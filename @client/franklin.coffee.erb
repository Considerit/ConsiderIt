#////////////////////////////////////////////////////////////
# Exploratory reimplementation of considerit client in React
#////////////////////////////////////////////////////////////

# Ugliness in this prototype: 
#   - Provision of @data() as a function via reactiveREST, rather than a straight up object. I couldn't
#     figure out a way to do it more cleanly. 
#   - Children needing to know the parent Proposal's key, and using active_proposal_key() to get it
#   - Programmer needing to know multiple ActiveREST cache keys to save new points to
#   - UI state and persisted data stored in same place (when saving, what to send to server?)
#   - Figuring out if the route was changed. Or more generally, knowing what the diff in state was
#     in the lifecycle methods now that we're not using @props or @state. Right now using a hack
#     (see use of _route_changed ActiveREST cache key)
#   - All UI state _must_ be declared in the @getDefaultData method for the component at which
#     that state will be stored. Otherwise, getters and setters won't be operative!
#   - Computed state not yet stored in ActiveREST
#   - Easy for programmer to accidently mess up ActiveREST cache
#   - Managing top_level_component in Router
#   - NewPoint CSS/HTML is still bulky, waiting on redesign

# ##
# React aliases
R = React.DOM

# ##
# Constants, especially used for layout styling
TRANSITION_SPEED = 700   # Speed of transition from results to crafting (and vice versa) 
BIGGEST_POSSIBLE_AVATAR_SIZE = 50
GRID_MAJOR = 48  #GRID_MAJOR = GRID_MINOR + GRID_GUTTER
GRID_MINOR = 30
GRID_GUTTER = 18
PAGE_WIDTH = 24 * GRID_MAJOR
CONTENT_WIDTH = PAGE_WIDTH - 4 * GRID_MAJOR
BODY_WIDTH = CONTENT_WIDTH - 8 * GRID_MAJOR - 2 * GRID_GUTTER
POINT_WIDTH = BODY_WIDTH / 2 - 20
POINT_CONTENT_WIDTH = POINT_WIDTH - 35 - GRID_GUTTER
HISTOGRAM_WIDTH = BODY_WIDTH    # Width of the slider / histogram base 
DECISION_BOARD_WIDTH = BODY_WIDTH + 4 # the four is for the border
REASONS_REGION_WIDTH = DECISION_BOARD_WIDTH + 2 * POINT_CONTENT_WIDTH + 4 * GRID_GUTTER + 4
MAX_HISTOGRAM_HEIGHT = 200

##
# Helpers that should probably go elsewhere

capitalize = (string) -> string.charAt(0).toUpperCase() + string.substring(1)
L = loading_indicator = R.div null, 'Loading...'

# Returns the top level Proposal component key. Components use this to grab data
# from its Proposal. This is a hack. Shadowing parent state would solve the problem.
# window.current_proposal = () ->
#         long_id = fetch('page')?.url.split('/')[1]
#         fetch('/page/' + long_id).proposal
getStanceSegment = (value) ->
  for i in [0..5]
    if value < stanceSegmentBoundaries[i + 1]
      return i
  return 6

user_opinions = {}
userOpinion = (user_key) ->
  user_opinions[user_key]
togglePage = (page) -> 
  $('.histogram_segment_pole').ensureInView
    offset_buffer: 150
    callback : -> 
      p = fetch('page')
      p.name = page
      save(p)


stanceSegmentBoundaries = { 0 : -1, 1 : -.9999, 2 : -0.5, 3 : -0.05, 4 : 0.05, 5 : 0.5, 6 : .9999 } 

stance_names = 
  6 : 'Rigidly Support'
  0 : 'Rigidly Oppose'
  5 : 'Firmly Support'
  1 : 'Firmly Oppose'
  4 : 'Lean Support'
  2 : 'Lean Oppose'
  3 : 'Are Neutral'

##
# StyleAnimator mixin
# Helper for components that implement animations.
# Applies styles defined in the component that change
# depending on state. Right now this mixin assumes that
# animations will be applied only on route changes. 
#
# A component that implements this mixin should define a method:
#     applyStyles : (animate = true)
# which puts the styles on the desired elements. 
StyleAnimator = 
  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) -> 
    @applyStyles fetch('_route_changed')

  applyStylesToElements : (styles, duration) ->
    $el = $(@getDOMNode())
    _.each _.keys(styles), (selector) -> 
      # Only apply styles if there are differences, for performance. 
      # This check doesn't work for transform properties because for Velocity we 
      # specify them as e.g. TranslateX: 4 rather than transform: translateX(4)
      styles_for_selector = styles[selector]
      styles_to_apply = {}
      $target = $el.find(selector)

      prop_map = $target.css(_.keys(styles_for_selector))
      if prop_map
        for property in _.keys(styles_for_selector)
          if prop_map[property] != styles_for_selector[property]
            styles_to_apply[property] = styles_for_selector[property]

      if _.size(styles_to_apply) > 0
        $target.velocity styles_to_apply, {duration}


## ##################
# React Components
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  mixins: [StyleAnimator]
  displayName: 'Proposal'

  ##
  # Lifecycle methods
  componentDidMount : -> 
    $el = $(@getDOMNode())
    $el.find('.fixed_proposal_heading').stickyTopBottom()

  componentDidUpdate : ->
    $el = $(@getDOMNode())
    $el.find('.fixed_proposal_heading').stickyTopBottom('update')
    
    # $el.find('.description_region').css
    #   top: $el.find('.fixed_proposal_heading').height() + 24

  ##
  # State-dependent styling
  applyStyles : (animate = true) ->  
    $el = $(@getDOMNode())
    duration = if animate then TRANSITION_SPEED else 0
    page = @data('page')

    # • Velocity requires properties to be pulled out (e.g. paddingLeft, 
    #   translateX, rather than using padding or transform)
    # • We use velocity even for 0 duration style applications to maintain 
    #   parity of style definition
    switch page.name
      when 'crafting'
        styles = 
          '.histogram_bar':        { opacity: '.2' }
          '.decision_board_body':  { translateX: 0, translateY: 0, width: "#{DECISION_BOARD_WIDTH}px", minHeight: "275px"}
          '.pros_by_community':    { translateX: 0 }
          '.cons_by_community':    { translateX: "#{DECISION_BOARD_WIDTH}px" }
        
        @applyStylesToElements styles, duration

        $el.find('.give_opinion_button').css 'visibility', 'hidden'
        _.delay => 
          #delay & check in case of quick switch between pages
          if page.name == 'crafting'         
            $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', ''
        , duration

      when 'results'
        your = @data(your_opinion_key)
        stance = your.stance
        segment = your.stance_segment

        give_opinion_button_width = 186
        gutter = .1 * give_opinion_button_width

        opinion_region_x = -gutter + (DECISION_BOARD_WIDTH - give_opinion_button_width + 2 * gutter) * (stance+1) / 2.0

        styles = 
          '.histogram_bar':         { opacity: '1' }
          '.decision_board_body':   { translateX: opinion_region_x, translateY: -18, width: "#{give_opinion_button_width}px", minHeight: "32px"}
          '.pros_by_community':     { translateX:  DECISION_BOARD_WIDTH / 2 }
          '.cons_by_community':     { translateX:  DECISION_BOARD_WIDTH / 2 }
        
        @applyStylesToElements styles, duration

        $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', 'none'
        _.delay => 
          #check in case of quick switch between pages
          if page.name == 'results' 
            $el.find('.give_opinion_button').css 'visibility', ''
        , duration  

  ##
  # Make this thing!
  render : ->
    proposal = @data()
    page = @data('page')
    points = page.points
    users = page.users
    included_points = proposal.your_opinion.point_inclusions
    initial_stance = proposal.your_opinion.stance
    highlighted_users = @data('histogram').highlighted_users

    description_region_style = {width: 1.25 * BODY_WIDTH}

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in proposal.opinions
      window.user_opinions[opinion.user] = opinion
    window.current_proposal = proposal.key
    window.your_opinion_key = proposal.your_opinion.key

    console.log(proposal.key, proposal.user)
    proposer = @data(proposal.user)

    R.div className:'proposal', key:@props.long_id, 'data-page':page.name,
      R.div className: 'fixed_proposal_heading', 
        R.span null,"#{if proposal.category && proposal.designator then proposal.category + ' ' + proposal.designator + ':' else ''}#{proposal.name}"

      #description

      R.div className:'description_region', style: description_region_style, 

        R.div className: 'context',
          # Avatar 
          #   className: 'proposer_avatar'
          #   key: proposal.user
          #   tag: R.img
          #   img_style: 'large'
          
          # R.span className: 'proposal_author_tic'
          
          R.div className: 'proposer_name', "posted by #{if proposer then proposer.name else ''}, Director of Business Development, Facebook" 

        R.div className: 'proposal_details', dangerouslySetInnerHTML:{__html: proposal.description}

    
      #feelings
      R.div className:'feelings_region', style : { width: BODY_WIDTH },
        OpinionFilter() #error in current activerest implementation makes you have to put components that other components depend on earlier

        Histogram()

      if page.auth_mode
        Auth()
      else
        #reasons
        R.div 
          className:'reasons_region'
          style : { width: REASONS_REGION_WIDTH }, #, left: -(REASONS_REGION_WIDTH - CONTENT_WIDTH) / 2 },
            #community pros
            CommunityPoints { key: 'pros' }

            DecisionBoard()

            #community cons
            CommunityPoints { key: 'cons' }


##
# Histogram
Histogram = ReactiveComponent
  displayName : 'Histogram'

  getDefaultProps : ->
    opinions: []

  ##
  # buildHistogram
  # Split up opinions into segments. For now we'll keep three hashes: 
  #   - all opinions
  #   - high level segments (the seven segments, strong supporter, neutral, etc)
  #   - small segments that represent individual columns in the histogram,
  #     now that we do not have wide bars per se
  buildHistogram : ->
    ##
    # Size the avatars. Size of avatar shrinks proportional to 1/sqrt(num_opinions)
    opinions = @data(current_proposal).opinions || []

    avatar_size = Math.min BIGGEST_POSSIBLE_AVATAR_SIZE, 
      Math.floor(BIGGEST_POSSIBLE_AVATAR_SIZE / Math.sqrt( (opinions.length + 1) / 10 )  )

    # Calculate about how many columns of opinions to put on the histogram. 
    columns_in_histogram = Math.floor(HISTOGRAM_WIDTH / avatar_size)

    max_slider_variance = 2.0 # Slider stances vary from -1.0 to 1.0. 

    # Assign each column in the histogram to a segment. Each column is an 
    # empty array which will eventually hold opinions.
    segments = ( [] for segment in [0..6] )
    for col in [0..columns_in_histogram]
      segment = getStanceSegment(max_slider_variance * col / columns_in_histogram - 1)
      segments[segment].push []

    # ensure neutral segment has 3 columns
    segments[3].push([]) while segments[3].length < 3   

    # Assign each Opinion to a column
    # This gets complicated because we treat the extremes and Neutral differently. 
    #  - The number of columns in the extremes is variable, with the max number
    #    of opinions per columns capped. Here we'll dynamically grow the number of 
    #    cols in each extreme, subdividing the cols whenever they hit their max number. 
    #  - There are three columns for Neutral. We distributed the opinions evenly 
    #    across these three. 
    #  - Opinions belonging to other places along the spectrum are mapped directly 
    #    to the column associated with that stance.     
    opinions_in_segment = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0}
    max_opinions_in_column = Math.floor MAX_HISTOGRAM_HEIGHT / avatar_size
    for opinion in opinions
      segment = getStanceSegment opinion.stance

      # If this is a Neutral opinion, fill up all three neutral cols equally
      if segment == 3
        segments[3][opinions_in_segment[3] % 3].push opinion

      # If this is an extreme opinion...
      else if segment in [0,6]
        last_col_in_segment = segments[segment].length - 1
        if segments[segment][last_col_in_segment].length == max_opinions_in_column - 1
          segments[segment].push []

        segments[segment][last_col_in_segment].push opinion

      # If this opinion is somewhere else on the spectrum...
      else
        adjusted_stance = Math.abs(opinion.stance - stanceSegmentBoundaries[segment])
        col_width = Math.abs( stanceSegmentBoundaries[segment + 1] - 
          stanceSegmentBoundaries[segment])/segments[segment].length
        segments[segment][Math.floor(adjusted_stance / col_width)].push opinion

      opinions_in_segment[segment] += 1

    # make sure that the extreme segment with fewest opinions has as 
    # many columns as the other extreme
    if segments[0].length != segments[6].length
      if segments[0].length > 
         segments[6].length then [bigger, smaller] = [segments[0], segments[6]] else 
                                 [bigger, smaller] = [segments[6], segments[0]]
      
      all_opinions_in_smaller = _.flatten(smaller)

      smaller.push([]) while smaller.length < bigger.length

      for column in smaller
        column.pop() while column.length > 0

      for opinion, idx in all_opinions_in_smaller
        smaller[idx%smaller.length].push opinion

    num_columns = _.flatten(_.values(segments), true).length

    [num_columns, segments, avatar_size]

  onClickHistogram : (ev) ->
    page = @data('page').name
    if page == 'crafting'
      togglePage('results')

  onSelectSegment : (ev) ->
    if @data('page').name == 'results'
      segment = $(ev.currentTarget).data('segment')

      selected_segment = @data('histogram').selected_segment

      # If clicking on already hard-selected segment, then we'll deselect. 
      segment = if selected_segment[0] == segment && 
                   selected_segment[1] then null else segment
      click_select = ev.type == 'click' 

      #ignore mouseEnter and mouseLeave events if selection was via click
      return if selected_segment && selected_segment[1] && !click_select 

      @data('histogram').selected_segment = [segment, click_select && segment]
      ev.stopPropagation()

  render : ->
    selected_segment = @data('histogram').selected_segment
    users_to_highlight = @data('histogram').highlighted_users
    [num_columns, segments, avatar_size] = @buildHistogram() #todo: memoize

    effective_histogram_width = num_columns * avatar_size
    margin_adjustment = -(effective_histogram_width - HISTOGRAM_WIDTH)/2
    #make sure that the neutral segment is centered
    margin_adjustment += (segments[0].length - segments[6].length) / 2 * avatar_size

    R.table 
      className: 'histogram'
      onClick:@onClickHistogram
      # onMouseLeave: @onSelectSegment
      style: { width: effective_histogram_width, marginLeft: margin_adjustment }, 
        R.tr null, 
          for bars, idx in segments.reverse()
            segment = 6 - idx
            is_selected = selected_segment[0] == segment
            R.td 
              className:"histogram_segment #{if is_selected then 'is_selected' else 'not_selected'}"
              key:segment
              # onMouseEnter: @onSelectSegment
              'data-segment':segment
              style : { opacity: (if is_selected && !selected_segment[0]? then '1' else '1') }
            ,
              R.table null,
                R.tr null,
                  for bar in bars
                    R.td className:"histogram_bar", style: {width: avatar_size},
                      for opinion in bar
                        Avatar 
                          tag: R.span, 
                          key: opinion.user
                          user: opinion.user
                          'data-segment':segment
                          style:
                            height: avatar_size
                            width: avatar_size
                            opacity: if users_to_highlight && 
                              !_.contains(users_to_highlight, opinion.user) 
                              then '.15' 
                              else if selected_segment[0] == null || is_selected 
                              then '1.0'
                              else '.15'
              if segment == 6
                R.div className:"histogram_segment_pole", 'Supporters'
              else if segment == 0
                R.div className:"histogram_segment_pole", 'Opposers'

##
# Slider
# Manages the slider and the UI elements attached to it. 
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [StyleAnimator]

  componentDidMount : -> 
    @setSlidability()

  componentWillUpdate : (prev_props, prev_state) ->
    @setSlidability()

  # We have a separate applyStyle here from Proposal because the Slider component
  # gets rerendered more frequently than the Proposal component (i.e. when the 
  # slider is being slid...forcing the entire Propoosal component to rerender
  # causes terrible performance).
  applyStyles : (animate = false) ->
    duration = if animate then TRANSITION_SPEED else 0
    $el = $(@getDOMNode())
    your_opinion = @data(your_opinion_key)

    mouth_scaler = if your_opinion.stance_segment >  3 then -1 else 1
    mouth_x      = if your_opinion.stance_segment == 3 then  0 else -7.5

    switch @data('page').name
      when 'crafting'
        styles = 
          '.bubblemouth': { scaleX: mouth_scaler * 1.5, scaleY: 1.5, translateY: 7, translateX: mouth_x * 1.5  }
          '.the_handle':  { scale: 2.5, translateY: -8 }

      when 'results'
        styles = 
          '.bubblemouth': { scaleX: mouth_scaler, scaleY: 1, translateY: -4.5, translateX: mouth_x  }
          '.the_handle':  { scale: 1, translateY: -9 }

    @applyStylesToElements styles, duration

  ##
  # setSlidability
  # Inits jQuery UI slider and enables/disables it between pages
  setSlidability : ->
    page = @data('page')
    page = page.name
    $slider_base = $(@getDOMNode()).find('.slider_base')
    if $slider_base.hasClass "ui-slider"
      $slider_base.slider(if page.auth_mode then 'disable' else 'enable')
    else
      $slider_base.slider
        disabled: page.auth_mode #@data('page').name == 'results'
        min: -1
        max: 1
        step: .01
        value: -@data(your_opinion_key).stance
        slide: (ev, ui) => 
          # Update the stance segment if it has changed. This facilitates 
          # the feedback atop the slider changing from e.g. 'strong 
          # supporter' to 'neutral'
          return false if ev.originalEvent.type != 'mousemove'

          your_opinion = @data(your_opinion_key)
          your_opinion.stance_segment = getStanceSegment -ui.value
          your_opinion.stance = -ui.value
          slider = @data('slider')
          slider.stance_segment = getStanceSegment -ui.value
          slider.stance = -ui.value
          if !slider.has_moved
            slider.has_moved = true
          save(slider)
          save(your_opinion)
        stop : (ev, ui) =>
          if @data('page').name == 'results'
            togglePage('crafting')

  togglePage : (ev) ->
    page = @data('page')
    if !page.auth_mode
      new_page = if page.name == 'results' then 'crafting' else 'results'
      togglePage(new_page)
    ev.stopPropagation()

  render : ->
    slider = @data('slider')
    stance = slider.stance
    segment = slider.stance_segment
    page = @data('page')
    page = page.name
    sticky = @data('decisionboard').sticky

    #jquery UI slider will pick an el with this class name up
    props_for_slider_handle = { className:'ui-slider-handle' } 
    if page == 'results'    
      _.extend props_for_slider_handle, 
        onClick: => @togglePage
        style: { cursor : 'pointer' } 

    # Can't be dynamically set b/c of integration with asset fingerprinting. This is 
    # also why this file is ERB
    if segment == 3
      if page == 'crafting'
        bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
      else
        bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-results.png' %>"
    else
      if page == 'crafting'
        bubblemouth_src = "<%= asset_path 'bubblemouth-crafting.png' %>"
      else
        bubblemouth_src = "<%= asset_path 'bubblemouth-results.png' %>"

    slider_feedback_percent = 
      if segment == 3 
      then "Neutral" 
      else "#{Math.floor(Math.abs(stance) * 100)}% #{if segment > 3 then 'Support' else 'Oppose'}"

    slider_feedback_bucket = stance_names[segment]
    
    face_left_eye_style = 
      transform: 
        if segment in [0, 6] 
        then 'scale(.9, .8)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_right_eye_style = 
      transform: 
        if segment in [0, 6] 
        then 'scale(1.1, 1.2)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_mouth_style = 
      transform: 
        "scale(#{.4 + .3 * Math.abs(stance) }, #{.08 + .4 * stance}) 
         translate(0, #{-2 - 5 * Math.abs(stance)}px) 
         rotate(45deg) 
         skew(#{if segment in [0,6] then '10deg' else '0deg'})"

    # safari only respects -webkit-transform
    crossbrowserTransformProperty = (props) -> _.extend props,
      '-webkit-transform' : props.transform
      '-ms-transform' : props.transform
      '-moz-transform' : props.transform

    crossbrowserTransformProperty sty for sty in [
      face_left_eye_style, face_right_eye_style, face_mouth_style]

    # ugly access here...this is a hack that hides a dependency between slider and histogram 
    triangle_width = 
      if sticky
      then 0 
      else $('.histogram_segment[data-segment="0"]').width() + 5

    slider_base_triangle_style = 
      borderLeft: "#{triangle_width}px solid transparent"
      borderRight: "#{triangle_width}px solid transparent"

    if !slider.has_moved 
      slider_feedback = 'Slide Your Overall Opinion' 
    else 
      slider_feedback = "You #{slider_feedback_bucket}"


    R.div className: 'slider', 
      R.div className:'slider_base', style : {width: HISTOGRAM_WIDTH}, 
        R.div 
          className: 'slider_base_triangle_left'
          style: _.extend({}, slider_base_triangle_style, {left: -triangle_width})
        R.div 
          className: 'slider_base_triangle_right'
          style: _.extend({}, slider_base_triangle_style, {right: -triangle_width})
        R.div props_for_slider_handle, 
          R.div className: 'the_handle', onClick: @togglePage,
            R.div className: 'face_mouth face_part', style: face_mouth_style
            R.div className: 'face_left_eye face_eye face_part', style: face_left_eye_style
            R.div className: 'face_right_eye face_eye face_part', style: face_right_eye_style
            R.div className: 'drag_arrow right', '>' if page == 'crafting' && !slider.has_moved && !page.auth_mode
            R.div className: 'drag_arrow left', '<' if page == 'crafting' && !slider.has_moved && !page.auth_mode

          R.img className:'bubblemouth', src: bubblemouth_src
          R.div 
            className:'slider_feedback'
            'data-stance-segment': segment
            style: {visibility: if sticky && !page.auth_mode then 'visible' else 'visible'}
          , slider_feedback

##
# OpinionFilter
# Filters whose opinions are displayed
OpinionFilter = ReactiveComponent
  displayName: 'OpinionFilter'

  onSelectSegment : (segment) ->
    console.log('Selected', segment)
    if @data('page').name == 'results'
      hist = @data('histogram')
      hist.selected_segment = if hist.selected_segment == segment then [null, null] else [segment, segment != null]
      save(hist)

  render : ->
    @hist = @data('histogram')
    if not @hist.selected_segment
      return L
    filter_options = ['show all opinions',
        'only rigid opposers',
        'only firm opposers',
        'only lean opposers',
        'only neutrals',
        'only lean supporters',
        'only firm supporters',
        'only rigid supporters']

    R.div className: 'opinion_filter_region',
      for phrase, i in filter_options

        # Shift i by 1, and start with null
        i = i-1
        if i == -1
          i = null

        c = "filter_option"
        if @hist.selected_segment[0] == i
          c = c + ' selected'
        R.a className: c, onClick: (=> @onSelectSegment(i)), phrase


##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'

  componentDidMount : ->
    @setStickyHeader()

    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = @data(your_opinion_key)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)
          $el.removeClass "user_is_hovering_on_a_drop_target"
      out : (ev, ui) => 
        $el.removeClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')
      over : (ev, ui) => 
        $el.addClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')

  componentDidUpdate : -> 
    $el = $(@getDOMNode())    
    if !@initial_position_fixed
      $el.stickyTopBottom('fix_initial_position')
      @initial_position_fixed = true

  setStickyHeader : ->
    $el = $(@getDOMNode())

    slider_region_height =  135 #$el.find('.slider .the_handle').outerHeight() + $el.find('.slider .slider_feedback').outerHeight() + 15 + 20 #15 is bubblemouth

    $el.stickyTopBottom
      container: $('.reasons_region')
      top_offset: $('.fixed_proposal_heading').outerHeight() + slider_region_height
      bottom_offset: 20
      docks: =>
              d = @data('decisionboard')
              d.sticky = false
              save(d)
      undocks: =>
              d = @data('decisionboard')
              d.sticky = true
              save(d)
      conditional: => @data('page').name == 'crafting'

  clickSave : -> 
    if @data('/current_user').id
      togglePage('results')
    else
      page = @data('page')
      page.auth_mode = 'register'
      save(page)

  render : ->
    page = @data('page')
    page = page.name
    current_user = @data('/current_user')

    opinion_region_style = 
      left: '50%'
      width: DECISION_BOARD_WIDTH
      marginLeft: -DECISION_BOARD_WIDTH / 2

    R.div className:'opinion_region focal_wrapper', style: opinion_region_style,
      Slider()

      R.div 
        className:'decision_board_body focal_area'
        onClick: => if @data('page').name == 'results' then togglePage('crafting')
      ,

        R.div null, 
          # only shown during crafting, but needs to be present always for animation
          R.div className: 'your_points',
            # your pros
            YourPoints { valence: 'pros' }

            # your cons
            YourPoints { valence: 'cons' }

          # only shown during results, but needs to be present always for animation
          R.a 
            className:'give_opinion_button primary_button'
          , 'Give your Opinion'

      R.div 
        className:'save_opinion_button primary_button'
        onClick: @clickSave
      , 'Save your opinion and see results'

      R.a 
        className:'cancel_opinion_button primary_cancel_button'
        onClick: (=> togglePage('results'))
      , 'discard your opinion'  


##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  render : ->
    included_points = @data(your_opinion_key).point_inclusions
    left_or_right = if @props.valence == 'pros' then 'left' else 'right'

    R.div 
      className:"points_on_decision_board #{@props.valence}_on_decision_board"
      style: { width: POINT_WIDTH }
    ,
      R.div className:'points_heading_label',
        "Speak Your #{capitalize(@props.valence)}"

      R.ul null,
        for point in included_points
          if @data(point).is_pro == (@props.valence == 'pros')
            Point { key: point, location_class: 'decision_board_point' }

        R.div className:'add_point_drop_target',
          R.div className: "drop_target_circle_#{left_or_right}"
          R.img className:'drop_target', src: "<%= asset_path 'drop_target.png' %>"
          R.span className:'drop_prompt',
            #"Drag #{@props.valence} points from the #{if @props.valence == 'pro' then 'left' else 'right'} that resonate with you."
            "Drag a #{capitalize(if @props.valence=='pros' then 'pro' else 'con')} from the #{left_or_right}"

        NewPoint { valence: @props.valence }

##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'

  componentDidMount : ->
    @setPointMouseover()

  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  setPointMouseover : ->
    $el = $(@getDOMNode())

    $el.on 'mouseenter mouseleave', '.includers', (ev) => 

      if @data('page').name == 'results'
        point = $(ev.currentTarget).parent().data('id')
        includers = @data(point).includers
        proposal_data = @data(current_proposal)

        hist = @data('histogram')
        if ev.type == 'mouseenter'          
          hist.highlighted_users = includers
          save(hist)
        else if ev.type == 'mouseleave'
          _.delay =>
            if proposal_data.highlighted_users == includers
              proposal_data.highlighted_users = null
              save(hist)
          , 200

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @data(current_proposal).points || []
    newpoint_threshold = 
      (_.sortBy points, (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = @data('page').name == 'results'
    selected_segment = @data('histogram').selected_segment
    proposal = @data(current_proposal)
    included_points = @data(your_opinion_key).point_inclusions
    points = proposal.points
    opinions = proposal.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_segment[0]?
      # If there is a histogram segment selected, we'll have to filter down 
      # to the points that users in this segment think are important, and 
      # order them by resonance to those users. I'm doing this quite inefficiently.
      point_inclusions_per_point_for_segment = {} # map of points to including users
      _.each opinions, (opinion) =>
        if opinion.stance_segment == selected_segment[0] && opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point_for_segment)
              point_inclusions_per_point_for_segment[point] = 1
            else
              point_inclusions_per_point_for_segment[point] += 1

      points = 
        _.filter points, (pnt) -> pnt.key of point_inclusions_per_point_for_segment
      points = 
        _.sortBy points, (pnt) -> -point_inclusions_per_point_for_segment[pnt.key]
    else
      # Default sort order
      points = 
        _.sortBy points, (pnt) => - if is_results then pnt.score else pnt.persuasiveness

    points

  render : ->
    selected_segment = @data('histogram').selected_segment

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key

    R.div 
      className:"points_by_community #{@props.key}_by_community"
      style: { width: POINT_CONTENT_WIDTH, minHeight: jQuery(window).height() }
    , 
      R.div className:'points_heading_label', 
        if @data('page').name == 'results' then "Top #{label}" else "Others' #{label}"
        R.p className:'points_segment_label', style: {visibility: if selected_segment[0] == null then 'hidden' else 'visible'},
          if selected_segment[0] == null then '-' else "for #{stance_names[selected_segment[0]]}s"          

      R.ul null, 
        if points.length > 0
          for point in points
            R.div null,
              Point 
                key: point, 
                is_new: Date.parse(point.created_at) > newpoint_threshold
                location_class : 'community_point'
        else
          R.li className: 'empty_point', "No #{label} listed"

##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  componentDidMount : ->
    @setShowDetails()
    @setDraggability()

  componentDidUpdate : -> 
    @setDraggability()

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page

    disable = @data('page').name == 'results'
    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.location_class == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = @data(your_opinion_key)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, @props.key
          save(your_opinion)
          console.log('Saved it.', your_opinion)
        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable

  setShowDetails : ->
    $(@getDOMNode()).click (ev) =>
      local = @data(@local_key)
      local.show_details = !local.show_details
      save(local)

  buildIncluders : -> 
    point = @data()
    to_remove = [point.user]

    # only show includers from this stance segment if a segment is selected
    selected_segment = @data('histogram').selected_segment
    if selected_segment[0]?
      for includer in point.includers
        stance_segment = @data(userOpinion(includer)).stance_segment
        if stance_segment && stance_segment != selected_segment[0]
          to_remove.push(includer)

    _.difference point.includers, to_remove

        
  renderIncluders : ->

    if @data().includers

      includers = @buildIncluders()

      s = #includers_style
        rows: 8
        dx: 2
        dy: 5
        col_gap: 8
        side_offset: 32 + 14 + 1

      # Now we'll go through the list from back to front
      i = includers.length

      for includer in includers
        i -= 1
        curr_column = Math.floor(i / s.rows)
        side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
        top_offset = (i % s.rows) * s.dy + 4
        left_right = if @data().is_pro then 'left' else 'right'
        style = { top: top_offset }
        style[left_right] = -side_offset

        # Finally draw the guy
        Avatar
          key: includer
          tag: R.span
          className: "point_includer_avatar"
          style: style

  renderNewIndicator : ->
    if @data().includers
      side_offset = 51
      left_right = if @data().is_pro then 'left' else 'right'
      style = 
        position: 'absolute'
        color: 'rgb(255,22,3)'
        fontSize: '11px'
        top:'41px'
        backgroundColor: 'white', zIndex: 5
      style[left_right] = "#{-side_offset}"
      R.span {style: style}, '*New*'

  render : -> 
    point = @data()

    selected_segment = @data('histogram').selected_segment
    author_opinion = @data(userOpinion(point.user))

    R.li 
      className: "point closed_point #{@props.location_class} 
        #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
    ,
  
      if @props.location_class == 'community_point' && @props.is_new
        @renderNewIndicator()

      R.div className:'includers', 
        if @props.location_class == 'community_point'
          @renderIncluders()

        if !selected_segment[0] || ( author_opinion && author_opinion.stance_segment == selected_segment[0] )
          Avatar tag: R.span, key: point.user, className:"point_author_avatar"

      R.div className:'point_content', style : { width: POINT_CONTENT_WIDTH },
        if @props.location_class == 'community_point'
          R.img 
            className: 'community_point_mouth'
            src: "<%= asset_path 'community_point_mouth.png' %>"

        R.div className:'point_nutshell',
          point.nutshell
          if point.text
            if @data(@local_key).show_details or 
              (point.nutshell.length + point.text.length) < 210
                R.div className: 'point_details', dangerouslySetInnerHTML:{__html: point.text}
            else
              R.span className: 'point_details_tease', 
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text() + "... [more]"

        # R.a className:'open_point_link',
        #   "#{@props.comment_count} comment#{if @props.comment_count != 1 then 's' else ''}"

##
# NewPoint
# Handles adding a new point into the system. Only rendered when proposal is
# in Crafting state. Manages whether the user has clicked "add a new point". 
# If they have, show new point form. 
NewPoint = ReactiveComponent
  displayName: 'NewPoint'
  componentDidUpdate : ->
    if @local.edit_mode
      $(@getDOMNode()).find('#nutshell').focus()

  handleAddPointBegin : (ev) -> 
    @local.edit_mode = true
    @local.add_details = false
    save(@local)

  handleAddPointCancel : (ev) -> 
    @local.edit_mode = false
    save(@local)
  handleAddDetails : (ev) -> 
    @local.add_details = true
    save(@local)
  handleSubmitNewPoint : (ev) ->
    $form = $(@getDOMNode())

    current_user = '/user/-2' #anon user
    point =
      key : '/new/point'
      nutshell : $form.find('#nutshell').val()
      text : $form.find('#text').val()
      is_pro : @props.valence == 'pros'
      user : current_user
      comment_count : 0 
      includers : [current_user]
      proposal : @data(current_proposal).key
      hide_name : $form.find("sign_name-#{@props.valence}").val()
    save(point)

    # proposal = @data(current_proposal)
    # points = proposal.points.splice(0)
    # points.push point
    # proposal.points = points

    # # how to not push to multiple places...
    # save(point)
 
    #included_points = proposal_data.included_points.splice(0)
    #included_points.push point
    #proposal_data.included_points = included_points

    @local.edit_mode = false
    save(@local)

  render : ->
    #TODO: refactor HTML/CSS for new point after we get better sense of new point redesign
    @local = @data @local_key,
        edit_mode : false
        sign_name : true
        add_details : false

    R.div className:'newpoint',
      if !@local.edit_mode
        R.div className:'newpoint_prompt',
          R.span className:'qualifier', 
            'or '
          R.span className:'newpoint_bullet', dangerouslySetInnerHTML:{__html: '&bull;'}
          R.a className:'newpoint_link', 'data-action':'write-point', onClick: @handleAddPointBegin,
            "Write a new #{capitalize(if @props.valence == 'pros' then 'pro' else 'con')}"
      else
        R.div className:'newpoint_form',
          R.input id:'is_pro', name: 'is_pro', type: 'hidden', value: "#{@props.valence == 'pros'}"
          R.label htmlFor:'nutshell', 'Your point'
          CharacterCountTextInput id:'nutshell', className:'newpoint_nutshell', maxLength:140, name:'nutshell', pattern:'^.{3,}', placeholder:'Make this summary succinct.', required:'required'
          
          if @local.add_details
            R.div null, 
              R.label htmlFor:'text', 'Expand on your point'
              AutoGrowTextArea id:'text', className:'newpoint_description', name:'text', placeholder:'Provide background and/or back your point up with evidence.', required:'required', min_height: 100
          else
            R.a className: 'add_details', onClick: @handleAddDetails, title: 'Provide background and/or back your point up with evidence.',
              R.i className: 'fa-caret-right fa'
              R.span null, 'Expand on your point'

          R.div className:'newpoint_hide_name',
            R.input className:'newpoint-anonymous', type:'checkbox', id:"sign_name-#{@props.valence}", name:"sign_name-#{@props.valence}", checked: @local.sign_name, onChange: (=> @local.sign_name = !@local.sign_name)
            R.label htmlFor: "sign_name-#{@props.valence}", title:'Signing your point with your name lends it more weight with other participants.', 'Sign your name'
          
          R.div className:'newpoint-submit',
            R.input className:'button primary_button', action:'submit-point', type:'submit', value:'Done', onClick: @handleSubmitNewPoint

            R.a className:'newpoint-cancel primary_cancel_button', onClick: @handleAddPointCancel,
              'cancel'

##
# Avatar
# Displays a user's avatar
# Supports straight up img src, or using the CSS-embedded b64 for each user
Avatar = ReactiveComponent
  has_multiple_instances_with_same_key: true
  displayName: 'Avatar'
  
  getDefaultProps : ->
    key: '/user/-1' # defaults to anonymous user
    tag: R.img
    img_style: null #null defaults to the css-based b64 embedded images

  componentWillUpdate : -> 
    if @data(@local_key).show_details
      @insertUserName()

  insertUserName : ->
    $el = $(@getDOMNode())
    pos = $el.offset()

    $name = $("<span class='hover_avatar_name'>#{@data().name}</span>")
    $('body').append $name   # ugly!

    $name.css 
      left: pos.left - $name.width() / 2 + $el.width()/2
      top: pos.top - $name.height()

  showDetails : (ev) -> 
    local = @data(@local_key)
    local.show_details = true
    save(local)

  hideDetails : (ev) -> 
    $('.hover_avatar_name').remove()
    local = @data(@local_key)
    local.show_details = false
    save(local)

  render : ->
    if Number.isInteger (@props.key)
      console.error('Not a good key', @props.key)
      console.trace()
      window.foo = "/user/#{@props.key}"
      console.log(nona.cache["/user/#{@props.key}"])
      @props.key = "/user/#{@props.key}"
    if !@props.key
      @props.key = "/user/-1"
    user = @data(@props.key)
    @data(@local_key) # just to register a dependence
    className = "#{@props.className} avatar"
    id = "avatar-#{user.key.split('/')[2]}"

    if @props.img_style && user.key != -1
      avatar_file_name = user.avatar_file_name

      console.log("Mike hasn't made this avatar's image work yet!  Fix the file line below:")
      if avatar_file_name
        filename = "/system/avatars/#{@props.key}/#{@props.img_style}/#{avatar_file_name}"

    attrs = 
      className: className
      id: id
      'data-id': @props.key
      onMouseEnter: @showDetails
      onMouseLeave: @hideDetails

    attrs.src = filename if filename
    
    @transferPropsTo @props.tag attrs


UserBar = ReactiveComponent
  displayName: 'UserBar'

  logout : -> 
    $.ajax Routes.current_user_path(),
      type : 'delete'
      success : (data) =>
        #TODO: update CSRF
        #TODO: clear current user
        current_user = @data('/current_user')
        current_user.id = current_user.email = current_user.password = null
        current_user.csrf = data.csrf      
        @data('page').auth_mode = null
        @data('auth').provider = null
        @data('auth').email = null
        @data('auth').name = null
        @data('auth').image_url = null

      error : (xhr, status, error) -> 
        console.error 'Error logging out: ', error

  render: ->
    current_user = @data('/current_user')
    if current_user.id
      R.div className: 'userbar', 
        Avatar key: current_user.id, tag: R.span, className: 'userbar_avatar', style: {height: 20, width: 20}
        R.a onClick: @logout, 'logout'
    else 
      R.div null

AutoGrowTextArea = ReactiveComponent
  displayName: 'AutoGrowTextArea'  

  getDefaultData : -> 
    height: @props.min_height

  autoGrow : -> 
    scroll_height = @getDOMNode().scrollHeight
    if scroll_height > @getDOMNode().clientHeight
      @data(@local_key).height = scroll_height + 5

  render : -> 
    @transferPropsTo R.textarea onKeyUp: @autoGrow, style: {height: @data(@local_key).height} 


CharacterCountTextInput = ReactiveComponent
  displayName: 'CharacterCountTextInput'

  getDefaultData : -> 
    count : 0

  render : -> 
    class_name = "is_counted"
    R.div style: {position: 'relative'}, 
      @transferPropsTo R.textarea className: class_name, onChange: (=> @data(@local_key).count = $(@getDOMNode()).find('textarea').val().length  )
      R.span className: 'count', @props.maxLength - @data(@local_key).count




##
# AuthHeader
# Should be refactored into Auth. Shares styles with Slider.
AuthHeader = ReactiveComponent
  displayName: 'AuthHeader'

  componentDidMount : -> 
    stance = (window.your_opinion_key and @data(your_opinion_key).stance) or 0
    $slider_base = $(@getDOMNode()).find('.slider_base')
    if !$slider_base.hasClass "ui-slider"
      $slider_base.slider
        disabled: true
        min: -1
        max: 1
        step: .01
        value: -stance

  toggleAuthMode : -> 
    page = @data('page')
    current_user = @data('/current_user')
    email = $(@getDOMNode()).find('#user_email').val()

    @data('auth').email = email if email && email.length > 0
    page.auth_mode = if page.auth_mode == 'register' then 'login' else 'register'    
    current_user.errors = []

  render : ->
    stance =  @data(your_opinion_key).stance
    segment = @data(your_opinion_key).stance_segment
    page = @data('page')

    # Can't be dynamically set b/c of integration with asset fingerprinting. This is 
    # also why this file is ERB
    if segment == 3
      bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
    else
      bubblemouth_src = "<%= asset_path 'bubblemouth-crafting.png' %>"

    slider_feedback = 'Please Introduce Yourself' 

    mouth_scaler = if segment > 3 then -1 else 1
    mouth_x =      if segment == 3 then 0 else -7.5


    bubble_mouth_props = 
      transform: "scale(#{mouth_scaler * 1.5}, 1.5) translate(#{mouth_x * 1.5}px, 7px)"
    handle_props = 
      transform: "scale(2.5) translateY(-8px)"

    crossbrowserTransformProperty = (props) -> _.extend props,
      '-webkit-transform' : props.transform
      '-ms-transform' : props.transform
      '-moz-transform' : props.transform

    crossbrowserTransformProperty bubble_mouth_props
    crossbrowserTransformProperty handle_props

    R.div className: 'slider', 
      R.div className:'slider_base', style : {width: HISTOGRAM_WIDTH}, 
        R.div className: 'ui-slider-handle', 
          R.div className: 'the_handle', onClick: @togglePage, style: handle_props
          R.img className:'bubblemouth', src: bubblemouth_src, style: bubble_mouth_props
          R.div className:'slider_feedback', 
            slider_feedback

            if page.auth_mode in ['login', 'register']
              R.div className: 'switch_auth_mode', 
                R.span null, if page.auth_mode == 'register' then 'If you already have an account, ' else 'If you don\'t have an account, '
                R.a className: 'toggle_auth', onClick: @toggleAuthMode, if page.auth_mode == 'register' then 'Log In' else 'Create an Account'




Auth = ReactiveComponent
  displayName: 'Auth'

  componentDidMount : -> 
    $(document).scrollTop $(@getDOMNode()).find('.slider_feedback').offset().top - 10

  startThirdPartyAuth : (provider) -> 
    new ThirdPartyAuthHandler
      provider : provider
      callback : (user_data) => 
        if 'key' of user_data
          # user already existed and now we've logged in via third party        
          current_user = @data('/current_user')
          page = @data('page')
          current_user.id = user_data.id
          current_user.name = user_data.name          
          current_user.csrf = user_data.csrf
          page.name = 'results'
          page.auth_mode = null
        else 
          # we're prepped to create an account...
          #TODO: show user the pledge
          # @authenticateWithServer user_data
          @auth = @data('auth')
          @auth.provider = provider
          @auth.name = user_data.name
          @auth.image_url = user_data.avatar_url
          @auth.email = user_data.email

  submitAuth : (ev) -> 
    ev.preventDefault()
    $el = $(@getDOMNode())

    email = $el.find('#user_email').val()
    password = $el.find('#user_password').val()
    name = $el.find('#user_name').val()

    #proper ActiveREST:
    # current_user.email = email
    # current_user.password = password
    # ...

    #scratch: 

    user_data = 
      email: email
      password: password
      name: name

    if $el.find('#user_verification_code').length > 0
      user_data.reset_password_token = $el.find('#user_verification_code').val()

    @authenticateWithServer user_data, true

  authenticateWithServer : (user_params, submit_avatar_form = false) -> 
    current_user = @data('/current_user')
    params = 
      authenticity_token: current_user.csrf
      user: user_params

    $.ajax 
      type: 'POST'
      url: Routes.current_user_path()
      beforeSend: (xhr) -> xhr.setRequestHeader('X-CSRF-Token', current_user.csrf)
      data: params
      success : (data, status, xhr) => 
        page = @data('page')
        current_user = @data('/current_user')
        current_user.id = data.id
        current_user.errors = if data.errors then data.errors else []
        current_user.csrf = data.csrf
        current_user.name = data.name

        # hack for submitting file data in ActiveREST for now
        # we'll just submit the file form after user is signed in
        if submit_avatar_form
          $('#user_avatar_form').ajaxSubmit
            type: 'PUT'
            data: 
              authenticity_token: current_user.csrf
            success: (data, status, xhr) -> 
              current_user.id = data.id
              current_user.errors = if data.errors then data.errors else []
              current_user.csrf = data.csrf
              current_user.name = data.name

        if !current_user.errors || current_user.errors.length == 0
          page.name = 'results'
          page.auth_mode = null
          current_user.errors = []

      error : (xhr, status, error) -> 
        console.error 'Error logging in: ', error

  sendPasswordReminder : -> 
    email = $('#user_email').val()
    $.post Routes.send_password_reset_token_path(), {user : {email: email}}, (data) =>
      if data.errors && data.errors.length > 0
        current_user = @data('/current_user')
        current_user.errors = data.errors
      else 
        page = @data('page')
        page.auth_mode = 'password_reminder'



  render: -> 
    current_user = @data('/current_user')
    page = @data('page')
    auth = @data('auth')

    focal_wrapper_style = 
      left: '50%'
      width: DECISION_BOARD_WIDTH
      marginLeft: -DECISION_BOARD_WIDTH / 2

    R.div className:'auth_region focal_wrapper', style: focal_wrapper_style,
      AuthHeader()

      R.div className:'auth focal_area',

        if page.auth_mode in ['login', 'register'] && !auth.provider

          R.div className: 'third_party_auth',
            R.label className: 'third_party_call', 'Instantly:'
            R.button className: 'third_party_option facebook', onClick: (=> @startThirdPartyAuth('facebook')),
              R.i className: 'fa fa-facebook'
              R.span null, 'facebook'
            R.button className: 'third_party_option google',  onClick: (=> @startThirdPartyAuth('google')),
              R.i className: 'fa fa-google'
              R.span null, 'google'
            if page.auth_mode in ['login', 'password_reminder']
              R.button className: 'third_party_option twitter',  onClick: (=> @startThirdPartyAuth('twitter')),
                R.i className: 'fa fa-twitter'
                R.span null, 'twitter'

            R.div className: 'separator', dangerouslySetInnerHTML:{__html: "&mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;  <label>or</label>  &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;"}

        if page.auth_mode in ['login', 'password_reminder']
          # logging in

          R.div null, 
            R.label className: 'auth_section_label', if page.auth_mode == 'login' then 'By email address:' else 'Change your password to login'

            R.table className: 'auth_fields login', 
              R.tr null, 
                R.td className: 'label_cell',
                  if page.auth_mode == 'login'  
                    R.label htmlFor: 'user_email', 'email:'
                R.td className: 'field_cell', 
                  R.input id: "user_email", defaultValue: auth.email, name: "user[email]", placeholder: "email@address", required: "required", type: if page.auth_mode == 'login' then "email" else "hidden"

              R.tr null, 
                R.td className: 'label_cell', 
                  switch page.auth_mode
                    when 'login'
                      R.label htmlFor: 'user_password', 'password:'
                    when 'password_reminder'
                      R.label htmlFor: 'user_password', 'new password:'

                R.td className: 'field_cell', 
                  R.input id: "user_password", name: "user[password]", placeholder: (if page.auth_mode == 'login' then "password" else "new password"), required: "required", type: "password"

                  if page.auth_mode == 'login'
                    R.a className: 'forgot_password', onClick: @sendPasswordReminder, 'I forgot! Email me password instructions.'

              if page.auth_mode == 'password_reminder'
                R.tr null, 
                  R.td className: 'label_cell', 
                    R.label htmlFor: 'user_verification_code', 'verification code:'

                  R.td className: 'field_cell', 
                    R.input id: "user_verification_code", name: "user[password_code]", placeholder: "verification code", required: "required", type: "text"
                    R.div className: 'password_verification_explanation', "Find code in an email just sent to you."

        else 
          # creating new account
          R.table className: 'auth_fields register', 
            R.tr null, 
              R.td className: 'label_cell',
                R.label htmlFor: 'user_name', 'Hi, my name is:'
              R.td className: 'field_cell', 
                R.input id: "user_name", value: auth.name, onChange: (=> auth.name = $('#user_name').val()), name: "user[name]", placeholder: "first and last name", required: "required", type: "text"

            if auth.provider
              R.tr null, 

                R.td className: 'label_cell',
                  R.label htmlFor: 'user_provider', 'I login via:'
                R.td className: 'field_cell', 
                  switch auth.provider
                    when 'facebook'
                      R.button className: 'third_party_option facebook', style: {cursor: 'default'},
                        R.i className: 'fa fa-facebook'
                        R.span null, 'facebook'
                    when 'google'
                      R.button className: 'third_party_option google', style: {cursor: 'default'},
                        R.i className: 'fa fa-google'
                        R.span null, 'google'
                    when 'twitter'
                      R.button className: 'third_party_option twitter', style: {cursor: 'default'},
                        R.i className: 'fa fa-twitter'
                        R.span null, 'twitter'

            else

              R.tr null, 

                R.td className: 'label_cell',
                  R.label htmlFor: 'user_email', 'I login as:'
                R.td className: 'field_cell', 
                  R.input id: "user_email", defaultValue: auth.email, name: "user[email]", placeholder: "email@address", required: "required", type: "email"
                  R.input id: "user_password", name: "user[password]", placeholder: "password", required: "required", type: "password", pattern: ".{5,}"


            R.tr null, 
              R.td className: 'label_cell', 
                R.label htmlFor: 'user_avatar', 'I look like this:'
              R.td className: 'field_cell',
                # hack for submitting file data in ActiveREST for now
                # we'll just submit the file form after user is signed in
                R.form id: 'user_avatar_form',action: Routes.current_user_path(), 

                  R.div className: 'avatar_preview_enclosure',
                    R.img id: 'avatar_preview', src: if auth.image_url then auth.image_url else null #todo: make sure that if user overrides image_url, that the new image is used
                
                  R.input id: 'user_avatar', name: "user[avatar]", type: "file", onChange: (ev) -> 
                    input = $('#user_avatar')[0]
                    if input.files && input.files[0]
                      reader = new FileReader()
                      reader.onload = (e) ->
                        $("#avatar_preview").attr 'src', e.target.result
                      reader.readAsDataURL input.files[0]
                    else
                      $("#avatar_preview").attr('src', "<%= asset_path 'no_image_preview.png' %>")

            R.tr null,
              R.td className: 'label_cell', 
                R.label null, 'Community pledge:'
              R.td className: 'field_cell',
                R.ul className: 'pledges',
                  R.li className: 'pledge', 
                    R.input className:'pledge-1', type:'checkbox', id:"pledge-1", name:"pledge-1"
                    R.label htmlFor: "pledge-1", 'I will not attack or mock others.'
                  R.li className: 'pledge', 
                    R.input className:'pledge-2', type:'checkbox', id:"pledge-2", name:"pledge-2"
                    R.label htmlFor: "pledge-2", 'I will speak only on behalf of myself.'
                  R.li className: 'pledge', 
                    R.input className:'pledge-3', type:'checkbox', id:"pledge-3", name:"pledge-3"
                    R.label htmlFor: "pledge-3", 'I will use only one account to participate.'



        if current_user.errors && current_user.errors.length > 0
          R.div className: "auth_errors", 
            R.i className: 'fa fa-exclamation-circle'
            R.span null, "#{current_user.errors.join(', ')}"


      R.div null, 
        R.div 
          className:'auth_button primary_button'
          onClick: @submitAuth
        , if page.auth_mode == 'register' then 'Create account and save your opinion' else 'Login and save your opinion'

        R.a 
          className:'cancel_auth_button primary_cancel_button'
          onClick: (=> page.auth_mode = null)
        , 'cancel log in'



Page = ReactiveComponent
  displayName: 'Page'

  updateUserOpinions: =>
  render : -> 
    default_state =
      name : @props.initial_page,
      url : "/#{@props.long_id}#{if @props.initial_page == 'results' then '/results' else ''}",
      auth_mode : null

    page = @data("/page/#{@props.long_id}", default_state)

    R.div 'data-authmode': page.auth_mode,
      R.div className: 'l_header', 
        UserBar()      
      R.div id: 'body', style : { minWidth: PAGE_WIDTH }, 
        R.div id: 'inner_body', #style : { width: CONTENT_WIDTH },
          if page.proposal
            Proposal key: page.proposal
          else
            loading_indicator
      R.div className: 'l_footer'


## ########################
## Initialize data & defaults

fetch 'histogram',
  highlighted_users : null
  selected_segment : [null, null]

fetch 'slider',
  has_moved : false

fetch 'decisionboard',
  sticky : false

fetch 'page',
  url : window.location.pathname
  name : ''

fetch 'auth',
  email : null
  name : null
  image_url : null
  provider : null


fetch('/current_user')


##
# load users' pictures
$.get Routes.get_avatars_path(), (data) -> $('head').append data



##
# Backbone routing
# Note: not committed to backbone. Want to experiment with other routing techniques too.
top_level_component = null
Router = Backbone.Router.extend

  routes :
    ":proposal(/)": "proposal"
    ":proposal/results(/)": "results"

  proposal : (long_id, page = 'crafting') ->
    if !top_level_component
      top_level_component = React.renderComponent Page(
                                         long_id : long_id
                                         initial_page : page
                                         ), document.getElementById('content')

    app = fetch('page')
    app.url = "/#{long_id}#{if page == 'results' then '/results' else ''}"
    app.name = page
    save(app)


  results : (long_id) -> @proposal long_id, 'results'

window.app_router = new Router()

$(document).ready -> Backbone.history.start {pushState: true}
