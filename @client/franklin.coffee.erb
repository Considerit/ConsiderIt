#////////////////////////////////////////////////////////////
# Exploratory reimplementation of considerit client in React
#////////////////////////////////////////////////////////////

# Ugliness in this prototype: 
#   - UI state and persisted data stored in same place (when saving, what to send to server?)
#   - Figuring out if the route was changed. Or more generally, knowing what the diff in state was
#     in the lifecycle methods now that we're not using @props or @state. Right now using a hack
#     (see use of _route_changed ActiveREST cache key)


## ########################
## Initialize defaults for client data

fetch 'histogram',
  highlighted_users : null
  selected_segment : null
  selected_segment_isclicked : null

fetch 'slider',
  has_moved : false
  is_moving : false
  stance : null
  stance_segment : null

fetch 'decisionboard',
  sticky : false
  
fetch 'root',
  auth_mode : null
  opinions_to_publish : []

fetch '/current_user'

rxaosp = window.navigator.userAgent.match /Android.*AppleWebKit\/([\d.]+)/ 
browser = 
  is_android_browser : !!(rxaosp && rxaosp[1]<537)  # stock android browser (not chrome)
  is_opera_mini : !!navigator.userAgent.match /Opera Mini/
  is_ie9 : !!(document.documentMode && document.documentMode == 9)
  is_iOS : !!navigator.platform.match(/(iPad|iPhone)/)
  touch_enabled : Modernizr.touch
  high_density_display : ((window.matchMedia && (window.matchMedia('only screen and (min-resolution: 124dpi), only screen and (min-resolution: 1.3dppx), only screen and (min-resolution: 48.8dpcm)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3)').matches)) || (window.devicePixelRatio && window.devicePixelRatio > 1.3))

window.lefty = false

proposal_url = (proposal) =>
  # The special thing about this function is that it only links to
  # "?results=true" if the proposal has an opinion.
  result = '/' + proposal.slug
  if proposal.top_point
    result += '?results=true'
  return result

getStanceSegment = (value) ->
  for i in [0..5]
    if value < stance_segment_boundaries[i + 1]
      return i
  return 6

userOpinion = (user_key) ->
  window.user_opinions[user_key]

_route_changed = false

togglePage = (proposal_mode, triggered_by) ->
  $('.histogram_segment_pole').ensureInView
    offset_buffer: 150
    callback : -> 
      root = fetch('root')

      window.writeToLog
        what: 'toggle proposal mode'
        details: 
          from: root.proposal_mode
          to: proposal_mode
          triggered_by: triggered_by 

      root.proposal_mode = proposal_mode
      root.selected_point = null
      save root

      # Kludge for tracking when the page changes
      _route_changed = true
      _.delay -> 
        _route_changed = false
      , 1


stance_segment_boundaries = { 0 : -1, 1 : -.9999, 2 : -0.5, 3 : -0.05, 4 : 0.05, 5 : 0.5, 6 : .9999 } 

stance_names = 
  6 : 'Fully Support'
  0 : 'Fully Oppose'
  5 : 'Firmly Support'
  1 : 'Firmly Oppose'
  4 : 'Slightly Support'
  2 : 'Slightly Oppose'
  3 : 'are Undecided'

##
# PageTransition mixin
# Helper for components that implement a page transition animation.
# Applies styles defined in the component that change
# depending on the route. 
#
# The styles will be added on every update and on component mount. 
# However, it will *animate* the styles only if the page has changed (_route_changed). 
# Otherwise it just directly applies the styles
PageTransition = 

  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) ->
    @applyStyles _route_changed

  applyStyles : (animate) ->
    duration = if animate then TRANSITION_SPEED else 0
    root = @root
    $el = $(@getDOMNode())


    # Each Component that implements this mixin can get triggered multiple times after a route change. 
    # So we're going to ensure that we apply styles only once for a given route change. 
    return if @transitioning == root.proposal_mode
    @transitioning = root.proposal_mode

    switch @name

      # The histogram will get transparent when moving to crafting page
      when 'histogram'
        opacity = if root.proposal_mode == 'crafting' then '0.2' else '1.0'
        $el.find('.histogram_bar').velocity {opacity: opacity}, {duration}

      # The position of the CommunityPoints will move to the wings on crafting, and 
      # be close together in results
      when 'communitypoints'

        if root.proposal_mode == 'crafting'
          offset_x = if @props.key == 'cons' then 0 else DECISION_BOARD_WIDTH
        else if root.proposal_mode == 'results'
          offset_x = DECISION_BOARD_WIDTH / 2

        $el.velocity { translateX: offset_x }, {duration}

      # The slider handle and mouth will change size and location when moving between crafting and results
      when 'slider'
        slider = fetch 'slider'

        direction = if slider.stance_segment >  3 then 1 else -1
        mouth_x   = if slider.stance_segment == 3 then 0 else -22

        handle_width = 22

        if root.proposal_mode == 'crafting'
          bubblemouth_style = { translateX: direction * mouth_x, translateY: 20, scaleX: direction * 1.5, scaleY: 1.5  }
          handle_style = { scale: 2.5 }
        else 
          bubblemouth_style = { translateX: direction * mouth_x, translateY: -4, scaleX: direction, scaleY: 1  }
          handle_style = { scale: 1 }

        $el.find('.bubblemouth').velocity bubblemouth_style, {duration}
        $el.find('.the_handle').velocity handle_style, {duration}

      # The decision board will have to expand for crafting and collapse into to the Give Opinion button in results
      when 'decisionboard'
        if root.proposal_mode == 'crafting'
          decision_board_style =
            translateX: 0
            translateY: 10
            width: DECISION_BOARD_WIDTH
            minHeight: 275

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.give_opinion_button').css 'visibility', 'hidden'
          _.delay => 
            #delay & check in case of quick switch between pages
            if root.proposal_mode == 'crafting'
              $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', ''
          , duration

        else 
          slider = fetch 'slider'
          slider_position = slider.clientX

          give_opinion_button_width = 200

          gutter = .1 * give_opinion_button_width
          opinion_region_x = -gutter + (DECISION_BOARD_WIDTH - give_opinion_button_width + 2 * gutter) * slider_position/HISTOGRAM_WIDTH

          decision_board_style =
            translateX: opinion_region_x
            translateY: -18
            width: give_opinion_button_width
            minHeight: 32
            marginTop: 0

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', 'none'
          _.delay => 
            #check in case of quick switch between pages
            if root.proposal_mode == 'results'
              $el.find('.give_opinion_button').css 'visibility', ''
          , duration  
      else
        throw "The #{@name} component does not define any styles to animate"

    _.delay => 
      @transitioning = null
    , duration


#####################
# React Components (needs to be updated)
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  displayName: 'Proposal'

  render : ->
    your_opinion = fetch @proposal.your_opinion
    current_user = fetch('/current_user')
    subdomain = fetch '/subdomain'

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal


    # change to results page if user entered crafting page when it is not permitted
    if @root.proposal_mode == 'crafting' && !(can_opine in [Permission.PERMITTED, Permission.UNVERIFIED_EMAIL, Permission.NOT_LOGGED_IN] || (can_opine == Permission.DISABLED && your_opinion.published))
      @root.proposal_mode = 'results'
      save @root

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in @page.opinions
      window.user_opinions[opinion.user] = opinion

    proposer = fetch(@proposal.user)

    # Description fields are the expandable details that help people drill
    # into the proposal. They are very specific to the type of proposal (e.g. for
    # an LVG ballot measure, one of the fields might be "fiscal impact statement").  
    # We're now storing all these fields in proposal.description_fields
    # as a serialized JSON object of one of the following structures:
    #       [ {"label": "field one", "html": "<p>some details</p>"}, ... ] 
    #       [ {"group": "group name", "items": [ {"label": "field one", "html": "<p>some details</p>"}, ... ]}, ...]
    if !@local.description_fields
      # Deserialize the description fields. 
      # It would be nice if ActiveREST recognized that a field is a serialized data object!
      # This will fail for proposals that are not using the serialized JSON format; 
      # For now, we'll just catch the error and carry on 
      try 
        @local.description_fields = $.parseJSON(@data().description_fields)
        @local.expanded_field = null
      catch
        @local.description_fields = null

    DIV className:'proposal', key:@props.slug, 'data-page':@root.proposal_mode,

      (window["#{subdomain.name}-proposal-subheader"] or StickyProposalHeading)()

      DIV null,
        #description
        DIV 
          style: 
            width: DESCRIPTION_WIDTH
            position: 'relative'
            margin: 'auto'
            marginLeft: if lefty then 300
            #marginRight: if lefty then 0
            fontSize: 16
            marginBottom: '2em'

          if !@proposal.active
            SPAN style: {display: 'inline-block', color: 'rgb(250, 146, 45)', padding: '4px 0px', marginTop: 10},
              I className: 'fa fa-info-circle', style: {paddingRight: 7}
              'Closed to new contributions at this time.'

          # TODO: now that we're accepting user contributed proposals, we need to SANITIZE the description
          DIV
            className: 'proposal_details'
            style:
              paddingTop: '1em'
              fontSize: 18
            dangerouslySetInnerHTML:{__html: @proposal.description}

          if @local.description_fields
            DIV style: {marginTop: '1em'},
              for item in @local.description_fields
                if item.group
                  @renderDescriptionFieldGroup item
                else
                  @renderDescriptionField item

          if permit('update proposal', @proposal) > 0
            DIV null,
              A 
                style: {color: '#888'}
                onClick: => window.app_router.navigate("#{@proposal.key}/edit", {trigger: true})
                'Edit'
              A 
                style: {color: '#888', padding: 10, backgroundColor: if @local.edit_roles then '#fafafa' else 'transparent'}
                onClick: => 
                  @local.edit_roles = !@local.edit_roles
                  save @local
                'Share'

              if permit('delete proposal', @proposal) > 0
                A
                  style: {color: '#888'}
                  onClick: => 
                    if confirm('Delete this proposal forever?')
                      destroy(@proposal.key)
                      window.app_router.navigate("/", {trigger: true})
                  'Delete'

          if @local.edit_roles
            DIV 
              style: {width: BODY_WIDTH, margin: 'auto', backgroundColor: '#fafafa', padding: '10px 60px', \
                      marginLeft: (if lefty then 300)}#, marginRight: if lefty then 0}
              ProposalRoles key: @proposal
            
        #feelings
        DIV
          style:
            width: BODY_WIDTH
            margin: '0 auto'
            marginLeft: if lefty then 300
            position: 'relative'
          OpinionFilter()
          HistogramData(proposal_slug: @proposal.slug)
          Histogram()

        #reasons
        DIV 
          className:'reasons_region'
          style : 
            width: REASONS_REGION_WIDTH
            position: 'relative'
            margin: '48px auto 4em auto'
            marginLeft: if lefty then 65
            #marginRight: if lefty then 0
              
          #community cons
          CommunityPoints { key: 'cons' }

          DecisionBoard()

          #community pros
          CommunityPoints { key: 'pros' }


      if subdomain.name == 'livingvotersguide' && @root.proposal_mode == 'results' && your_opinion.published
        ThanksAndShareStrip()

  componentDidUpdate : ->
    $el = $(@getDOMNode())

    # Resizing the reasons region to solve a layout error when 
    # the height of the decision board (which is absolutely positioned) 
    # is taller than either of the wing point columns
    $el.find('.reasons_region').css {minHeight: $el.find('.opinion_region').height()} 


  renderDescriptionField : (field) ->
    DIV 
      className: 'description_field'
      key: field.label
      style: {padding: '.25em 0'}

      DIV 
        style: {cursor: 'pointer'}
        onClick: => 
          field.expanded = !field.expanded
          save(@local)
          if field.expanded 
            window.writeToLog
              what: 'expand proposal description'
              details: 
                description_type: field.label        
        SPAN 
          className: "fa #{if field.expanded then 'fa-minus-circle' else 'fa-plus-circle'}" 
          style: 
            opacity: .7
            position: 'relative'
            left: -4
            paddingRight: 6

        SPAN 
          style: {lineHeight: 1.6, fontSize: 18}
          field.label

      if field.expanded
        DIV 
          style: 
            padding: '10px 0'
            width: 700
            overflow: 'hidden'
          dangerouslySetInnerHTML:{__html: field.html}

  renderDescriptionFieldGroup : (group) -> 
    DIV 
      className: 'description_group'
      key: group.group,
      style: 
        position: 'relative'
        marginBottom: 10
        borderLeft: '1px solid #e1e1e1'
        paddingLeft: 20
        left: -20

      DIV 
        style: 
          position: 'absolute'
          width: 200
          left: -217
          textAlign: 'right'
          top: 4
          fontWeight: if browser.high_density_display then 300 else 400

        LABEL null, group.group
      for field in group.items
        @renderDescriptionField field

styles += """
.proposal_details br, .description_field br {
  padding-bottom: 0.5em; }
.proposal_details p, .proposal_details ul, .proposal_details table, .description_field p, .description_field ul, .description_field table {
  margin-bottom: 0.5em; }
.proposal_details td, .description_field td {
  padding: 0 3px; }
.proposal_details li, .description_field li {
  list-style: outside; }
.proposal_details ul, .description_field ul {
  padding-left: 20px;
  margin-left: 20px; }
.proposal_details a, .description_field a {
  text-decoration: underline; }
.proposal_details blockquote, .description_field blockquote {
  opacity: 0.7;
  padding: 10px 20px; }
.proposal_details table, .description_field table {
  padding: 20px 0px; }


"""


StickyProposalHeading = ReactiveComponent
  displayName: 'StickyProposalHeading'
  render : ->
    subdomain = fetch('/subdomain')
    proposals = fetch('/proposals')

    # If navigation bar is enabled, then we'll use a really short proposal name in the heading.
    # Otherwise we'll display the full question. This split doesn't come from
    # deep thought. Right now we'll just show the nav bar if the proposal belongs to a group
    use_navigation_bar = @proposal.cluster && proposals

    if not use_navigation_bar
      heading_style =
        textAlign: 'center'
        minWidth: PAGE_WIDTH # for width consistency when dropping into fixed sticky header
        backgroundColor: subdomain.branding.primary_color
        fontSize: 26
        padding: '4px 90px'

      return DIV null,
               DIV className: 'proposal_heading stickable',   style: heading_style,
                 SPAN null, @proposal.name
               DIV className: 'proposal_heading placeholder', style: heading_style,
                 SPAN null, @proposal.name
    
    # Now we know that we are drawing the navigation bar

    # Determine the next proposal
    next_proposal =
      if proposals.clusters  # In case /proposals isn't loaded
        curr_cluster = _.findWhere proposals.clusters, {name: @proposal.cluster}
        if curr_cluster?.proposals.length > 1
          # Now find the current proposal in the cluster, and return the next one
          for proposal, index in curr_cluster.proposals
            if @proposal == proposal
              break
          next_index = (index + 1) % curr_cluster.proposals.length
          curr_cluster.proposals[next_index]

    heading_height = 50
    DIV null, 
      DIV className: 'proposal_heading placeholder', style: {height: heading_height} 
      DIV
        id: 'proposal_heading'
        className: 'proposal_heading stickable'
        style:
          height: heading_height
          minWidth: PAGE_WIDTH # for width consistency when dropping into fixed sticky header
          backgroundColor: subdomain.branding.primary_color
          textAlign: 'center'

        A
          onClick: (=> window.app_router.navigate("/", {trigger: true}))
          style: {position: 'absolute', display: 'inline-block', top: 10, left: 12},
          I className: 'fa fa-home', style: {fontSize: 28, color: 'white'}

        DIV
          style: 
            display: 'inline-block'
            position: 'absolute'
            left: 58
            fontSize: 18
            paddingTop: 12

          @proposal.cluster

        DIV
          # Set the width so we can align it perfectly with the proposal description text:
          style: 
            width: DESCRIPTION_WIDTH
            textAlign: 'left'
            margin: 'auto'
            marginLeft: if lefty then 300
            #marginRight: if lefty then 0

          DIV style: {width: PAGE_WIDTH}, # ...but let the stuff inside be big
            DIV
              style:
                fontSize: 22
                fontWeight: 700
                position: 'relative'
                top: 4

              onMouseEnter: (=> @local.dropped_down = true; save(@local))
              onMouseLeave: (=> @local.dropped_down = false; save(@local))

              DIV 
                style: 
                  backgroundColor: 'rgba(0,0,0,.2)'
                  padding: '3px 15px'
                  borderRadius: 6
                  marginTop: 3
                  display: 'inline-block'
                  cursor: 'pointer'

                SPAN null,
                  "#{if @proposal.designator && @proposal.category then "#{@proposal.category[0]}-#{@proposal.designator} " else ''}#{@proposal.name}" 
                  I 
                    className: 'fa fa-caret-down'
                    style: 
                      paddingLeft: 8
                      fontSize: 30
                      position: 'relative'
                      top: 2

              if @local.dropped_down
                DIV 
                  style: 
                    width: 500
                    position: 'absolute'
                    top: 38
                    paddingTop: 5

                  DIV style: {backgroundColor: subdomain.branding.primary_color, borderRadius: '4px'},
                    DIV style: {backgroundColor: 'rgba(0,0,0,.2)', padding: '14px 0', borderRadius: '4px'},

                      if curr_cluster?.proposals.length > 1
                        DIV null,
                          TABLE className: 'current_cluster', style: {width: '100%'},
                            TBODY null,
                              for other_proposal in curr_cluster.proposals
                                TR href: proposal_url(other_proposal), onClick: clickInternalLink, key: "tr/#{other_proposal.slug}",
                                  TD style: {textAlign: 'left', paddingLeft: 20},
                                    A 
                                      href: proposal_url(other_proposal)
                                      onClick: clickInternalLink
                                      style: 
                                        color: 'white'
                                        fontWeight: if other_proposal.key == @proposal.key then 700 else 400
                                        fontSize: 18                                        
                                      other_proposal.name

                                  TD style: {position: 'relative'},
                                    if !other_proposal.your_opinion || !fetch(other_proposal.your_opinion).published
                                      SPAN style: {fontWeight: 400, color: 'rgb(205,205,205)', fontSize: 21}, '?'
                                    else
                                      # make a small slider summary
                                      opinion = fetch(other_proposal.your_opinion)
                                      face_size = 20 # height/width of the summary slider bar
                                      eye_style = { width: 2, height: 2, borderRadius: '50%', backgroundColor: subdomain.branding.primary_color, position: 'absolute', top: 6 }
                                      mouth_style = {fontSize: 12, color: subdomain.branding.primary_color, left: face_size * .45, top: face_size * .28, position: 'absolute', transform: 'rotate(90deg)'}
                                      css.crossbrowserify mouth_style
                                      if opinion.stance_segment < 3
                                        # frown!
                                        mouth = '('
                                      else if opinion.stance_segment == 3
                                        # confused!
                                        mouth = '|'
                                      else
                                        # pleased!
                                        mouth = ')'

                                      DIV 
                                        style: 
                                          borderBottom: "1px solid white"
                                          width: 100
                                          position: 'relative'
                                          top: 15

                                        DIV
                                          style: 
                                            borderRadius: '50%'
                                            backgroundColor: 'white'
                                            width: face_size
                                            height: face_size
                                            position: 'absolute'
                                            top: -face_size / 2
                                            marginLeft: -face_size / 2 
                                            left: "#{100 * (opinion.stance + 1.0) / 2.0}%"
                                          DIV style: _.extend {}, eye_style, {left: 6} # left eye
                                          DIV style: _.extend {}, eye_style, {left: face_size - 8} # right eye
                                          DIV style: mouth_style, mouth


                                  TD style: {paddingRight: 20}

                          DIV className: 'separator', style: {borderBottom: '1px dotted #dedede', width: '85%', margin: '28px auto 12px auto'}

                      DIV className: 'other_clusters',
                        for cluster in proposals.clusters
                          if @proposal.cluster != cluster.name && cluster.proposals.length > 0
                            do (cluster) =>
                              DIV 
                                className: 'another_cluster'
                                onMouseEnter: => @local.show_cluster = cluster.name; save(@local)
                                onMouseLeave: => @mouseLeaveOtherCluster(cluster.name)
                                style: {padding: '0 50px', width: '100%', position: 'relative'}

                                SPAN style: {float: 'left', fontSize: 18, fontWeight: 400},
                                  cluster.name
                                I className: 'fa fa-caret-right', style: {float: 'right'}
                                DIV style: {clear: 'both'}

                                if @local.show_cluster == cluster.name
                                  DIV style: {width: 300, zIndex: 99999, backgroundColor: subdomain.branding.primary_color, borderRadius: '4px', position: 'absolute', left: 458, top: -12},                                  
                                    UL className: 'other_proposal_list', style: {backgroundColor: 'rgba(0,0,0,.2)', borderRadius: '4px', padding: '8px 0' },
                                      for other_proposal in cluster.proposals
                                        LI style: {listStyle: 'none'}, key: "li/#{other_proposal.slug}",
                                          A 
                                            href: proposal_url(other_proposal)
                                            onClick: clickInternalLink
                                            style:
                                              display: 'block'
                                              textAlign: 'left'
                                              padding: '2px 10px'
                                              color: 'white'
                                              fontSize: 18
                                              fontWeight: 400
                                            other_proposal.name


              if next_proposal
                DIV 
                  style: 
                    fontSize: 15
                    marginLeft: 50
                    display: 'inline-block'
                    fontWeight: 400

                  "Next: "
                    A
                      style: 
                        color: 'white'
                        textDecoration: 'underline'
                      onClick: do (url = proposal_url(next_proposal)) =>
                        => window.app_router.navigate(url, {trigger: true})
                      next_proposal.name


  componentDidMount : -> @initOrUpdateHeader()
  componentDidUpdate : -> @initOrUpdateHeader()

  initOrUpdateHeader : -> 
    $el = $(@getDOMNode())

    $header = $el.find('.proposal_heading.stickable')

    if $header.length > 0 && !@is_waiting()
      $header.StickyElement
        placeholder: $el.find('.proposal_heading.placeholder')[0]
        container: $el.parents('.proposal')
        stick_on_zoomed_screens: false

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.find('.proposal_heading.stickable').StickyElement('destroy')
  mouseLeaveOtherCluster : (cluster) -> 
    if @local.show_cluster == cluster
      @local.show_cluster = null
      save(@local)

styles += """
.current_cluster tr:hover, .other_proposal_list li:hover {
  background-color: rgba(0, 0, 0, 0.1);
  cursor: pointer; }

.proposal_heading {
  width: 100%;
  color: white;
  z-index: 999;
  position: relative; }


"""


window.ProposalSubheading = ReactiveComponent
  displayName: 'ProposalSubheading'
  render : ->
    subdomain = fetch('/subdomain')
    proposals = fetch('/proposals')
    heading_fontsize = 45

    # Determine the next proposal
    next_proposal =
      if proposals.clusters  # In case /proposals isn't loaded
        curr_cluster = _.findWhere proposals.clusters, {name: @proposal.cluster}
        if curr_cluster?.proposals.length > 1
          # Now find the current proposal in the cluster, and return the next one
          for proposal, index in curr_cluster.proposals
            if @proposal == proposal
              break
          next_index = (index + 1) % curr_cluster.proposals.length
          curr_cluster.proposals[next_index]

    DIV
      style:
        margin: '30px 0 0 0'

      # Placeholder
      # DIV
      #   className: 'proposal_heading_placeholder'
      #   style:
      #     color: 'transparent'
      #     position: 'relative'
      #     paddingBottom: 15
      #     paddingLeft: 300
      #     width: 560 + 300
      #   DIV null,
      #     @proposal.cluster
      #   DIV
      #     style: {fontSize: heading_fontsize, fontWeight: 700, lineHeight: 1.2}
      #     @proposal.name

      # Actual sticky thing
      DIV
        className: 'stickable'
        style:
          width: 560 + 300
          backgroundColor: 'white'
          zIndex: 3
          position: 'relative'
          paddingBottom: 15
          paddingLeft: 300

        # Next button
        A
          style:
            position: 'absolute'
            right: 0
          onClick: do (url = proposal_url(next_proposal)) =>
            => window.app_router.navigate(url, {trigger: true})
          'Next >'

        # Cluster name
        DIV
          style:
            fontStyle: 'italic'
          @proposal.cluster

        # Proposal name
        DIV
          style:
            lineHeight: 1.2
            fontWeight: 700
            fontSize: heading_fontsize
          @proposal.name

  # componentDidMount : -> @initOrUpdateHeader()
  # componentDidUpdate : -> @initOrUpdateHeader()
  #
  # initOrUpdateHeader : -> 
  #   $el = $(@getDOMNode())
  #
  #   $header = $el.find('.stickable')
  #
  #   if $header.length > 0 && !@is_waiting()
  #     $header.StickyElement
  #       placeholder: $el.find('.proposal_heading_placeholder')[0]
  #       container: $el.parents('.proposal')
  #       stick_on_zoomed_screens: false
  #
  # componentWillUnmount : -> 
  #   $el = $(@getDOMNode())
  #   $el.find('.stickable').StickyElement('destroy')


##
# HistogramData
# Doesn't render anything. Stores computed Histogram data. 
HistogramData = ReactiveComponent
  displayName: 'HistogramData'

  ##
  # Split up opinions into columns based on their stance.   
  render : ->
    proposal_slug = @props.proposal_slug
    histogram_data = fetch('histogramdata/' + proposal_slug)

    # We only need to recompute this data if the distribution of stances has changed. 
    opinions = fetch('/page/' + proposal_slug).opinions || []
    last_computation_hash = JSON.stringify( _.map(opinions, (o) => fetch(o.key).stance) )

    if not histogram_data.last_computation_hash \
       or (histogram_data.last_computation_hash != last_computation_hash)

      max_avatar_size = @props.max_avatar_size or BIGGEST_POSSIBLE_AVATAR_SIZE
      histogram_width = @props.width or HISTOGRAM_WIDTH
      max_height = @props.height or MAX_HISTOGRAM_HEIGHT

      ##
      # Size the avatars. Size of avatar shrinks proportional to 1/sqrt(num_opinions)
      avatar_size = Math.min max_avatar_size,
        Math.floor(max_avatar_size / Math.sqrt( (opinions.length + 1) / 10 )  )

      # Calculate the number of columns in the histogram. But we want to ensure that there
      # are an _odd_ number of cols so that a neutral opinion falls into the exact 
      # center of the histogram. To ensure this, we'll manipulate avatar_size. 
      loop 
        columns_in_histogram = Math.floor(histogram_width / avatar_size)
        break if columns_in_histogram % 2 == 1
        avatar_size -= 1

      columns = ([] for col in [0..columns_in_histogram-1])

      # Assign each Opinion to a column
      for opinion in opinions
        opinion = fetch(opinion.key)
         
        round_method = if opinion.stance_segment < 3 then Math.floor else Math.ceil

        column = round_method (opinion.stance + 1) / 2.0 * (columns_in_histogram - 1)
        columns[column].push opinion

      # Spill out extremes into multiple columns. We'll cap the number of opinions
      # in a column to max_opinions_in_column. We'll keep the number of extreme columns
      # equal between supporters and opposers. 
      max_opinions_in_column = Math.floor max_height / avatar_size
      most_extreme_opinions = Math.max columns[0].length, columns[columns.length-1].length
      if most_extreme_opinions > max_opinions_in_column
        num_extreme_cols = Math.ceil most_extreme_opinions / max_opinions_in_column

        # split each extreme into num_extreme_cols. First supporters then opposers.
        for extreme, idx in [columns[0], columns[columns.length - 1]]
          for i in [0..num_extreme_cols - 2]
            if extreme.length > max_opinions_in_column
              opinions_for_new_col = extreme.splice(max_opinions_in_column, max_opinions_in_column)
            else
              opinions_for_new_col = []

            if idx == 0 
              columns.unshift opinions_for_new_col #add to beginning for supporters
            else 
              columns.push opinions_for_new_col #add to end for opposers

      #columns.reverse() #we're going from 1 <=> -1 for supporters <=> opposers

      histogram_data.columns = columns
      histogram_data.avatar_size = avatar_size
      histogram_data.last_computation_hash = last_computation_hash

      save histogram_data

    SPAN null #dummy DOM for React render 
  

##
# Histogram
Histogram = ReactiveComponent
  displayName : 'Histogram'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  onClickHistogram : (ev) ->
    if @root.proposal_mode == 'crafting'
      togglePage('results', 'click_histogram')

  onSelectSegment : (ev) ->
    if @root.proposal_mode == 'results'
      segment = $(ev.currentTarget).data('segment')
      hist = fetch('histogram')

      selected_segment = hist.selected_segment

      # If clicking on already hard-selected segment, then we'll deselect. 
      if selected_segment == segment and selected_segment_isclicked
        segment = null

      click_select = ev.type == 'click' 

      #ignore mouseEnter and mouseLeave events if selection was via click
      return if selected_segment and selected_segment_isclicked and !click_select 

      hist.selected_segment = segment
      hist.selected_segment_isclicked = click_select and segment
      save(hist)
      ev.stopPropagation()

  render : ->
    selected_segment = fetch('histogram').selected_segment
    users_to_highlight = fetch('histogram').highlighted_users


    histogram_data = fetch('histogramdata/' + @proposal.slug)
    columns = histogram_data.columns
    num_columns = columns.length
    avatar_size = histogram_data.avatar_size

    effective_histogram_width = num_columns * avatar_size + 2
    margin_adjustment = -(effective_histogram_width - HISTOGRAM_WIDTH) / 2 #- avatar_size / 4

    DIV null,
      TABLE 
        className: 'histogram'
        onClick: @onClickHistogram
        # onMouseLeave: @onSelectSegment
        style: 
          width: effective_histogram_width
          marginLeft: margin_adjustment
          position: 'relative'
        TBODY null,
          TR null, 
            TD 
              key: 'opposers'
              className: "histogram_segment_pole"
              style: 
                left: -160
                width: 145 
              SPAN null, if @root.proposal_mode == 'crafting' then 'Oppose' else 'Opposers'

            for bar, idx in columns
              segment = if bar.length > 0 then bar[0].stance_segment else -1
              is_selected = selected_segment == segment

              TD 
                key: idx 
                className: "histogram_bar #{if is_selected then 'is_selected' else 'not_selected'}"
                style: 
                  width: avatar_size
                  opacity: if is_selected && !selected_segment? then '1' else '1'
                  minHeight: if bar.length == 0 then 75 else 0
                for opinion in bar
                  user = opinion.user
                  Avatar 
                    key: user
                    user: user
                    hide_face: @root.proposal_mode == 'crafting'
                    hide_name: @root.proposal_mode == 'crafting'
                    'data-segment':segment
                    style:
                      height: avatar_size
                      width: avatar_size
                      opacity: if users_to_highlight && 
                        !_.contains(users_to_highlight, opinion.user) 
                        then '.15' 
                        else if selected_segment == null || is_selected 
                        then '1.0'
                        else '.15'

            TD 
              key: 'supporters'
              className: "histogram_segment_pole"
              style: 
                right: -145
                width: 130
              SPAN null, if @root.proposal_mode == 'crafting' then 'Support' else 'Supporters'


styles += """
.histogram_segment_pole {
  position: absolute;
  font-size: 30px;
  bottom: -20px;
  pointer-events: none; }
  .histogram_segment_pole span {
    position: absolute;
    bottom: 0; }

.histogram_bar {
  display: inline-block;
  font-size: 0;
  vertical-align: bottom; 
  #{css.crossbrowserify({transform: 'rotate(180deg)'}, true)}
  -ms-transform: rotate(0);
  }

  .histogram_bar .avatar {
    border-radius: 50%;
    background-color: #{default_avatar_in_histogram_color}; 
    #{css.crossbrowserify({transform: 'rotate(180deg)'}, true)}
    -ms-transform: rotate(0);}

"""

##
# Slider
# Manages the slider and the UI elements attached to it. 
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  # Kick off sliding 
  handleMouseDown: (e) -> 
    el = @getDOMNode()
    # Dragging has to start by dragging the slider handle
    return if !$(e.target).is('.the_handle')

    e.preventDefault()

    # Initiate dragging
    slider = fetch('slider')
    slider.is_moving = true
    slider.offsetX = e.clientX or e.touches[0].clientX

    slider.startX = parseInt($(e.target)[0].style.left, 10) || 0
    save slider

    $(window).on "mousemove.slider", @handleMouseMove
    $(window).on "mouseup.slider", @handleMouseUp

  # Stop sliding
  handleMouseUp: (e) ->
    # Don't do anything if we're not actually dragging. We only hit this logic
    # if there is some delay in removing the event handlers.
    slider = fetch 'slider'

    return if !slider.is_moving

    e.preventDefault()

    your_opinion = fetch(@proposal.your_opinion)
    
    # Clicking on the slider handle should transition us between crafting <=> results. 
    # We should also transition to crafting when we've been dragging on the results page. 
    if slider.stance == your_opinion.stance || @root.proposal_mode == 'results'
      new_page = if @root.proposal_mode == 'results' then 'crafting' else 'results'
      togglePage new_page, 'click_slider'
      e.stopPropagation()

    # We save the slider's position to the server only on mouse-up.
    # This way you can drag it with good performance.
    if your_opinion.stance       != slider.stance
      your_opinion.stance         = slider.stance
      your_opinion.stance_segment = slider.stance_segment
      save your_opinion
      window.writeToLog 
        what: 'move slider'
        details: {stance: slider.stance}

    # Turn off dragging
    slider.is_moving = false
    save slider

    $(window).off ".slider" # Remove event handlers

  # While sliding
  handleMouseMove: (e) ->
    e.preventDefault() # prevents text selection of surrounding elements

    slider = fetch('slider')

    clientX = e.clientX or e.touches[0].clientX

    # Update position
    slider.clientX = slider.startX + clientX - slider.offsetX
    slider.clientX = 0 if slider.clientX < 0
    slider.clientX = @props.width if slider.clientX > @props.width
    slider.has_moved = true

    # convert position of handle to a slider value on [1, -1]
    slider.stance = slider.clientX / @props.width * 2 - 1
    slider.stance_segment = getStanceSegment slider.stance

    save slider


  render : ->
    slider = fetch('slider')

    # Update the slider position when the server gets back to us
    your_opinion = fetch(@proposal.your_opinion)

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    if slider.stance != your_opinion.stance and !slider.is_moving
      slider.stance = your_opinion.stance
      slider.stance_segment = your_opinion.stance_segment
      slider.clientX = @props.width * (slider.stance / 2 + .5)
      if your_opinion.stance
        slider.has_moved = true
      save(slider)

    page = @root.proposal_mode
    sticky = fetch('decisionboard').sticky
    stance = slider.stance
    segment = slider.stance_segment

    # Can't be dynamically set b/c of integration with asset fingerprinting. 
    # This is also why this file is ERB.
    bubblemouth_srcs = 
      neutral : {crafting: "<%= asset_path 'bubblemouth_neutral-crafting.png' %>", results: "<%= asset_path 'bubblemouth_neutral-results.png' %>"}
      other : {crafting: "<%= asset_path 'bubblemouth-crafting.png' %>", results: "<%= asset_path 'bubblemouth-results.png' %>"}
    
    bubblemouth_src = if segment == 3 then bubblemouth_srcs['neutral'][page] else bubblemouth_srcs['other'][page]

    eye_style = 
      backgroundColor: 'white'
      top: 6
      width: 3
      height: 3
      transform: "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_mouth_style = 
      bottom: -1
      width: SLIDER_HANDLE_SIZE - 4
      left: 2
      height: SLIDER_HANDLE_SIZE - 4
      boxShadow: '3px 3px 0 0 white'
      transform: 
        "scale(#{.4 + .3 * Math.abs(stance) }, #{.08 + .4 * stance}) 
         translate(0, #{-2 - 5 * Math.abs(stance)}px) 
         rotate(45deg) 
         skew(#{if segment in [0,6] then '10deg' else '0deg'})"

    css.crossbrowserify sty for sty in [eye_style, face_mouth_style]
    _.extend(face_part, {position: 'absolute', pointerEvents: 'none', borderRadius: '50%' }) for face_part in [eye_style, face_mouth_style]

    # Keep feedback centered over handle, but keep within the bounds of the slider region 
    # when the slider is in an extreme position. 
    feedback_left = @props.width * (stance/2 + .5)
    if sticky 
      feedback_width = if slider.has_moved then 190 else 400
      if feedback_left > @props.width / 2
        feedback_left = Math.min(@props.width - feedback_width/2 + 35, feedback_left)
      else if feedback_left < @props.width / 2
        feedback_left = Math.max(feedback_width/2 - 35, feedback_left)
    else
      feedback_width = 450

    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point =  selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)

    slider_base_style = 
      width: @props.width
      height: 6
      backgroundColor: if page == 'crafting' then '#AFD7FF' else '#787878'

    handle_style =
      boxShadow: "0px 1px 0px black, inset 0 1px 2px rgba(255,255,255, .4), 0px 0px 0px 1px #{considerit_blue}"            
      backgroundColor: considerit_blue      
      left: slider.clientX
      zIndex: 10
      borderRadius: '50%'
      width: if can_opine != Permission.INSUFFICIENT_PRIVILEGES then SLIDER_HANDLE_SIZE else 0
      height: if can_opine != Permission.INSUFFICIENT_PRIVILEGES then SLIDER_HANDLE_SIZE else 0
      marginLeft: -SLIDER_HANDLE_SIZE / 2
      top: -9
      position: 'relative'

    bubblemouth_style = {left: slider.clientX}

    if selected_point
      handle_style.backgroundColor = "#ccc"
      handle_style.boxShadow = "0px 1px 0px #aaa"
      slider_base_style.backgroundColor = "#ddd"
      bubblemouth_style.visibility = 'hidden' # TODO: use grayscale filter when !selected_wing_point instead of hidding

    DIV 
      className: 'slider'
      style : 
        left: - (@props.width - DECISION_BOARD_WIDTH) / 2
        position: 'absolute'
        top: -48
        margin: 'auto'
      DIV className:'slider_base', style : slider_base_style, 
        DIV 
          style: 
            position: 'absolute'
            top: -80
            pointerEvents: 'none' # clicking on this interferes with slider and toggle state
            visibility: 'visible'
            left: feedback_left
            marginLeft: -feedback_width / 2
            width: feedback_width
            fontSize: if sticky then '18px' else '29px'
            top: if sticky then '-65px' else '-80px'
            display: if page == 'results' then 'none' else 'block'
            borderRadius: 10 
            fontWeight: 700
            color: considerit_blue
            textAlign: 'center'

          if !slider.has_moved then 'Slide Your Overall Opinion' else "You #{stance_names[segment]}"


        if can_opine in [Permission.PERMITTED, Permission.UNVERIFIED_EMAIL, Permission.NOT_LOGGED_IN] || (can_opine == Permission.DISABLED && your_opinion.published)

          [DIV 
            className: 'the_handle'
            onMouseUp: @handleMouseUp
            onMouseDown: @handleMouseDown
            onTouchStart: @handleMouseDown
            onTouchMove: @handleMouseMove
            onTouchEnd: @handleMouseUp
            onTouchCancel: @handleMouseUp
            style: handle_style

            if page == 'crafting'
              DIV className: 'face',            
                DIV 
                  className: 'face_mouth'
                  style: face_mouth_style
                DIV 
                  className: 'face_eye'
                  style: _.extend {}, eye_style,
                    left: 6
                DIV 
                  className: 'face_eye'
                  style: _.extend {}, eye_style,
                    right: 6

            if page == 'crafting' && !slider.has_moved
              [DIV 
                className: 'drag_arrow'
                style: 
                  right: -15
                  position: 'absolute'
                  top: 3
                  color: considerit_blue
                  fontSize: 12              
                '>' 
              DIV 
                className: 'drag_arrow'
                style: 
                  left: -15
                  position: 'absolute'
                  top: 3
                  color: considerit_blue
                  fontSize: 12                
                '<']

          IMG className:'bubblemouth', src: bubblemouth_src, style: bubblemouth_style
          ]

styles += """
#{css.grab_cursor('.the_handle')}

.bubblemouth {
  position: absolute;
  width: 18px;
  pointer-events: none;
  z-index: 10;
  margin-left: -#{SLIDER_HANDLE_SIZE/2}px; }

"""


##
# OpinionFilter
# Filters whose opinions are displayed
OpinionFilter = ReactiveComponent
  displayName: 'OpinionFilter'

  onSelectSegment : (segment) ->
    hist = fetch('histogram')
    if !segment? || hist.selected_segment == segment
      # Deselect
      hist.selected_segment = null
      hist.selected_segment_isclicked = null
    else
      # Select
      hist.selected_segment = segment
      hist.selected_segment_isclicked = true

      window.writeToLog
        what: 'filter results by segment'
        details: 
          segment: segment


    save hist


  render : ->
    hist = fetch('histogram')

    # Remove filter when on crafting page
    if @root.proposal_mode == 'crafting'
      hist.selected_segment = null
      hist.selected_segment_isclicked = null

    filter_options = ['show all opinions',
        'only full opposers',
        'only firm opposers',
        'only slight opposers',
        'only undecideds',
        'only slight supporters',
        'only firm supporters',
        'only full supporters']

    DIV 
      style: 
        display: if @root.proposal_mode == 'crafting' then 'none' else 'block'
        position: 'absolute'
        zIndex: 10
        right: -275
        bottom: -200
        fontSize: 13

      for phrase, i in filter_options
        # Shift i by 1, and start with null
        i = if i == 0 then null else i - 1
          
        A 
          key: "segment-#{i}"
          className: "filter_option #{if hist.selected_segment == i then 'selected' else ''}"
          onClick: do(i) => => @onSelectSegment(i) 
          style: 
            color: if hist.selected_segment == i then 'black' else '#666'
            position: 'relative'
            display: 'block'

          SPAN 
            style: 
              position: 'absolute'
              content: '•'
              left: -10
              top: 1
              visibility: if hist.selected_segment == i then '' else 'hidden'
            '•'
          phrase


##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')
    
    your_opinion = fetch(@proposal.your_opinion)

    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point = selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)
    
    decision_board_style =
      borderRadius: 16
      borderStyle: 'dashed'
      borderWidth: 3
      borderColor: considerit_blue


    if @local.user_hovering_on_drop_target
      decision_board_style.borderStyle = 'solid'

    if @root.proposal_mode == 'results'
      _.extend decision_board_style,
        borderStyle: 'solid'
        backgroundColor: considerit_blue
        boxShadow: '0px 2px 0px black'
        cursor: 'pointer'

    if selected_wing_point
      decision_board_style.filter = 'grayscale(1)'
      decision_board_style['-webkit-filter'] = 'grayscale(1)'
      decision_board_style.opacity = '.4'
    else if selected_point
      decision_board_style.borderColor = "#ccc"


    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal


    DIV 
      className:'opinion_region'
      style: 
        position: 'absolute'
        width: DECISION_BOARD_WIDTH
        zIndex: 0 #so that points being dragged are above opinion region
        display: 'inline-block'
        verticalAlign: 'top'

      Slider
        width: HISTOGRAM_WIDTH


      if can_opine != Permission.INSUFFICIENT_PRIVILEGES && (can_opine != Permission.DISABLED || your_opinion.published )
        # only shown during results, but needs to be present for animation
        if @root.proposal_mode == 'results'
          give_opinion_style = 
            display: 'block'
            color: 'white'
            padding: '.25em 18px'
            margin: 0
            fontSize: 16
            boxShadow: 'none'
        else
          give_opinion_style = {}

        [DIV 
          className:'decision_board_body'
          style: decision_board_style
          onClick: => if @root.proposal_mode == 'results' then togglePage('crafting', 'give_opinion_button')

          DIV null, 
            # only shown during crafting, but needs to be present always for animation
            DIV 
              className: 'your_points'
              style: 
                padding: '0 18px'
                marginTop: -3 # To undo the 3 pixel border
              YourPoints { key: 'your_con_points', valence: 'cons' }
              YourPoints { key: 'your_pro_points', valence: 'pros' }


            A 
              className: 'give_opinion_button primary_button'
              style: give_opinion_style

              if your_opinion.published 
                'Update your Opinion' 
              else 
                'Give your Opinion'

        DIV className: 'decision_board_footer', 

          # Big bold button at the bottom of the crafting page
          DIV 
            className:'save_opinion_button primary_button'
            onClick: => 
              your_opinion = fetch(@proposal.your_opinion)
              if can_opine > 0
                your_opinion.published = true
                save your_opinion
                togglePage('results', 'save_button')
              else
                if can_opine == Permission.UNVERIFIED_EMAIL
                  @root.auth_mode = 'verify'
                  current_user.trying_to = 'send_verification_token'
                  save current_user
                else
                  @root.auth_mode = 'register'
                  @root.auth_reason = 'Save your Opinion'

                # We'll need to publish this opinion after auth is completed
                @root.opinions_to_publish.push(@proposal.your_opinion)

                save @root

            if your_opinion.published 
              'See the results' 
            else 
              'Save your opinion and see results'

          if @root.proposal_mode == 'crafting'
            A 
              style: 
                marginTop: '.5em'
                padding: 3
                display: 'inline-block'

              INPUT
                type:      'checkbox'
                id:        "follow_proposal"
                name:      "follow_proposal"
                checked:   @proposal.is_following
                style: 
                  fontSize: 21
                  cursor: 'pointer'
                onChange: =>
                  @proposal.is_following = !@proposal.is_following
                  save @proposal
              LABEL 
                htmlFor: "follow_proposal"
                title:'We\'ll send periodic email notifications summarizing activity on the proposal, as well as alerts about new pro and con points. You can easily unsubscribe later.'
                style: 
                  marginLeft: 6
                  fontSize: 16
                  color: '#888'
                  cursor: 'pointer'   
                'Notify me about new activity'

          if !your_opinion.published
            A 
              className:'cancel_opinion_button primary_cancel_button'
              onClick: => togglePage('results', 'cancel_button')
              'or just skip to the results'  
        ]


  componentDidMount : ->
    @setStickyHeader()

    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = fetch(@proposal.your_opinion)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)

            window.writeToLog
              what: 'included point'
              details: 
                point: ui.draggable.parent().data('id')

          @local.user_hovering_on_drop_target = false
          save @local

      out : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = false
          save @local

      over : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = true
          save @local

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.StickyElement('destroy')

  componentDidUpdate : -> 
    $el = $(@getDOMNode())    
    root = fetch('root')

    # hack to get around a problem where the browser's remembered scroll position messes
    # up the sticky location after initialization
    if !@initial_position_fixed
      $el.StickyElement('fix_initial_position')
      @initial_position_fixed = true
    else if root.proposal_mode == 'results' #fix problem where it would stay sticky moving to results page
      $el.StickyElement('update')

  setStickyHeader : ->
    $el = $(@getDOMNode())

    slider_region_height =  115

    $el.StickyElement
      container: $('.reasons_region')
      top_offset: $('.proposal_heading').outerHeight() + slider_region_height
      bottom_offset: 20
      unsticks: =>
        d = @data()
        d.sticky = false
        save(d)
      sticks: =>
        d = @data()
        d.sticky = true
        save(d)
      conditional: => 
        @root.proposal_mode == 'crafting'


##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  render : ->
    included_points = fetch(@proposal.your_opinion).point_inclusions    
    left_or_right = if @props.valence == 'pros' then 'right' else 'left'

    can_add_new_point = permit 'create point', @proposal

    your_points = @data @props.key,
      editing_points : []
      adding_new_point : false

    DIV 
      className:"points_on_decision_board #{@props.valence}_on_decision_board"
      style: 
        width: POINT_WIDTH
        marginTop: 28

      DIV 
        className:'points_heading_label'
        style: 
          fontWeight: 700
          color: considerit_blue
        "Give Your #{capitalize(@props.valence)}"

      UL null,
        for point in included_points

          if fetch(point).is_pro == (@props.valence == 'pros')
            if point in your_points.editing_points
              EditPoint { key: point, fresh: false, valence: @props.valence, your_points_key: @props.key }
            else
              Point { key: point, rendered_as: 'decision_board_point', your_points_key: @props.key }

        #drop target
        DIV 
          style: 
            padding: '0 0 .25em 9px'
            position: 'relative'

          IMG 
            src: "<%= asset_path 'drop_target.png' %>"
            style: css.crossbrowserify
              transform: if @props.valence == 'cons' then '' else 'scaleX(-1)'
              width: 223

          SPAN 
            style:
              fontSize: 14
              position: 'absolute'
              top: '1.4em'
              left: if @props.valence == 'cons' then 36 else 29
              width: 180

            "Drag a #{capitalize(if @props.valence=='pros' then 'pro' else 'con')} from the #{left_or_right}"

        if can_add_new_point != Permission.INSUFFICIENT_PRIVILEGES
          if !your_points.adding_new_point
            DIV 
              style: 
                padding: '.25em 0'
                marginTop: '1em'
                marginLeft: 20
                fontSize: 14

              SPAN 
                style: {fontWeight: if browser.high_density_display then 300 else 400}
                'or '
              SPAN 
                style: {padding: '0 6px'}
                dangerouslySetInnerHTML:{__html: '&bull;'}
              A 
                style:
                  textDecoration: 'underline'
                  color: considerit_blue
                onClick: => 
                  if can_add_new_point == Permission.NOT_LOGGED_IN
                    @root.auth_mode = 'register'
                    @root.auth_reason = 'write a point'
                    save @root
                  else if can_add_new_point == Permission.UNVERIFIED_EMAIL
                    @root.auth_mode = 'verify'
                    @root.auth_reason = 'write a point'
                    save @root
                    current_user.trying_to = 'send_verification_token'
                    save current_user

                  else
                    your_points.adding_new_point = true
                    save your_points

                  writeToLog {what: 'click new point'}

                "Write a new #{capitalize(if @props.valence == 'pros' then 'pro' else 'con')}"

          else
            EditPoint { key: "new_point_#{@props.valence}", fresh: true, valence: @props.valence, your_points_key: @props.key }

styles += """
.points_by_community, .points_on_decision_board {
  display: inline-block;
  vertical-align: top; }

.points_heading_label {
  text-align: center;
  margin-bottom: 30px;
  margin-top: 7px;
  font-size: 30px; }

"""


##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting
  render : ->
    selected_segment = fetch('histogram').selected_segment

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key
    con_is_selected = @root.selected_point and not fetch(@root.selected_point).is_pro

    # TODO: The minheight below is not a principled or complete solution to two sizing issues: 
    #           1) resizing the reasons region when the height of the decision board 
    #              (which is absolutely positioned) grows taller the wing points
    #           2) when filtering the points on result page to a segment without many inclusions,
    #              the document height can jarringly fluctuate
    DIV
      className: "points_by_community #{@props.key}_by_community"
      style:
        width: POINT_CONTENT_WIDTH
        minHeight: (if @page.points.length > 4 then jQuery(window).height() else 400)
        zIndex: if con_is_selected and @props.key == 'cons' then 6 else 2
        margin: '38px 18px 0 18px'
        position: 'relative'

      DIV 
        className:'points_heading_label'
        style: 
          position: 'relative'
          fontWeight: if browser.high_density_display then 300 else 400
          left: if @props.key == 'cons' then -20 else 20
            # Mike: I wanted the headers to be centered over the ENTIRE
            # points including avatars, not just bubbles.  But the
            # avatars are sticking out on their own, so I simulated
            # a centered look with these -20px and +20px offsets

        if fetch('root').proposal_mode == 'results' then "Top #{label}" else "Others' #{label}"
        P 
          style: 
            visibility: if selected_segment == null then 'hidden' else 'visible'
            textAlign: 'center'
            fontSize: 12
            position: 'absolute'
            width: '100%'
            bottom: -12
            color: '#db004d'
            fontWeight: if browser.high_density_display then 300 else 400

          if selected_segment == null then '-' else "for those who #{stance_names[selected_segment]}"          

      UL null,
        if points.length > 0
          for point in points
            Point
              key: point.key,
              is_new: Date.parse(point.created_at) > newpoint_threshold
              rendered_as : 'community_point'
        else
          LI 
            style: 
              marginTop: 50
              fontStyle: 'italic'
              listStyle: 'none'
              textAlign: 'center'
              fontWeight: if browser.high_density_display then '300' else '400'

            "No #{label} listed"

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @page.points || []
    newpoint_threshold = 
      (_.sortBy points, (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = fetch('root').proposal_mode == 'results'
    selected_segment = fetch('histogram').selected_segment
    included_points = fetch(@proposal.your_opinion).point_inclusions
    points = @page.points
    opinions = @page.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_segment?
      # If there is a histogram segment selected, we'll have to filter down 
      # to the points that users in this segment think are important, and 
      # order them by resonance to those users. I'm doing this quite inefficiently.
      point_inclusions_per_point_for_segment = {} # map of points to including users
      _.each opinions, (opinion) =>
        if opinion.stance_segment == selected_segment && opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point_for_segment)
              point_inclusions_per_point_for_segment[point] = 1
            else
              point_inclusions_per_point_for_segment[point] += 1

      points = 
        _.filter points, (pnt) -> pnt.key of point_inclusions_per_point_for_segment
      points = 
        _.sortBy points, (pnt) -> -point_inclusions_per_point_for_segment[pnt.key]
    else
      # Default sort order
      points = 
        _.sortBy points, (pnt) => - if is_results then pnt.score else pnt.last_inclusion

    points

styles += """

"""


##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  render : ->
    point = @data()

    is_selected = @root.selected_point == @props.key

    selected_segment = fetch('histogram').selected_segment
    current_user = fetch('/current_user')


    renderIncluders = =>

      if @data().includers

        includers = @buildIncluders()

        s = #includers_style
          rows: 8
          dx: 2
          dy: 5
          col_gap: 8
          side_offset: 32 + 14 + 1

        # Now we'll go through the list from back to front
        i = includers.length

        for includer in includers
          i -= 1
          curr_column = Math.floor(i / s.rows)
          side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
          top_offset = (i % s.rows) * s.dy 
          left_right = if @data().is_pro then 'right' else 'left'
          style = { top: top_offset }
          style[left_right] = -side_offset

          # Finally draw the guys
          Avatar
            key: includer
            className: "point_includer_avatar"
            style: style

    renderNewIndicator = =>
      if @data().includers
        side_offset = 48
        left_right = if @data().is_pro then 'right' else 'left'
        style = 
          position: 'absolute'
          color: 'rgb(255,22,3)'
          fontSize: '11px'
          top: -14
          #backgroundColor: 'white'
          zIndex: 5
          fontVariant: 'small-caps'
          fontWeight: 'bold'

        style[left_right] = "#{-side_offset}"
        SPAN {style: style}, '-new-'


    point_content_style = { width: POINT_CONTENT_WIDTH }
    if is_selected
      _.extend point_content_style,
        border: "3px solid #{considerit_blue}"
        left: -3
        top: -3
        width: point_content_style.width + 6
        backgroundColor: 'white'
        marginBottom: 2

      if @props.rendered_as == 'decision_board_point'
        _.extend point_content_style,
          padding: 8
          borderRadius: 8
          marginTop: -8
          marginLeft: -8
          width: point_content_style.width + 16

    if @props.rendered_as == 'under_review'
      _.extend point_content_style, {width: 500}


    needs_expansion_to_see_details = point.text && (point.nutshell.length + point.text.length) > 210

    select_enticement = []

    if needs_expansion_to_see_details
      select_enticement.push SPAN key: 1,
        SPAN dangerouslySetInnerHTML: {__html: '&hellip;'}
        ' ('
        A className: 'select_point',
          'read more'
        ')'

    if point.comment_count > 0 || !needs_expansion_to_see_details
      select_enticement.push SPAN key: 2, style: {whiteSpace: 'nowrap'},
        " ("
        A className: 'select_point',
          "#{point.comment_count} comment#{if point.comment_count != 1 then 's' else ''}"
        ")"

    if point.assessment
      select_enticement.push SPAN key: 3,
        I
          className: 'fa fa-search'
          title: 'Click to read a fact-check of this point'
          style: 
            color: '#5E6B9E'
            fontSize: 14
            cursor: 'help'
            paddingLeft: 4


    point_style = 
      position: 'relative'
      listStyle: 'none outside none'

    if @props.rendered_as == 'decision_board_point'
      _.extend point_style, 
        marginLeft: 9
        padding: '0 18px 1em 18px'

    LI
      className: "point #{@props.rendered_as} #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
      onClick: @selectPoint
      onTouchEnd: @selectPoint
      style: point_style

      if @props.rendered_as == 'community_point' && @props.is_new
        renderNewIndicator()

      DIV className:'includers', onMouseEnter: @highlightIncluders, onMouseLeave: @unHighlightIncluders, 
        if @props.rendered_as == 'community_point'
          renderIncluders()

        else if !selected_segment || (userOpinion(point.user) && author_opinion = fetch(userOpinion(point.user)) && author_opinion.stance_segment == selected_segment )
          Avatar 
            key: point.user
            className:"point_author_avatar"
            hide_face: point.hide_name
            hide_name: @props.rendered_as == 'under_review'

      DIV className:'point_content', style : point_content_style,
        if @props.rendered_as == 'community_point' || @props.rendered_as == 'under_review' || is_selected
          IMG
            className: 'community_point_mouth'
            src: if is_selected then "<%= asset_path 'community_point_mouth_selected.png' %>" else "<%= asset_path 'community_point_mouth.png' %>"

        DIV className:'point_nutshell',
          splitParagraphs point.nutshell

          DIV className: "point_details#{if is_selected || @props.rendered_as == 'under_review' then '' else '_tease'}",
            if point.text && point.text.length > 0
              if is_selected || !needs_expansion_to_see_details || @props.rendered_as == 'under_review'
                splitParagraphs(point.text)
              else 
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text()

            if !is_selected && select_enticement && @props.rendered_as != 'under_review'
              select_enticement

        DIV null,
          if permit('update point', point) > 0 && @props.rendered_as == 'decision_board_point'
            A
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8

              onClick: ((e) =>
                e.stopPropagation()
                points = fetch(@props.your_points_key)
                points.editing_points.push(@props.key)
                save(points))
              SPAN null, 'edit'

          if permit('delete point', point) > 0 && @props.rendered_as == 'decision_board_point'
            A 
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8
              onClick: (e) =>
                e.stopPropagation()
                if confirm('Delete this point forever?')
                  destroy @props.key
              SPAN null, 'delete'

      if is_selected
        point_included = _.contains(fetch(@proposal.your_opinion).point_inclusions, point.key)
        Discussion
          key:"/comments/#{point.id}"
          is_pro: point.is_pro
          in_wings: @root.proposal_mode == 'crafting' and not point_included

  componentDidMount : ->
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  componentDidUpdate : -> 
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  # Hack that fixes a couple problems:
  #   - Scroll to the point when following a link from an email notification to a point
  #   - Scroll to new point when scrolled down to bottom of long discussion & click 
  #     a new point below it
  ensureDiscussionIsInViewPort : ->
    if @root.selected_point == @props.key
      $(@getDOMNode()).ensureInView {scroll: false}

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page

    return if @props.rendered_as == 'under_review'

    disable = fetch('root').proposal_mode == 'results'

    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.rendered_as == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = fetch(@proposal.your_opinion)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, @props.key
          save(your_opinion)
          window.writeToLog
            what: 'removed point'
            details: 
              point: @props.key

        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable


  selectPoint: (e) ->
    # android browser needs to respond to this via a touch event;
    # all other browsers via click event. iOS fails to select 
    # a point if both touch and click are handled...sigh...
    return unless browser.is_android_browser || e.type == 'click'

    return if @props.rendered_as == 'under_review'

    e.stopPropagation()

    if @root.selected_point == @props.key # deselect
      @root.selected_point = null
      what = 'deselected a point'
    else
      what = 'selected a point'
      @root.selected_point = @props.key

    save @root

    window.writeToLog
      what: what
      details: 
        point: @props.key


  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  highlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      point = @data()
      includers = point.includers

      # For point authors who chose not to sign their points, remove them from 
      # the users to highlight. This is particularly important if the author 
      # is the only one who "included" the point. Then it is very eash for 
      # anyone to discover who wrote this point. 
      if point.hide_name
        includers = _.without includers, point.user
      hist = fetch 'histogram'
      if hist.highlighted_users != includers
        hist.highlighted_users = includers
        save(hist)

  unHighlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      hist = fetch 'histogram'
      hist.highlighted_users = null
      save(hist)


  buildIncluders : -> 
    point = @data()
    author_has_included = _.contains point.includers, point.user
    to_remove = [point.user]

    # only show includers from this stance segment if a segment is selected
    selected_segment = fetch('histogram').selected_segment
    if selected_segment?
      for includer in point.includers
        if userOpinion(includer)
          stance_segment = fetch(userOpinion(includer)).stance_segment

          if stance_segment && stance_segment != selected_segment
            to_remove.push includer
        else 
          to_remove.push includer

    includers = _.difference point.includers, to_remove
    if author_has_included 
      includers.push point.user
    includers
        

styles += """
.community_point_mouth {
  position: absolute;
  width: #{COMMUNITY_POINT_MOUTH_WIDTH}px;
  top: 8px;
  z-index: 1; }

.community_point.con .community_point_mouth, .under_review .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

.community_point.pro .community_point_mouth {
  right: -#{COMMUNITY_POINT_MOUTH_WIDTH}px;
  #{css.crossbrowserify({transform: 'scaleX(-1)'}, true)}; }

.decision_board_point .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

/* war! disabled jquery UI draggable class defined with !important */
.point_content.ui-draggable-disabled {
  cursor: pointer !important; }

#{css.grab_cursor('.point_content.ui-draggable')}

.community_point .point_content, .under_review .point_content {
  border-radius: 16px;
  padding: 0.5em 9px;
  margin-bottom: 0.5em;
  background-color: #f6f7f9;
  box-shadow: #b5b5b5 0 1px 1px 0px;
  min-height: 34px; }

.point_nutshell {
  word-wrap: break-word;
  font-size: 14px; }

.point_details_tease, .point_details {
  margin-top: 0.5em;
  font-size: 14px;
  word-wrap: break-word; 
  font-weight: #{if browser.high_density_display then 300 else 400}; }
  .point_details_tease a, .point_details a {
    text-decoration: underline;
    word-break: break-all; }

.point_details {
  display: block; }

.point_details_tease {
  cursor: pointer; }
  .point_details_tease a.select_point {
    text-decoration: none; }
    .point_details_tease a.select_point:hover {
      text-decoration: underline; }

.point_details p {
  margin-bottom: 1em; }

.point_details p:last-child {
  margin-bottom: 0; }

.point_author_avatar, .point_includer_avatar {
  position: absolute; }

.decision_board_point .point_author_avatar {
  top: 8px;
  width: 22px;
  height: 22px; }

.under_review .point_author_avatar {
  top: 0px;
  width: 50px;
  height: 50px;
  left: -73px;
  box-shadow: -1px 2px 0 0 #eeeeee; }

.point_includer_avatar {
  width: 22px;
  height: 22px; }

.community_point .point_author_avatar {
  top: 0;
  width: 22px;
  height: 22px; }

.community_point.con .point_author_avatar {
  left: -1;
  box-shadow: -1px 2px 0 0 #eeeeee; }
.community_point.con .point_includer_avatar {
  box-shadow: -1px 2px 0 0 #eeeeee; }

.community_point.pro .point_author_avatar {
  right: -1;
  box-shadow: 1px 2px 0 0 #eeeeee; }
.community_point.pro .point_includer_avatar {
  box-shadow: 1px 2px 0 0 #eeeeee; }

.decision_board_point .point_author_avatar {
  left: -10px;
  top: -2px; }

"""

Comment = ReactiveComponent
  displayName: 'Comment'

  render: -> 
    comment = @data()

    if comment.editing
      # Sharing keys, with some non-persisted client data getting saved...
      EditComment fresh: false, point: comment.point, key: comment.key

    else

      DIV className: 'comment_entry',

        # Comment author name
        DIV className: 'comment_entry_name',
          fetch(comment.user).name + ':'

        # Comment author icon
        Avatar
          className: 'comment_entry_avatar'
          key: comment.user
          hide_name: true

        # Comment body
        DIV className: 'comment_entry_body',
          splitParagraphs(comment.body)

        # Delete/edit button
        if permit('update comment', comment) > 0
          comment_action_style = 
            color: '#444'
            textDecoration: 'underline'
            cursor: 'pointer',
            paddingRight: 10
          DIV style: { marginLeft: 60}, 
            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                if confirm('Delete this comment forever?')
                  destroy(key)
              'delete'

            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                comment.editing = true
                save comment
              'edit'          

# fact-checks, edit comments, comments...
styles += """
.comment_entry {
  margin-bottom: 45px;
  min-height: 60px;
  position: relative; }

.comment_entry_name {
  font-weight: bold;
  color: #666666; }

.comment_entry_avatar {
  position: absolute;
  width: 50px;
  height: 50px; }

.comment_entry_body {
  margin-left: 60px;
  word-wrap: break-word;
  position: relative; }
  .comment_entry_body a {
    text-decoration: underline; }
  .comment_entry_body strong {
    font-weight: 600; }
  .comment_entry_body p {
    margin-bottom: 1em; }
"""

FactCheck = ReactiveComponent
  displayName: 'FactCheck'

  render : -> 
    assessment = @data()
    DIV className: 'comment_entry',

      # Comment author name
      DIV className: 'comment_entry_name',
        'Seattle Public Library Fact check:'

      # Comment author icon
      DIV className: 'magnifying_glass',
        I className: 'fa fa-search'

      # Comment body
      DIV className: 'comment_entry_body',
        DIV style: {margin: '10px 0 20px 0'},
          "A citizen requested research into the claims made by this point. "
          SPAN style: {fontSize: 12},
            A style: {fontWeight: 700}, href: '/about#fact_check', onClick: clickInternalLink,
              'Learn more'
            ' about the service.'

        for claim in assessment.claims
          claim = fetch(claim.key)
          verdict = fetch(claim.verdict)

          [DIV style: {margin: '10px 0'}, 
            IMG style: {position: 'absolute', width: 25, left: -40}, src: verdict.icon
            'Claim: '
            SPAN style: {fontWeight: 600}, claim.claim_restatement
          DIV null, 
            SPAN null,
              'Rating: '
              SPAN style: {fontStyle: 'italic'}, verdict.name
              SPAN style: {marginLeft: 20, fontSize: 12, textDecoration: 'underline', cursor: 'help'}, title: verdict.desc,  'help'
          DIV style: {margin: '10px 0'}, dangerouslySetInnerHTML:{__html: claim.result}]

styles += """
.magnifying_glass {
  position: absolute;
  width: 50px;
  height: 50px;
  font-size: 50px;
  margin-top: -2px;
  color: #5e6b9e; }
"""

EditComment = ReactiveComponent
  displayName: 'EditComment'

  render : -> 
    permitted = permit 'create comment', @proposal

    DIV className: 'comment_entry',

      # Comment author name
      DIV
        style:
          fontWeight: 'bold'
          color: '#666'
        (fetch('/current_user').name or 'You') + ':'

      # Icon
      Avatar
        style:
          position: 'absolute'
          width: 50
          height: 50
          backgroundColor: if permitted < 0 then 'transparent'
          border:          if permitted < 0 then '1px dashed grey'

        key: fetch('/current_user').user
        hide_name: true

      if permitted == Permission.DISABLED
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Comments closed'

      else if permitted == Permission.INSUFFICIENT_PRIVILEGES
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Sorry, you do not have permission to comment'

      else if permitted < 0
        SPAN
          style:
            position: 'absolute'
            margin: '14px 0 0 70px'
            cursor: 'pointer'

          onClick: =>
            if permitted == Permission.NOT_LOGGED_IN
              @root.auth_mode = 'login' 
            else if permitted == Permission.UNVERIFIED_EMAIL
              @root.auth_mode = 'verify'
              current_user.trying_to = 'send_verification_token'
              save current_user

            @root.auth_reason = 'Write a Comment'
            save(@root)

          if permitted == Permission.NOT_LOGGED_IN
            DIV null,
              SPAN 
                style: { textDecoration: 'underline', color: considerit_blue }
                'Log in to write a comment'
              if '*' not in @proposal.roles.commenter
                DIV style: {fontSize: 11},
                  'Only some email addresses are authorized to comment.'

          else if permitted == Permission.UNVERIFIED_EMAIL
            DIV null,
              SPAN
                style: { textDecoration: 'underline', color: considerit_blue }
               'Verify your account'
              SPAN null, 'to write a comment'

      AutoGrowTextArea
        className: 'new_comment'
        placeholder: if permitted > 0 then 'Write a new comment' else ''
        disabled: permitted < 0
        onChange: (e) => @local.new_comment = e.target.value; save(@local)
        defaultValue: if @props.fresh then null else @data().body
        min_height: 60
        style:
          marginLeft: 60
          width: 390
          lineHeight: 1.4
          fontSize: 16
          border: if permitted < 0 then 'dashed 1px'

      if permitted > 0
        DIV style: {textAlign: 'right'},
          Button({style: {marginLeft: 314}}, 'Save comment', (e) =>
            e.stopPropagation()
            if @props.fresh
              comment =
                key: '/new/comment'
                body: @local.new_comment
                user: fetch('/current_user').user
                point: "/point/#{@props.point}"
            else
              comment = @data()
              comment.body = @local.new_comment
              comment.editing = false

            save(comment)
            $(@getDOMNode()).find('.new_comment').val(''))


Discussion = ReactiveComponent
  displayName: 'Discussion'

  render : -> 
    
    discussion_style =
      width: DECISION_BOARD_WIDTH
      border: "3px solid #{considerit_blue}"
      position: 'absolute'
      zIndex: 100
      padding: '20px 40px'
      borderRadius: 16
      backgroundColor: 'white'

    bubble_mouth_style =
      position: 'absolute'
      top: 14
      width: 27
      height: 63

    # Reconfigure discussion board position
    side = if @props.is_pro then 'right' else 'left'
    if @props.in_wings
      discussion_style[side] = 215
      discussion_style['top'] = 44
    else
      discussion_style[side] = if @props.is_pro then -23 else -30
      discussion_style['marginTop'] = 13

    # Reconfigure bubble mouth position
    if @props.in_wings
      bubble_mouth_style.right = if @props.is_pro then -27       else undefined
      bubble_mouth_style.left  = if @props.is_pro then undefined else -27
    else
      trans_func = 'rotate(270deg)'
      if @props.is_pro
        trans_func += ' scaleY(-1)'

      _.extend bubble_mouth_style,
        left: if @props.is_pro then 335 else 100
        top: -45
        transform:            trans_func
        '-ms-transform':      trans_func
        '-moz-transform':     trans_func
        '-webkit-transform':  trans_func
        '-o-transform':       trans_func
      

    comments = @discussion.comments
    if @discussion.assessment
      comments = comments.slice()
      comments.push @discussion.assessment
      comments.sort (a,b) -> a.created_at < b.created_at

    DIV style: discussion_style, onClick: ((e) -> e.stopPropagation()),
      IMG
        src: "<%= asset_path 'bubblemouth-discussions.png' %>"
        className: if @props.is_pro then '' else 'flipped'
        style: bubble_mouth_style

      H1
        style:
          textAlign: 'left'
          fontSize: 38
          color: considerit_blue
          marginLeft: 60
          marginBottom: 25
          marginTop: 24
          fontWeight: 600
        'Discuss this Point'
      
      SubmitFactCheck()

      DIV className: 'comments',
        for comment in comments
          if comment.key.match /(comment)/
            Comment key: comment.key
          else 
            FactCheck key: comment.key

      # Write a new comment
      EditComment fresh: true, point: arest.key_id(@props.key)

  # HACK! Insert a placeholder to add enough height to accommodate the 
  # overlaid point. And if it is a point on the decision board,
  # also add the space to the decision board (so that scrolling
  # to bottom of discussion can occur)
  componentDidUpdate : -> @fixBodyHeight()
  componentDidMount : -> @fixBodyHeight()
  componentWillUnmount : -> @clear_placeholder()
  clear_placeholder : -> 
    $body = $('.reasons_region')
    $body.find('.discussion_placeholder').remove()

  fixBodyHeight : -> 
    @clear_placeholder()

    $body = $('.reasons_region')
    height_of_discussion = $(@getDOMNode()).height()
    placeholder = "<div class='discussion_placeholder' style='height: #{height_of_discussion}px'></div>"
    $body.append(placeholder)
    if $(@getDOMNode()).parents('.opinion_region').length > 0
      $('.decision_board_body').append placeholder

Button = (props, text, callback) ->
  style =
    backgroundColor: considerit_blue
    borderRadius: 8
    color: 'white'
    padding: '3px 10px'
    display: 'inline-block'
    fontWeight: 600
    textAlign: 'center'
    cursor: 'pointer'
  props.style = _.extend(style, (props.style or {}))
  props.onClick = callback

  DIV props, text


SubmitFactCheck = ReactiveComponent
  displayName: 'SubmitFactCheck'

  # States
  # - Blank
  # - Clicked request
  # - Contains request from you already
  # - Contains a verdict

  render: ->
    return SPAN(null) if !@proposal.assessment_enabled

    logged_in = fetch('/current_user').logged_in

    request_a_fact_check = =>
      [
        DIV null,
          'You can'
        DIV
          style:
            fontSize: 22
            fontWeight: 600
            textDecoration: 'underline'
            color: '#474747'
            marginTop: -4
            marginBottom: -1
            cursor: 'pointer'
          onClick: (=>
            if @local.state == 'blank slate'
              @local.state = 'clicked'
            else if @local.state == 'clicked'
              @local.state = 'blank slate'
            save(@local))
          'Request a Fact Check'
        DIV null,
          'from The Seattle Public Library'
      ]

    a_librarian_will_respond = (width) =>
      DIV style: {maxWidth: width},
        'A '
        A
          style: {textDecoration: 'underline'}
          href: '/about/#fact_check'
          'librarian will respond'
        ' to your request within 48 hours'

    request_a_factcheck = =>
      if permit('request factcheck', @proposal) > 0
        [
          DIV style: {marginTop: 12},
            'What factual claim do you want researched?'
          AutoGrowTextArea
            className: 'new_request'
            style:
              width: 390
              height: 60
              lineHeight: 1.4
              fontSize: 16
            placeholder: (logged_in and 'Your research question') or ''
            disabled: not logged_in
            onChange: (e) =>
              @local.research_question = e.target.value
              save(@local)
          Button
            style: {float: 'right'}
            onClick => (e) =>
              e.stopPropagation()
              request =
                key: '/new/request'
                suggestion: @local.research_question
                point: "/point/#{arest.key_id(@discussion.key)}"
              save(request)
              $(@getDOMNode()).find('.new_request').val('')
            'submit'

          a_librarian_will_respond(255)
        ]
      else
        DIV
          onClick: =>
            @root.auth_mode = 'login'
            @root.auth_reason = 'Request a Fact Check'
            save(@root)
          style:
            marginTop: 14
            textDecoration: 'underline'
            color: considerit_blue
            cursor: 'pointer'
          'Log in to request a fact check'


    top_message_style = {maxWidth: 274, marginBottom: 10}
    request_in_progress = =>
      DIV null,
        DIV style: top_message_style,
          'You have requested a Fact Check from The Seattle Public Library'
        a_librarian_will_respond()
          
    request_completed = =>
      overall_verdict = fetch(@discussion.assessment.verdict)

      [
        DIV style: top_message_style,
          'This point has been Fact-Checked by The Seattle Public Library'
        DIV style: {marginBottom: 10},
          switch overall_verdict.id
            when 1
              "They found some claims inconsistent with reliable sources."
            when 2
              "They found some sources that agreed with claims and some that didn't."
            when 3
              "They found the claims to be consistent with reliable sources."
            when 4
              "Unfortunately, the claims made are outside the research scope of the fact-checking service."

        DIV style: {marginBottom: 10},
          A style: {textDecoration: 'underline'},
            ''
          "See the details"
          " of the librarians' research below."
      ]


    # Determine our current state
    @local.state = @local.state or 'blank slate'
    your_requests = (r for r in @discussion.requests or [] \
                     when r.user == fetch('/current_user').user)
    fact_check_completed = @discussion.claims?.length > 0
    if fact_check_completed
      @local.state = 'verdict'
    else if your_requests.length > 0
      @local.state = 'requested'


    show_request = @local.state != 'blank slate'
    
    request_style = if show_request then { marginBottom: 45, minHeight: 60 } else {}

    # Now let's draw
    DIV style: request_style,

      # Magnifying glass
      if show_request

        DIV className: 'magnifying_glass',
          I
            className: 'fa fa-search'

      # Text to the right
      DIV
        style:
          marginLeft: 60
        switch @local.state
          when 'blank slate'
            request_a_fact_check()
          when 'clicked'
            [request_a_fact_check()
            request_a_factcheck()]
          when 'requested'
            request_in_progress()
          when 'verdict'
            request_completed()

##
# EditPoint
# Form for editing or creating a point. Used by NewPoint component & when someone
# edits their point. 
EditPoint = ReactiveComponent
  displayName: 'EditPoint'

  render : ->
    @local = @data @local_key,
      sign_name : if @props.fresh then true else !@data().hide_name
      add_details : false

    textarea_style = 
      width: '100%'
      minHeight: 100
      overflow: 'hidden'
      fontSize: 14

    DIV
      className: 'edit_point'
      style: 
        margin: '0 18px'
        position: 'relative'
        fontSize: 14

      INPUT id:'is_pro', name: 'is_pro', type: 'hidden', value: "#{@props.valence == 'pros'}"
      LABEL 
        htmlFor:'nutshell'
        'Your point'
      CharacterCountTextInput 
        id:'nutshell'
        maxLength:140
        name:'nutshell'
        pattern:'^.{3,}'
        placeholder:'Make this summary succinct.'
        required:'required'
        defaultValue: if @props.fresh then null else @data().nutshell
        style: textarea_style

      
      DIV null,
        A 
          className: 'add_details'
          onClick: =>
            @local.add_details = !@local.add_details
            save(@local)            
          title: 'Provide background and/or back your point up with evidence.'
          style: { fontSize: 14 }

          I className: if @local.add_details then 'fa-caret-down fa' else 'fa-caret-right fa'
          SPAN
            style: {paddingLeft: 6}
            'Expand on your point'

        if @local.add_details
          DIV null, 
            AutoGrowTextArea 
              id:'text'
              name:'text'
              placeholder:'Provide background and/or back your point up with evidence.'
              required:'required'
              min_height: 170
              defaultValue: if @props.fresh then null else @data().text
              style: textarea_style


      if @proposal.active
        DIV 
          style: 
            position: 'absolute'
            bottom: 0
            fontSize: 13
          INPUT
            className: 'newpoint-anonymous'
            type:      'checkbox'
            id:        "sign_name-#{@props.valence}"
            name:      "sign_name-#{@props.valence}"
            checked:   @local.sign_name
            onChange: =>
              @local.sign_name = !@local.sign_name
              save(@local)
          LABEL 
            htmlFor: "sign_name-#{@props.valence}"
            title:'Signing your name lends your point more weight with other participants.', 'Sign your name'
        
      DIV 
        style: 
          textAlign: 'right'
          marginTop: 3
          marginBottom: '.5em'

        if !@proposal.active
          DIV 
            style: {color: '#777', fontSize: 12}
            'New points disabled for this proposal'
        else
          INPUT 
            className:'button primary_button'
            action:'submit-point',
            type:'submit', 
            onClick: @savePoint
            value:'Done'
            style: 
              marginTop: '.5em'
              width: '100%'
              fontSize: 18

        A 
          className:'newpoint-cancel primary_cancel_button'
          onClick: @done
          'cancel'  

  componentDidMount : ->
    $el = $(@getDOMNode())
    $el.find('#nutshell').focus()
    $el.find('.newpoint-cancel').ensureInView {scroll: false, position: 'bottom'}

  done : ->
    your_points = fetch @props.your_points_key
    if @props.fresh
      your_points.adding_new_point = false
    else
      your_points.editing_points = _.without your_points.editing_points, @props.key
    save your_points

  savePoint : (ev) ->
    $form = $(@getDOMNode())
    root = fetch('root')

    nutshell = $form.find('#nutshell').val()
    text = $form.find('#text').val()
    hide_name = !$form.find("#sign_name-#{@props.valence}").is(':checked')

    if !@props.fresh
      # If we're updating an existing point, we just have to update
      # some of the fields from the form
      point = @data()
      point.nutshell = nutshell
      point.text = text
      point.hide_name = hide_name
    else
      current_user = fetch('/current_user').user
      point =
        key : '/new/point'
        is_pro : @props.valence == 'pros'
        user : current_user
        comment_count : 0
        includers : [current_user]
        proposal : @proposal.key
        nutshell : nutshell
        text : text
        hide_name : hide_name

    save point

    @done()

    # This is a kludge cause activerest sucks for pre-rendering
    # changes before the server returns them
    fetch(@proposal.your_opinion).point_inclusions.push(point.key)
    re_render([@proposal.your_opinion])

styles += """
.edit_point .count{
  position: absolute;
  right: 20px;
  top: -19px;
}
"""

##
# Avatar
# Displays a user's avatar
# Supports straight up img src, or using the CSS-embedded b64 for each user
Avatar = ReactiveComponent
  displayName: 'Avatar'
  
  render : ->
    user = @data()

    # setting @local fails in strict mode, which is a problem for phantomjs rendering for google search results
    try 
      @local = fetch @local_key,
        show_details : false
    catch e
      noop = 1

    id = if @props.hide_face then "avatar-hidden" else "avatar-#{user.key.split('/')[2]}"

    attrs =
      className: "avatar #{if @props.className then @props.className else ''}"
      id: id
      onMouseEnter: (ev) => 
        @local.show_details = true
        save(@local)
      onMouseLeave: (ev) => 
        $('.hover_avatar_name').remove()
        @local.show_details = false
        save(@local)

    if @props.img_style && user.key != -1 && user.avatar_file_name
      attrs.src = "/system/avatars/#{@props.key}/#{@props.img_style}/#{avatar_file_name}"

    @transferPropsTo SPAN attrs

  getDefaultProps : ->
    key: '/user/-1' # defaults to anonymous user
    img_style: null #null defaults to the css-based b64 embedded images
    hide_face: false

  componentWillUpdate : -> 
    if @local.show_details && !@props.hide_name
      @insertUserName()

  insertUserName : ->
    $el = $(@getDOMNode())
    pos = $el.offset()
    display_name = if @props.hide_face then 'Anonymous' else @data().name
    $name = $("<span class='hover_avatar_name'>#{display_name}</span>")
    $('body').append $name   # ugly!

    # if we're at the top of the page, stick the name below
    direction = if $el.offset().top < 50 then 1 else -1
    $name.css 
      left: pos.left - $name.width() / 2 + $el.width()/2
      top: pos.top + direction * $name.height()

window.styles += """
.avatar {
  vertical-align: top;
  background-color: transparent;
  border: none;
  display: inline-block;
  margin: 0;
  padding: 0;
  border-radius: 50%;
  background-size: cover;
  background-color: #{default_avatar_in_histogram_color}; }
  .avatar.avatar_anonymous {
    cursor: default; }

.hover_avatar_name {
  position: absolute;
  font-size: 14px;
  background-color: white;
  padding: 0 4px;
  border-radius: 16px;
  z-index: 999999;
  white-space: nowrap;
  pointer-events: none; }
"""



AutoGrowTextArea = ReactiveComponent
  displayName: 'AutoGrowTextArea'  

  # You can pass an onChange() handler in to props that will get
  # called
  onChange: (e) ->
    @props.onChange?(e)
    @checkAndSetHeight()

  componentDidMount : -> @checkAndSetHeight()
  componentDidUpdate : -> @checkAndSetHeight()

  checkAndSetHeight : ->
    scroll_height = @getDOMNode().scrollHeight
    if scroll_height > @getDOMNode().clientHeight
      @local.height = scroll_height + 5
      save(@local)

  render : -> 
    if !@local.height
      @local.height = @props.min_height

    @transferPropsTo TEXTAREA
      onChange: @onChange
      style: {height: @local.height}


CharacterCountTextInput = ReactiveComponent
  displayName: 'CharacterCountTextInput'
  componentWillMount : -> fetch(@local_key).count = 0
  render : -> 
    class_name = "is_counted"
    DIV style: {position: 'relative'}, 
      @transferPropsTo TEXTAREA className: class_name, onChange: (=>
         @local.count = $(@getDOMNode()).find('textarea').val().length
         save(@local))
      SPAN className: 'count', @props.maxLength - @local.count


Auth = ReactiveComponent
  displayName: 'Auth'

  render: -> 
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')
    root = fetch('root')

    # When we switch to new auth_mode screens, wipe out all the old
    # errors, cause we're startin' fresh!
    if not @local.last_auth_mode or @local.last_auth_mode != root.auth_mode
      @local.last_auth_mode = root.auth_mode
      current_user.errors = []


    # Let's set up some useful helpers
    submitOnEnter = (event) =>
      if event.which == 13
        event.preventDefault()
        @submitAuth(event)

    input_box = (name, placeholder, type, onChange, pattern) =>
      if @local[name] != current_user[name]
        @local[name] = current_user[name]
        save @local

      # There is a react bug where input cursor will jump to end for 
      # controlled components. http://searler.github.io/react.js/2014/04/11/React-controlled-text.html
      # This makes it annoying to edit text. I've contained this issue to edit_profile only
      # by only setting value in the Input component when in edit_profile mode
      type = type || 'text'
      onChange = onChange || (event) => 
        @local[name] = current_user[name] = event.target.value
        save @local

      INPUT
        id: 'user_' + name
        value: if @root.auth_mode == 'update' then @local[name] else null
        name: "user[#{name}]"
        key: "#{name}_input_box"
        placeholder: placeholder
        required: "required"
        type: type
        onChange: onChange
        onKeyPress: submitOnEnter
        pattern: pattern

    name_input_field     = input_box('name', 'first and last name')
    email_input_field    = input_box('email', 'email@address', 'email')

    password_input_field =
      input_box('password',
                 if root.auth_mode == 'login' then "password" else if root.auth_mode == 'register' then 'choose a password' else "choose a new password",
                 'password',
                 null,
                 if root.auth_mode == 'register' then ".{5,}" else '')

    providers = ['facebook', 'google']

    third_party_authenticated = current_user.facebook_uid || current_user.twitter_uid || current_user.google_uid

    #####
    # We used to display the Auth header using the position and
    # styling of the slider.  Now it's just neutral.

    # Asset fingerprinting. This is why this file is ERB
    bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"

    bubble_mouth_props = 
      transform: "translate(0px, 11px) scale(1.5, 1.5)"
      left: 270
      position: 'relative'
    css.crossbrowserify bubble_mouth_props

    if !subdomain.has_civility_pledge
      pledges = []
    else
      pledges = ['I will participate with only one account', 
                 'I will speak only on behalf of myself', 
                 'I will not attack or mock others']

    auth_area_style = 
      padding: '1.5em 18px .5em 18px'
      fontSize: 21
      marginTop: 10

    if @root.auth_mode != 'update'
      _.extend auth_area_style, 
        borderRadius: 16
        borderStyle: 'dashed'
        borderWidth: 3
        borderColor: considerit_blue

    DIV null,
      if @root.auth_mode == 'update'
        DashHeader name: 'Edit Profile'

      DIV
        style: 
          margin: '0 auto 10em 0'
          position: 'relative'
          display: 'block'
          zIndex: 0
          margin: 'auto'
          marginLeft: if lefty then 300
          position: 'relative'
          width: DECISION_BOARD_WIDTH

        onClick: (e) => e.stopPropagation()

        if @root.auth_mode != 'update'
          DIV 
            className: 'auth_header'
            style : 
              width: HISTOGRAM_WIDTH
              position: 'relative'
              margin: 'auto' 
              top: 5
            DIV 
              className:'auth_heading'
              style: 
                borderRadius: 10                
                fontWeight: 700
                color: considerit_blue
                textAlign: 'center'
                visibility: 'visible'
                left: HISTOGRAM_WIDTH / 2.0
                top: 5
                marginLeft: -225
                width: 450
                fontSize: 50
                position: 'relative'

              'Introduce Yourself' 
              if @root.auth_reason
                DIV style: {fontSize: 18, margin: '-8px 0 15px 0'},
                  "To #{@root.auth_reason}"

            DIV 
              className: 'the_handle'
              style: 
                left: 255
                height: SLIDER_HANDLE_SIZE * 2.5
                width: SLIDER_HANDLE_SIZE * 2.5
                top: 0
                borderRadius: '50%'
                marginLeft: -SLIDER_HANDLE_SIZE / 2
                backgroundColor: considerit_blue
                position: 'relative'
                boxShadow: "0px 1px 0px black, inset 0 1px 2px rgba(255,255,255, .4), 0px 0px 0px 1px #{considerit_blue}"

            IMG className:'bubblemouth', src: bubblemouth_src, style: bubble_mouth_props

        DIV 
          className: "auth" + (if @local.submitting then ' waiting' else '')
          style: auth_area_style
          if root.auth_mode in ['login', 'register'] && !current_user.provider && !third_party_authenticated
            DIV className: 'third_party_auth',
              LABEL 
                style: {marginRight: 18}
                'Instantly:'
              for provider in providers
                do (provider) =>
                  BUTTON key: provider, className: "third_party_option #{provider}", onClick: (=> @startThirdPartyAuth(provider)),
                    I className: "fa fa-#{provider}"
                    SPAN null, provider

              DIV 
                style: 
                  fontWeight: 700
                  paddingTop: '1em'
                  color: "rgba(36,120,204,0.1)"
                dangerouslySetInnerHTML:{__html: "&mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;  <label style=\"padding: 0 18px; color: #{considerit_blue}\">or</label>  &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;"}

          if root.auth_mode in ['login', 'login_via_reset_password_token', 'verify']
            DIV null, 
              if root.auth_mode == 'login'
                LABEL 
                  style: 
                    padding: '1em 0'
                    display: 'block'
                  'By email address:'
              else if root.auth_mode == 'login_via_reset_password_token'
                DIV null,
                  LABEL className: 'reset_password_section_label', 'Reset your password'
                  DIV style: {'margin-bottom': 16}, "We just sent you a verification code via email to #{current_user.email}. Check your email, and enter the code here:"
              else if root.auth_mode == 'verify'
                DIV null,
                  LABEL className: 'reset_password_section_label', 'Confirm your email address'
                  DIV style: {'margin-bottom': 16}, 
                    "Hi! For additional security, we require users to prove that they control the email address with which they’re accessing this private area." 
                  DIV style: {'margin-bottom': 16},
                    "We just sent a verification code via email to #{current_user.email}. Check your email, and enter the code here:"


              TABLE className: 'auth_fields login',
                TBODY null,
                  if root.auth_mode in ['login_via_reset_password_token', 'verify']
                    TR null, 
                      TD className: 'label_cell', 
                        LABEL htmlFor: 'user_verification_code', 'code:'

                      TD className: 'field_cell', 
                        INPUT
                          id: "verification_code"
                          name: "verification_code"
                          key: "reset_password_token_input_box"
                          placeholder: "verification code"
                          required: "required"
                          type: "text"
                          onKeyPress: submitOnEnter
                          onChange: (event) => current_user.verification_code = event.target.value
                        DIV 
                          style: {fontSize: 12}
                          "Find code in an email just sent to you."

                  else
                    TR null,
                      TD className: 'label_cell',
                        LABEL htmlFor: 'user_email', 'email:'
                      TD className: 'field_cell',
                        email_input_field

                  if root.auth_mode in ['login_via_reset_password_token', 'login']
                    TR null,
                      TD {style: (if root.auth_mode == 'login_via_reset_password_token' then {width: '37%'} else {}), className: 'label_cell'},
                        LABEL htmlFor: 'user_password', "#{if root.auth_mode == 'login_via_reset_password_token' then 'new ' else ''}password:"

                      TD className: 'field_cell', 
                        password_input_field,
                        if root.auth_mode == 'login'
                          A 
                            onClick: @sendResetPassword
                            style: 
                              fontSize: 11
                              borderBottom: '1px solid #ccc'
                              color: '#888'
                              marginLeft: 12
                              position: 'relative'
                              top: -4
                            'I forgot! Email me password instructions.'


          else 
            # creating new account
            TABLE className: 'auth_fields register', 
              TBODY null,
                TR null, 
                  TD className: 'label_cell',
                    LABEL htmlFor: 'user_name', 'Hi, my name is:'
                  TD className: 'field_cell', 
                    name_input_field

                if third_party_authenticated && @root.auth_mode != 'update'
                  p = if current_user.google_uid then 'google' else if current_user.facebook_uid then 'facebook' else 'twitter'
                  TR null, 

                    TD className: 'label_cell',
                      LABEL htmlFor: 'user_provider', 
                        if third_party_authenticated then 'I login via:' else 'I login as:'
                    TD className: 'field_cell', 
                      BUTTON className: "third_party_option #{p}", style: {cursor: 'default'},
                        I className: "fa fa-#{p}"
                        SPAN null, p

                else

                  TR null, 

                    TD className: 'label_cell',
                      LABEL htmlFor: 'user_email', 'I login as:'
                    TD className: 'field_cell', 
                      if !Modernizr.input.placeholder
                        LABEL htmlFor: 'user_email', 'Email:'
                      if root.auth_mode == 'register-after-invite'
                        current_user.email
                      else
                        email_input_field

                      if !Modernizr.input.placeholder
                        LABEL htmlFor: 'user_password', 'Password:'
                      password_input_field

                # We're not going to bother with letting IE9 users set a profile picture. Too much hassle. 
                if window.FormData

                  TR null, 
                    TD className: 'label_cell', 
                      LABEL htmlFor: 'user_avatar', 'I look like this:'
                    TD className: 'field_cell',
                      # hack for submitting file data in ActiveREST for now
                      # we'll just submit the file form after user is signed in


                      FORM 
                        id: 'user_avatar_form'
                        action: '/update_user_avatar_hack', 

                        DIV className: 'avatar_preview_enclosure',
                          IMG id: 'avatar_preview', src: if current_user.avatar_remote_url then current_user.avatar_remote_url else if current_user.b64_thumbnail then current_user.b64_thumbnail else null

                        INPUT 
                          id: 'user_avatar'
                          name: "avatar"
                          type: "file"
                          style: {marginTop: 24, verticalAlign: 'top'}
                          onChange: (ev) => 
                            @submit_avatar_form = true
                            input = $('#user_avatar')[0]
                            if input.files && input.files[0]
                              reader = new FileReader()
                              reader.onload = (e) ->
                                $("#avatar_preview").attr 'src', e.target.result
                              reader.readAsDataURL input.files[0]
                              #current_user.avatar = input.files[0]
                            else
                              $("#avatar_preview").attr('src', "<%= asset_path 'no_image_preview.png' %>")

                if subdomain.has_civility_pledge && root.auth_mode != 'update'
                  TR null,
                    TD className: 'label_cell', 
                      LABEL null, 'Community pledge:'
                    TD className: 'field_cell',
                      UL className: 'pledges',
                        for pledge, idx in pledges
                          LI 
                            className: 'pledge'
                            style: {listStyle: 'none'} 
                            INPUT 
                              className:"pledge-input"
                              type:'checkbox'
                              id:"pledge-#{idx}"
                              name:"pledge-#{idx}"
                              style: {fontSize: 21}
                            LABEL 
                              htmlFor: "pledge-#{idx}"
                              style: 
                                fontSize: 14
                                color: '#414141'
                                paddingLeft: 6
                                fontWeight: 400
                              pledge

          if current_user.errors && current_user.errors.length > 0
            DIV
              style: 
                textAlign: 'center'
                fontSize: 21
                color: 'darkred'
                backgroundColor: '#ffD8D8' 
                padding: 10
              I 
                className: 'fa fa-exclamation-circle'
                style: {paddingRight: 9}
              SPAN null, "#{current_user.errors.join(', ')}"

          if root.auth_mode in ['login', 'register']
            toggle_auth = A 
                      style: 
                        display: 'inline-block'
                        color: considerit_blue
                        textDecoration: 'underline'
                        backgroundColor: 'transparent'
                        border: 'none'
                        fontWeight: 600
                      onClick: => 
                        current_user = fetch('/current_user')
                        @root.auth_mode = if @root.auth_mode == 'register' then 'login' else 'register'
                        current_user.errors = []
                        save(@root)                      
                      if root.auth_mode == 'register'
                        'Use an Existing Account' 
                      else 
                        'Create an Account'

            DIV 
              style: 
                fontSize: 20
                left: 0
                position: 'relative'
                top: -6
                fontWeight: 'normal'
                marginTop: 20
                backgroundColor: '#ffffa1'
                padding: 14
              SPAN null,
                if root.auth_mode == 'register'
                  ['Or ', toggle_auth, ' if you have one already']
                else
                  ['Or ', toggle_auth, ' if you need one']

        DIV null, 
          DIV
            className:'auth_button primary_button' + (if @local.submitting then ' disabled' else '')
            onClick: @submitAuth
            if root.auth_mode == 'register'
              'Create account' 
            else if root.auth_mode == 'register-after-invite'
              'Complete registration'
            else if root.auth_mode == 'update'
              'Update'
            else 
              'Login'
            if root.auth_reason == 'Save your Opinion' then ' and save your opinion'

          if root.auth_mode == 'update'
            if @local.saved_successfully
              SPAN style: {color: 'green'}, "Updated successfully"
          else
            A 
              className:'cancel_auth_button primary_cancel_button'
              onClick: =>
                if root.auth_mode == 'verify'
                  window.app_router.navigate("/", {trigger: true})
                root.auth_mode = null
                root.publish_this_opinion = null
                save root
              'cancel log in'


  componentDidMount : -> 
    if $(@getDOMNode()).find('.auth_heading').length > 0
      $(document).scrollTop $(@getDOMNode()).find('.auth_heading').offset().top - 10

    window.writeToLog
      what: 'accessed authentication'


  startThirdPartyAuth : (provider) ->
    root = @root
    new ThirdPartyAuthHandler
      provider : provider
      callback : (new_data) => 
        # Yay we got a new current_user object!  But this hasn't gone
        # through the normal arest channel, so we gotta save it in
        # sneakily with updateCache()
        arest.updateCache(new_data)

        # We know that the user has authenticated, but we don't know
        # whether they've completed OUR registration process including
        # the pledge.  The server tells us this via the existence of a
        # `user' object in current_user.

        current_user = fetch '/current_user'
        if current_user.logged_in
          # We are logged in!  The user has completed registration.
          @authCompleted()

        else 
          # We still need to show the pledge!
          root.auth_mode = 'register'
          save(root)

  submitAuth : (ev) -> 
    ev.preventDefault()
    $el = $(@getDOMNode())

    @local.submitting = true
    save @local

    current_user = fetch('/current_user')

    current_user.signed_pledge = $el.find('.pledge-input').length == $el.find('.pledge-input:checked').length
    current_user.trying_to = @root.auth_mode
    
    save current_user, => 
      if @root.auth_mode in ['register', 'update']
        ensureCurrentUserAvatar()

      if @root.auth_mode == 'update'
        @local.saved_successfully = current_user.errors.length == 0        

      # Once the user logs in, we will stop showing the log-in screen
      else if current_user.logged_in
        @authCompleted()

      @local.submitting = false
      save @local

    # hack for submitting file data in ActiveREST for now
    # we'll just submit the file form after user is signed in
    # TODO: investigate alternatives for submitting form data
    if @submit_avatar_form

      $('#user_avatar_form').ajaxSubmit
        type: 'PUT'
        data: 
          authenticity_token: current_user.csrf
          trying_to: 'update_avatar_hack'


  sendResetPassword : -> 

    # Tell the server to email us a token
    current_user = fetch('/current_user')
    current_user.trying_to = 'send_password_reset_token'
    save current_user, =>
      if not (current_user.errors?.length > 0)
        # Switch to reset_password mode
        @root.auth_mode = 'login_via_reset_password_token'
        save(@root)
      else
        # console.log("Waiting for user to fix errors #{current_user.errors?}")
        arest.updateCache(current_user)
      
  authCompleted : -> 

    if @root.auth_reason == 'Save your Opinion'
      setTimeout((() -> togglePage('results', 'after_save')), 700)

    @root.auth_mode = @root.auth_reason = null

    save @root

styles += """
.auth .third_party_option {
  border: 1px solid #777777;
  border-color: rgba(0, 0, 0, 0.2);
  border-bottom-color: rgba(0, 0, 0, 0.4);
  color: white;
  box-shadow: inset 0 0.1em 0 rgba(255, 255, 255, 0.4), inset 0 0 0.1em rgba(255, 255, 255, 0.9);
  display: inline-block;
  padding: 3px 9px 3px 34px;
  margin: 0 4px;
  text-align: center;
  text-shadow: 0 1px 0 rgba(0, 0, 0, 0.5);
  border-radius: 0.3em;
  position: relative;
  background-color: #{considerit_blue}; }
  .auth .third_party_option:hover {
    background-color: #19528b; }
  .auth .third_party_option:before {
    border-right: 0.075em solid rgba(0, 0, 0, 0.1);
    box-shadow: 0.075em 0 0 rgba(255, 255, 255, 0.25);
    content: "";
    position: absolute;
    top: 0;
    left: 25px;
    height: 100%;
    width: 1px; }
  .auth .third_party_option i {
    margin-right: 18px;
    display: inline-block;
    font-size: 16px;
    position: absolute;
    left: 9px; }
  .auth .third_party_option span {
    font-weight: 600;
    font-size: 12px; }
.auth .reset_password_section_label {
  padding: 0 0 1em 0;
  display: block; }
.auth input[type="text"], .auth input[type="email"], .auth input[type="password"] {
  border: 1px solid #aaaaaa;
  padding: 5px 10px;
  width: 100%;
  font-size: 18px;
  color: #414141; }
.auth table {
  border-collapse: separate; }
  .auth table.login {
    border-spacing: 0 0.25em; }
  .auth table.register {
    border-spacing: 0 1em; }
    .auth table.register #user_password {
      margin-top: 0.5em; }
.auth td {
  vertical-align: top; }
  .auth td.label_cell {
    width: 37%; }
  .auth td.field_cell {
    width: 100%;
    padding-left: 18px; }
.auth label {
  color: #{considerit_blue};
  font-weight: 600; }
.auth .login label {
  color: #595959; }

.avatar_preview_enclosure {
  height: 60px;
  width: 60px;
  border-radius: 50%;
  background-color: #e6e6e6;
  overflow: hidden;
  display: inline-block;
  margin-right: 18px; }
  .avatar_preview_enclosure #avatar_preview {
    width: 60px; }

"""

ProposalSummary = ReactiveComponent
  displayName: 'ProposalSummary'

  render : ->
    subdomain = fetch('/subdomain')

    proposal = @data()
    hover_class = if @local.hovering_on == proposal.id then 'hovering' else ''

    link_hover_color = considerit_blue
    cell_border = "1px solid #{if @local.hovering_on then link_hover_color else 'rgb(191, 192, 194)'}"
    TR 
      className: "proposal_summary " + hover_class
      style:
        height: ''
        padding: '0 30px'
        display: 'block'
        borderLeft: cell_border
      onMouseEnter: => @local.hovering_on = true; save(@local)
      onMouseLeave: => @local.hovering_on = false; save(@local)

      if subdomain.name == 'livingvotersguide'
        TD className: 'summary_measure_designator',
          if proposal.category && proposal.designator
            A onClick: clickInternalLink, href: proposal_url(proposal), style: {color: "#{if @local.hovering_on then link_hover_color else ''}"},
              "#{proposal.category[0]}-#{proposal.designator}"

      TD className: 'summary_name', style: {width: (if subdomain.name == 'livingvotersguide' then 270 else 320)},
        A onClick: clickInternalLink, href: proposal_url(proposal), style: {color: "#{if @local.hovering_on then link_hover_color else ''}"},
          proposal.name
      TD
        className: 'summary_decide'
        style: {borderLeft: cell_border, borderRight: cell_border, cursor: 'pointer'},
        onClick: (=> window.app_router.navigate("/#{proposal.slug}", {trigger: true}))
        if !proposal.your_opinion || !fetch(proposal.your_opinion).published \
           || fetch(proposal.your_opinion).stance_segment == 3
          style = {fontWeight: 400, color: 'rgb(158,158,158)', fontSize: 21}
          if @local.hovering_on
            style.color = 'black'
            style.fontWeight = 600
          SPAN style: style, '?'
        else if fetch(proposal.your_opinion).stance_segment < 3
          SPAN style: {position: 'relative', left: 14},
            IMG 
              className: 'summary_opinion_marker'
              src: "<%= asset_path 'no_x.svg' %>"
              style: {width: 24, position: 'absolute', left: -28}
            SPAN style: {color: 'rgb(239,95,98)', fontSize: 18, fontWeight: 600}, 'No'
        else
          SPAN style: {position: 'relative', left: 14},
            IMG 
              className: 'summary_opinion_marker'
              src: "<%= asset_path 'yes_check.svg' %>"
              style: {width: 24, position: 'absolute', left: -28}

            SPAN style: {color: 'rgb(166,204,70)', fontSize: 18, fontWeight: 600}, 'Yes'

      TD
        className: 'summary_share'
        style: {cursor: 'pointer'}
        onClick: (=> window.app_router.navigate(proposal_url(proposal), {trigger: true}))
        if proposal.top_point
          DIV 
            className: 'top_point community_point pro'
            style : { width: 270, position: 'relative' }

            DIV className:'point_content',
              IMG 
                className: 'community_point_mouth'
                src: "<%= asset_path 'community_point_mouth.png' %>"

              DIV className:'point_nutshell', style: {fontSize: 15},
                "#{proposal.top_point.nutshell[0..30]}..."

styles += """
tr.proposal_summary {
  min-height: 60px; }

td.summary_name {
  display: inline-block;
  font-size: 18px;
  font-weight: 500; }
  td.summary_name a {
    border-bottom: 1px solid #b1afa7; }

td.summary_decide {
  width: 170px;
  text-align: center;
  display: inline-block;
  height: 100%;
  min-height: 66px; }

td.summary_share {
  width: 320px;
  display: inline-block;
  padding-left: 15px;
  margin-top: -4px; }
"""

Homepage = ReactiveComponent
  displayName: 'Homepage'
  render: ->
    subdomain = fetch('/subdomain')
    if window["#{subdomain.name}Homepage"]
      return window["#{subdomain.name}Homepage"]()
    else
      return DefaultHomepage()


DefaultHomepage = ReactiveComponent
  displayName: 'DefaultHomepage'

  componentDidMount : -> @initOrUpdateHeader()

  componentDidUpdate : -> @initOrUpdateHeader()

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.find('.sticky_header.stickable').StickyElement('destroy')

  initOrUpdateHeader : -> 
    $el = $(@getDOMNode())

    $header = $el.find('.sticky_header.stickable')
    if $header.length > 0
      $header.StickyElement
        placeholder: $el.find('.sticky_header.placeholder')[0]
        container: $el
        stick_on_zoomed_screens: false

  render : ->
    subdomain = fetch('/subdomain')
    proposals = fetch('/proposals')

    # The "Welcome to the community!" people
    contributors = @page.contributors.filter((u)-> !!fetch(u).avatar_file_name)
    contributors_without_avatar_count = @page.contributors.filter((u)-> !fetch(u).avatar_file_name).length

    # Columns of the sticky header for the proposal list.
    if subdomain.name == 'livingvotersguide'
      columns = [ {heading: 'Learn', details: 'about your ballot'}, \
                  {heading: 'Decide', details: 'how you\'ll vote'}, \
                  {heading: 'Share', details: 'your opinion'}, \
                  {heading: 'Join', details: 'the contributors'}]
    else
      columns = [ {heading: 'Learn', details: 'about the issues'}, \
                  {heading: 'Decide', details: 'what you think'}, \
                  {heading: 'Share', details: 'your opinion'}, \
                  {heading: 'Join', details: 'the contributors'}]

    sticky_header_height = 79

    DIV className: 'homepage',
      # Draw the sticky subheader
      DIV className: "sticky_header placeholder", style: {width: '100%', height: sticky_header_height}
      DIV 
        className: "sticky_header stickable"
        style: 
          backgroundColor: subdomain.branding.primary_color
          color: 'white'
          height: sticky_header_height
          width: '100%'
          zIndex: 9999
          minWidth: PAGE_WIDTH #minwidth is for when dropping into sticky, position fixed mode

        TABLE style: {margin: 'auto', paddingLeft: 242},
          TBODY null,
            TR null,
              for col in columns
                TD style: {display: 'inline-block', width: 250},
                  DIV 
                    style: 
                      fontWeight: 700
                      fontSize: 42
                      textAlign: 'center'
                    col.heading
                  DIV 
                    style: 
                      fontWeight: 300
                      fontSize: 18
                      textAlign: 'center'
                      position: 'relative'
                      top: -8
                    col.details

      DIV style: {marginTop: 30},
        if contributors.length > 0
          DIV 
            style: 
              width: PAGE_WIDTH
              position: 'relative'
              margin: 'auto'
            DIV 
              style:
                left: 1005
                position: 'absolute'
                width: 165
                textAlign: 'left'
                zIndex: 1

              for user in _(contributors).first(90)
                Avatar key: user, className: 'welcome_avatar', style: {height: 32, width: 32, margin: 1}
              if contributors_without_avatar_count > 0
                others = if contributors_without_avatar_count != 1 then 'others' else 'other'
                DIV style: {fontSize: 14, color: "#666"}, "...and #{contributors_without_avatar_count} #{others}"

        # Draw the proposal summaries
        for cluster, index in proposals.clusters or []
          DIV null,
            if index == 1 and subdomain.name == 'livingvotersguide'
              ZipcodeBox()

            if cluster.proposals?.length > 0 
              TABLE
                style:
                  borderLeft: '0px solid rgb(191, 192, 194)'
                  margin: '20px auto'
                  position: 'relative'

                TBODY null,
                  TR null,
                    # Draw the cluster name off to the side
                    TH 
                      style: 
                        textAlign: 'right'
                        width: 115
                        padding: '8px 8px 8px 8px'
                        display: 'inline-block'
                        fontSize: 18
                        position: 'absolute'
                        left: -125
                        fontWeight: if browser.high_density_display then 300 else 400
                      cluster.name                

                  # Draw each proposal summary
                  for proposal in cluster.proposals
                    ProposalSummary
                      key: proposal.key
                      cluster: cluster.name
            
            # TODO: There are probably lots of cases where we want to add more details to
            #       a cluster of proposals.  For example, saying that proposals in cluster
            #       "Council meeting 6/7" will be open for discussion at the upcoming
            #       meeting. Keep an eye on this possible generality (and eliminate this
            #       edge case if we do generalize it)
            if cluster.name == 'Advisory votes' and subdomain.name == 'livingvotersguide'
              DIV
                style:
                  color: 'rgb(108,107,98)'
                  fontSize: 16
                  paddingLeft: 164
                  paddingTop: 12
                  margin: 'auto'
                  width: PAGE_WIDTH
                "* Advisory Votes are not binding. They are a consequence of "
                A
                  href: "http://en.wikipedia.org/wiki/Washington_Initiative_960"
                  style:
                    fontWeight: 600
                    color: 'rgb(108,107,98)'
                  'Initiative 960' 
                " passing in 2007."

      if permit('create proposal') > 0
        # lazily styled & positioned...
        DIV style: {width: 871, margin: 'auto'}, 
          A 
            style: {color: '#888', textDecoration: 'underline', fontSize: 18, marginLeft: 30}
            href: '/proposal/new'
            onClick: (e) => 
              clickInternalLink(e)
              $(document).scrollTop(0)
            'Create new proposal'

window.ElectionHomepage = ReactiveComponent
  displayName: 'Homepage'
  render : ->
    subdomain = fetch('/subdomain')
    proposals = fetch('/proposals')
    line_height = '1.8em'

    DIV
      style: {fontSize: 22}

      STYLE null,
        '''a.proposal:hover {border-bottom: 1px solid grey}'''

      # List all clusters
      for cluster, index in proposals.clusters or []
        if cluster.proposals?.length > 0
          first_column =
            width: 350
            marginLeft: 200
            display: 'inline-block'
            verticalAlign: 'top'

          secnd_column =
            width: 300
            display: 'inline-block'
            verticalAlign: 'top'
            marginLeft: 50

          first_header =
            fontSize: 30
            marginBottom: 40
            fontWeight: 600
          _.extend(first_header, first_column)

          secnd_header =
            fontSize: 30
            marginBottom: 45
            fontWeight: 600
            position: 'relative'
            whiteSpace: 'nowrap'
          _.extend(secnd_header, secnd_column)

          special_secnd_headers =
            'Debate': "Candidates' Opinions"

          # 
          # Cluster of proposals
          DIV
            style: margin: '45px 0'

            # Header of cluster
            H1
              style: first_header
              cluster.name
            H1
              style: secnd_header
              SPAN
                style:
                  position: 'absolute'
                  bottom: -43
                  fontSize: 21
                  color: '#444'
                  fontWeight: 300
                'Oppose'
              SPAN
                style:
                  position: 'absolute'
                  bottom: -43
                  fontSize: 21
                  color: '#444'
                  right: 0
                  fontWeight: 300
                'Support'
              special_secnd_headers[cluster.name] or 'Members\' Opinions'

            for proposal in cluster.proposals
              author = fetch(proposal.user)
              is_candidates = cluster.name.toLowerCase() == 'candidates'

              # Proposal
              DIV
                key: proposal.key
                style:
                  minHeight: 70

                DIV style: first_column,

                  if is_candidates
                    candidate = proposal.roles.editor.length > 0 and proposal.roles.editor[0]
                    if not candidate or candidate == '-'
                      candidate = author.key

                    # Person's icon
                    A
                      href: proposal_url(proposal)
                      onClick: clickInternalLink
                      Avatar
                        key: candidate
                        user: candidate
                        style:
                          height: 50
                          width: 50
                          borderRadius: 0
                          backgroundColor: '#ddd'

                  # Name of Proposal
                  DIV
                    style:
                      display: 'inline-block'
                      fontWeight: 400
                      marginLeft: if is_candidates then 18
                      paddingBottom: 20
                      width: first_column.width - 50 + (if is_candidates then -18 else 0)
                      marginTop: if is_candidates then 9
                    A
                      className: 'proposal'
                      style: if not is_candidates then {borderBottom: '1px solid grey'}
                      onClick: clickInternalLink
                      href: proposal_url(proposal)
                      proposal.name

                # Histogram for Proposal
                A
                  href: proposal_url(proposal)
                  onClick: clickInternalLink
                  DIV
                    style: secnd_column
                    MiniHisto(proposal: proposal, width: 300, height: 50)


MiniHisto = ReactiveComponent
  displayName: 'mini_histo'
  render: ->
    @opinions = fetch('/page/' + @props.proposal.slug).opinions
    icons = for opinion in @opinions
      # id = arest.key_id(user.key)
      #"/system/avatars/#{id}/small/#{user.avatar_file_name}"
      neutral = Math.abs(opinion.stance) < .1
      Avatar
        key: opinion.user
        user: opinion.user
        style:
          position: 'absolute'
          backgroundColor: '#d3d3d3'
          # filter: 'grayscale(.8)'
          # '-webkit-filter': 'grayscale(.8)'
          #opacity: .8
          # border:  if neutral then 'solid 1px black'
          # opacity: if neutral then .2
    DIV
      style:
        height: @props.height
        width: @props.width
        #backgroundColor: '#f8f8f8'
        position: 'relative'
        borderBottom: '1px solid #444'
      SPAN
        style:
          position: 'absolute'
          left: -21
          bottom: -12
          fontSize: 19
          fontWeight: 500
          color: '#444'
        '–'
      SPAN
        style:
          position: 'absolute'
          right: -21
          bottom: -13
          fontSize: 19
          fontWeight: 500
          color: '#444'
        '+'
      DIV
        ref: 'histo'
        icons

  attach_mini_histo: ->
    if @refs and @refs.histo and not @mounted
      page = fetch('/page/' + @props.proposal.slug)
      histo = @refs.histo.getDOMNode()
      icons = histo.childNodes
      opinions = for opinion, i in page.opinions
        {stance: opinion.stance, icon: icons[i]}
      mini_histo(@props.width, @props.height-1, histo, opinions)
      @mounted = true
  componentDidMount: ->
    @attach_mini_histo()
  componentDidUpdate: ->
    @attach_mini_histo()
  componentWillUnmount: ->
    @mounted = false


# MiniHisto2 = ReactiveComponent
#   displayName: 'mini_histo'
#   render: ->
#     # Virtual component computes the data... until I fix this
#     h = HistogramData
#           proposal_slug: @props.proposal.slug
#           width: @props.width
#           height: @props.height
#           max_avatar_size: 40
#     histogram_data = fetch('histogramdata/' + @props.proposal.slug)
#     if not histogram_data.columns
#       return DIV null, h, loading_indicator

#     columns = histogram_data.columns
#     num_columns = columns.length
#     avatar_size = histogram_data.avatar_size

#     effective_histogram_width = num_columns * avatar_size + 2
#     margin_adjustment = -(effective_histogram_width - HISTOGRAM_WIDTH) / 2

#     DIV
#       style:
#         height: @props.height
#         width: @props.width
#         backgroundColor: '#eee'
#         position: 'relative'
#       h
#       for bar, i in columns
#         for opinion, j in bar
#           user = opinion.user
#           Avatar 
#             key: user
#             user: user
#             style:
#               position: 'absolute'
#               height: avatar_size
#               width: avatar_size
#               left: i * avatar_size
#               bottom: j * avatar_size


ProfileMenu = ReactiveComponent
  displayName: 'ProfileMenu'

  render : -> 
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')

    menu_options = [
      {href: '/edit_profile', label: 'Edit Profile'},
      {href: '/dashboard/email_notifications', label: 'Notifications'},
      if current_user.is_admin then {href: '/dashboard/import_data', label: 'Import Data'} else null,
      if current_user.is_admin then {href: '/dashboard/application', label: 'App Settings'} else null,
      if current_user.is_admin then {href: '/dashboard/roles', label: 'User Roles'} else null,
      if current_user.is_moderator then {href: '/dashboard/moderate', label: 'Moderate'} else null,
      if subdomain.assessment_enabled && current_user.is_evaluator then {href: '/dashboard/assessment', label: 'Fact-check'} else null 
    ]

    menu_options = _.compact menu_options

    DIV
      style:
        _.extend(
          position: 'absolute'
          right: 50
          top: 17,
          _.clone(@props.style))

      if current_user.logged_in
        SPAN
          className: 'profile_menu_wrap'
          style:
            position: 'relative'
          onMouseEnter: => @local.menu = true; save(@local)
          onMouseLeave: => @local.menu = false; save(@local)
          DIV 
            style: 
              display: if not @local.menu then 'none'
              position: 'absolute'
              marginTop: -8
              marginLeft: -8
              padding: 8
              paddingTop: 50
              paddingRight: 14
              backgroundColor: '#eee'
              left: -82
              textAlign: 'left'
              zIndex: 999999

            for option in menu_options
              A
                className: 'menu_link'
                href: option.href
                key: option.href
                onClick: clickInternalLink
                option.label

            A 
              className: 'menu_link'
              onClick: @logout
              'Log out'

          SPAN 
            style: 
              color: subdomain.branding.header_text_color
              position: 'relative'
              zIndex: 9999999999
              backgroundColor: if !@local.menu then 'rgba(255,255,255, .1)' else 'inherit'
              boxShadow: if !@local.menu then '0px 1px 1px rgba(0,0,0,.1)' else 'none'
              borderRadius: 8
              padding: '3px 4px'

            Avatar key: current_user.user, hide_name: true, className: 'userbar_avatar', style: {height: 20, width: 20, marginRight: 7, marginTop: 1}
            I className: 'fa fa-caret-down', style: {visibility: if @local.menu then 'hidden' else 'visible'}
      else
        A
          'className': 'profile_anchor login'
          'data-action': 'login'
          onClick: (e) =>
            @root.auth_mode = 'login'
            @root.auth_reason = null            
            save @root
          style: {color: 'white'}
          'Log in'

      #Avatar key: current_user.user, className: 'userbar_avatar', style: {height: 26, width: 26, marginTop: -2}


  logout : -> 
    current_user = fetch('/current_user')
    current_user.logged_in = false
    current_user.trying_to = 'logout'

    if @root.auth_mode == 'update'
      @root.page_name = 'homepage'

    @root.auth_mode = null

    save current_user, =>
      # We need to get a fresh your_opinion object
      # after logging out. 

      # TODO: the server should dirty keys on the client when the
      # current_user logs out
      arest.clear_matching_objects((key) -> key.match( /\/page\// ))

    save @root

styles += """
.profile_navigation {
  text-align: right;
  width: 100%;
  padding: 20px 120px 0 0;
  font-size: 21px; }

.menu_link {
  position: relative;
  bottom: 8px;
  padding-left: 27px;
  display: block;
  color: #{considerit_blue};
  white-space: nowrap; }

.menu_link:hover{ color: black; }

.profile_menu_wrap:hover .profile_anchor{ color: inherit; }
"""

Header = ReactiveComponent
  displayName: 'Header'

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')

    DIV 
      style: 
        position: 'relative'
        margin: '0 auto'
        backgroundColor: 'white'
        minWidth: PAGE_WIDTH

      if window["#{subdomain.name}Header"]
        window["#{subdomain.name}Header"]()
      else
        DefaultHeader()

      DIV null, 
        if @root.page_name == 'about'
          A 
            onClick: (=> window.app_router.navigate("/", {trigger: true}))
            style: {position: 'absolute', display: 'inline-block', zIndex: 999, marginTop: 8, marginLeft: 16, fontWeight: 600}
            I className: 'fa fa-home', style: {fontSize: 28, color: '#bbb'}
            SPAN style: {fontSize: 15, paddingLeft: 6, color: '#777', verticalAlign: 'text-bottom'}, 'Home'


      DIV style: { backgroundColor: '#eee', color: '#f00', padding: '5px 20px', display: if @root.server_error then 'block' else 'none'},
        'Warning: there was a server error!'


FBShare = ReactiveComponent
  displayName: 'FBShare'

  componentDidMount: ->
    FB.XFBML.parse document

  render: -> 
    layout = 'button'
    SPAN 
      style: {display: 'inline-block', marginRight: 5, position: 'relative', top: -6}
      dangerouslySetInnerHTML: { __html: "<fb:share-button data-layout='#{layout}'></fb:share-button>"}
    

FBLike = ReactiveComponent
  displayName: 'FBLike'
  render : -> 
    page = 'http://www.facebook.com/pages/Living-Voters-Guide/157151824312366'
    IFRAME 
      style: {border: 'none', overflow: 'hidden', width: 90, height: 21}
      src: "//www.facebook.com/plugins/like.php?href=#{page}&send=false&layout=button_count&width=450&show_faces=false&action=like&colorscheme=light&font=lucida+grande&height=21"
      scrolling: "no"
      frameBorder: "0"
      allowTransparency: "true"

Tweet = ReactiveComponent
  displayName: 'Tweet'

  render: ->
    url = "https://platform.twitter.com/widgets/tweet_button.1410542722.html#?_=1410827370943&count=none&id=twitter-widget-0&lang=en&size=m"
    for url_param in ['hashtags', 'original_referer', 'related', 'text', 'url']
      if @props[url_param]
        url += "&#{url_param}=#{@props[url_param]}"

    IFRAME 
      src: url
      scrolling: "no"
      frameBorder: "0"
      allowTransparency: "true"
      className: "twitter-share-button twitter-tweet-button twitter-share-button twitter-count-none"
      style: {width: 57; height: 20}


Footer = ReactiveComponent
  displayName: 'Footer'
  render : -> 
    subdomain = fetch('/subdomain')

    DIV 
      style: 
        position: 'relative'
        padding: '2.5em 0 .5em 0'
        textAlign: 'center'
      if window["#{subdomain.name}Footer"]
        window["#{subdomain.name}Footer"]()
      else
        DefaultFooter()

TechnologyByConsiderit = ReactiveComponent
  displayName: 'TechnologyByConsiderit'
  render : -> 
    DIV style: {textAlign: 'left', padding: '0 12px', color: 'rgb(131,131,131)', display: 'inline-block', fontSize: 20},
      "Technology by "
      A href: 'http://consider.it', style: {textDecoration: 'underline', color: '#B03B42', fontWeight: 600}, target: '_blank', 'Considerit'

# top secret proposal creation component
EditProposal = ReactiveComponent
  displayName: 'EditProposal'

  saveProposal : -> 
    $el = $(@getDOMNode())

    name = $el.find('#name').val()
    description = $el.find('#description').val()
    slug = $el.find('#slug').val()
    cluster = $el.find('#cluster').val()
    cluster = null if cluster == ""
    active = $el.find('#open_for_discussion:checked').length > 0
    hide_on_homepage = $el.find('#listed_on_homepage:checked').length == 0

    if @props.fresh
      proposal =
        key : '/new/proposal'
        name : name
        description : description
        cluster : cluster
        slug : slug
        active: active
        hide_on_homepage: hide_on_homepage

      if @local.roles
        proposal.roles = @local.roles
        proposal.invitations = @local.invitations

    else 
      proposal = @data()
      _.extend proposal, 
        cluster: cluster
        name: name
        slug: slug
        description: description
        active: active
        hide_on_homepage: hide_on_homepage

    if @local.description_fields
      proposal.description_fields = JSON.stringify(@local.description_fields)

    save proposal, -> window.app_router.navigate "/#{slug}", {trigger : true}

  render : ->
    user = fetch('/current_user')
    proposal = @data()
    subdomain = fetch '/subdomain'
    
    return DIV null, 'Nothing to see here, move on' if (permit('update proposal', proposal) < 0) || (!@props.fresh && !proposal.slug )

    block_style = { width: CONTENT_WIDTH, padding: '2px 0px', marginBottom: 12, position: 'relative' }
    description_field_style = {fontSize: 16, width: CONTENT_WIDTH - 200, padding: '4px 8px', marginBottom: 8, border: '1px solid #ccc'}
    input_style = _.extend {}, description_field_style, {marginLeft: 18}
    label_style = {verticalAlign: 'top', fontSize: 16, width: 150, display: 'inline-block'}

    if !@local.description_fields
      @local.description_fields = if @data().description_fields then $.parseJSON(@data().description_fields) || [] else []
      if @local.description_fields.length > 0
        if @local.description_fields[0].group
          # Right now, we just downgrade group syntax to flat description list syntax
          # TODO: when editing a proposal, support the proposal description groups syntax (or get rid of it)
          @local.description_fields = _.flatten(@local.description_fields.map (group) -> group.items)

      save @local

    DIV null, 
      DashHeader name: if @props.fresh then "New Proposal" else "Edit #{proposal.name}"
      DIV style: { width: PAGE_WIDTH, margin: 'auto', padding: '3em 0' },

        DIV style: block_style,
          LABEL htmlFor:'slug', style: label_style, 'URL'
          INPUT 
            id:'slug'
            name:'slug'
            pattern:'^.{3,}'
            placeholder:"The URL in #{window.location.origin}/URL. Just letters, numbers, underscores, dashes."
            required:'required'
            defaultValue: if @props.fresh then null else proposal.slug
            style: input_style

        DIV style: block_style,
          LABEL htmlFor:'name', style: label_style, 'Topic question'
          INPUT 
            id:'name'
            name:'name'
            pattern:'^.{3,}'
            placeholder:'Make this super succinct with a <verb> <noun>.'
            required:'required'
            defaultValue: if @props.fresh then null else proposal.name
            style: input_style

        DIV style: block_style,
          LABEL htmlFor:'description', style: label_style, 'Description'
          AutoGrowTextArea 
            id:'description'
            name:'description'
            pattern:'^.{3,}'
            placeholder:'Make this good :)'
            required:'required'
            defaultValue: if @props.fresh then null else proposal.description
            style: _.extend {}, input_style, {height: 150}

        DIV style: {marginLeft: 168, marginBottom: 30},

          for field,idx in @local.description_fields
            
            DIV key: "field-#{idx}", style: block_style,
              I className: "fa fa-plus-circle", style: {position: 'absolute', left: -20, top: 10, color: '#bbb'}
              INPUT 
                style: description_field_style
                type: 'text'
                id:"field-#{idx}-label"
                name:"field-#{idx}-label"
                pattern:'^.{3,}'
                placeholder:'Label'
                required:'required'
                onChange: do(idx) => (e) => @local.description_fields[idx].label = e.target.value; save(@local)
                value: @local.description_fields[idx].label

              AutoGrowTextArea 
                id:"field-#{idx}-html"
                name:"field-#{idx}-html"
                pattern:'^.{3,}'
                placeholder:'Text that is shown when expanded'
                required:'required'
                onChange: do(idx) => (e) => @local.description_fields[idx].html = e.target.value; save(@local)
                value: @local.description_fields[idx].html
                style: description_field_style
              
              SPAN 
                style: {color: '#ccc', textDecoration: 'underline', fontSize: 12, cursor: 'pointer', position: 'absolute', top: 5, marginLeft: 20}
                onClick: do (idx) => =>
                  @local.description_fields.splice(idx, 1)
                  save @local
                'delete'

          SPAN
            style: {color: '#bbb', cursor: 'pointer', fontSize: 14}
            onClick: => 
              @local.description_fields.push({label: null, html: null})
              save @local

            "+ "
            SPAN style: {textDecoration: 'underline'}, "expandable field"


        DIV style: block_style,
          LABEL htmlFor:'cluster', style: label_style, 'Group (optional)'
          INPUT 
            id:'cluster'
            name:'cluster'
            pattern:'^.{3,}'
            placeholder:'The group to which this proposal belongs, if any.'
            defaultValue: if @props.fresh then null else proposal.cluster
            style: input_style

        DIV style: block_style,
          INPUT 
            id: 'listed_on_homepage'
            name: 'listed_on_homepage'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else !proposal.hide_on_homepage
          LABEL htmlFor: 'listed_on_homepage', 'List on homepage'

        DIV style: block_style,
          INPUT 
            id: 'open_for_discussion'
            name: 'open_for_discussion'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else proposal.active
          LABEL htmlFor: 'open_for_discussion', 'Open for discussion'


        if @props.fresh
          DIV null, 
            SPAN 
              style: {textDecoration: 'underline', cursor: 'pointer'}
              onClick: => 
                @local.edit_roles = !@local.edit_roles
                save @local
              I className: 'fa-child fa', style: {marginRight: 7}
              'Roles and invitations'

            DIV 
              style: 
                width: CONTENT_WIDTH
                backgroundColor: '#fafafa'
                padding: '10px 60px'
                display: if @local.edit_roles then 'block' else 'none' #roles has to be rendered
                                                                              #so that default roles are 
                                                                              #set on the proposal

              ProposalRoles key: @local

        DIV null,
          INPUT className:'button primary_button', type:'submit', value:"#{if @props.fresh then 'Publish' else 'Update'}", onClick: @saveProposal


About = ReactiveComponent
  displayName: 'About'

  componentWillMount : ->
    @local.embed_html_directly = true
    @local.html = null
    @local.save

  componentDidMount : -> @handleContent()
  componentDidUpdate : -> @handleContent()

  handleContent : -> 
    $el = $(@getDOMNode())

    if @local.embed_html_directly
      # have to use appendChild rather than dangerouslysetinnerhtml
      # because scripts in the about page html won't get executed
      # when using dangerouslysetinnerhtml
      if @local.html
        $el.find('.embedded_about_html').append @local.html

    else
      # REACT iframes don't support onLoad, so we need to figure out when 
      #               to check the height of the loaded content ourselves      
      $el.prop('tagName').toLowerCase() == 'iframe'
      iframe = $el[0]
      _.delay ->
        try 
          iframe.height = iframe.contentWindow.document.body.scrollHeight + "px"
        catch e
          iframe.height = "2000px"
          console.error 'Couldn\'t set about page iframe height because of http/https mismatch. Should work in production.'
          console.error e
      , 1000


  render : -> 
    subdomain = fetch('/subdomain') 

    if @local.embed_html_directly && !@local.html && subdomain.about_page_url
      # fetch the about page HTML directly
      $.get subdomain.about_page_url, (response) => @local.html = response; save @local

    DIV style: {marginTop: 20},
      if !subdomain.about_page_url
        DIV null, 'No about page defined'
      else if !@local.embed_html_directly
        IFRAME src: subdomain.about_page_url, width: PAGE_WIDTH, style: {display: 'block', margin: 'auto'}
      else
        DIV className: 'embedded_about_html'


EmailNotificationSettings = ReactiveComponent
  displayName: 'EmailNotificationSettings'

  render : -> 
    data = @data()
    current_user = fetch('/current_user')

    # TODO: listing each followable and making it unfollowable
    DIV null,
      DashHeader name: 'Email Notification Settings'
      DIV style: {width: CONTENT_WIDTH, margin: '15px auto'}, 

        DIV null,
          INPUT 
            id: 'no_email_notifications'
            name: 'no_email_notifications'
            type: 'checkbox'
            defaultChecked: !current_user.no_email_notifications
            onChange: (e) => 
              current_user.no_email_notifications = !$('#no_email_notifications').is(':checked')
              save current_user
          LABEL htmlFor: 'no_email_notifications', 'Receive email notifications'

        if !current_user.no_email_notifications
          if _.flatten(_.values(data.follows)).length == 0
            DIV null, 'You\'re not currently receiving any email notifications'
          else
            DIV null,
              H1 style: {fontSize: 24, margin: '10px 0'}, "This is what you receive email notifications about:"

              for followable_type in ['Point', 'Proposal']
                if data.follows[followable_type].length > 0
                  DIV null,
                    H1 style: {fontSize: 18, margin: '10px 0'}, "#{followable_type}s"
                    for follow in data.follows[followable_type]
                      followable = fetch(follow)
                      DIV style: {margin: '20px 0'}, 
                        if followable_type == 'Point'
                          Point key: followable, rendered_as: 'under_review'
                        else 
                          BLOCKQUOTE null,
                            followable.name
                        BUTTON 
                          style: {fontSize: 18}
                          onClick: do(followable) => => 
                            followable.is_following = false
                            save followable
                            arest.serverFetch '/dashboard/email_notifications' # don't want to have to dirty this key whenever a point or proposal is updated
                          'unsubscribe'


Computer = ReactiveComponent
  # This doesn't actually render anything.  It just processes state
  # changes to current_user for CSRF and logging in and out.
  displayName: 'Computer'
  render : ->
    current_user = fetch('/current_user')
    if current_user.csrf
      arest.csrf(current_user.csrf)

    #console.log("Maybe we will publish: '#{@root.opinions_to_publish}' #{current_user.logged_in}")

    # Publish pending opinions if we can
    if @root.opinions_to_publish.length > 0

      remaining_opinions = []

      for opinion_key in @root.opinions_to_publish
        opinion = fetch(opinion_key)
        can_opine = permit('publish opinion', opinion.proposal)

        if can_opine > 0 && !opinion.published
          opinion.published = true
          save opinion
        else 
          remaining_opinions.push opinion_key

          # TODO: show some kind of prompt to user indicating that despite 
          #       creating an account, they still aren't permitted to publish 
          #       their opinion.
          # if can_opine == Permission.INSUFFICIENT_PRIVILEGES
          #   ...

      if remaining_opinions.length != @root.opinions_to_publish.length
        @root.opinions_to_publish = remaining_opinions
        save @root

    # users following an email invitation need to complete registration (name + password)
    if current_user.needs_to_set_password
      @root.auth_mode = 'register-after-invite'
      @root.auth_reason = 'complete registration'
      save @root

    SPAN null


Page = ReactiveComponent
  displayName: 'Page'
  mixins: [AccessControlled]

  render: ->

    avatars = fetch('/avatars')
    subdomain = fetch('/subdomain')

    if @root.auth_mode && @root.auth_mode != 'update'
      return Auth()

    if subdomain.name == 'homepage' && @root.page_name == 'homepage'
      SPAN null, ''
    else if !subdomain.name
      L
    else
      DIV style: {minWidth: PAGE_WIDTH, backgroundColor: 'white'}, 'data-authmode': @root.auth_mode, #authmode controls styling during authentication process
        if avatars.avatars
          STYLE type: 'text/css', id: 'b64-avatars', dangerouslySetInnerHTML: {__html: avatars.avatars}
        
        BrowserHacks()
        Header()
        DIV style : { minWidth: PAGE_WIDTH, minHeight: 200, zIndex: 2, margin: 'auto', \
                      marginLeft: if lefty then 0 },
          if @root.auth_mode || @root.page_name == 'edit_profile'
            Auth()

          else

            if !@accessGranted()
              SPAN null 
            else if @root.page_name.match(/(.+)\/edit/)
              EditProposal key: "/#{@root.page_name.match(/(.+)\/edit/)[1]}", fresh: false
            else
              switch @root.page_name
                when 'homepage'
                  Homepage key: @page.key
                when 'about'
                  About()
                when 'proposal/new'
                  EditProposal key: "new_proposal", fresh: true              
                when 'dashboard/email_notifications'
                  EmailNotificationSettings key: '/page/dashboard/email_notifications'
                when 'dashboard/assessment'
                  FactcheckDash key: "/page/dashboard/assessment"
                when 'dashboard/create_subdomain'
                  CreateSubdomain key: "/page/dashboard/create_subdomain"
                when 'dashboard/import_data'
                  ImportDataDash key: "/page/dashboard/import_data"
                when 'dashboard/moderate'
                  ModerationDash key: "/page/dashboard/moderate"
                when 'dashboard/application'
                  AppSettingsDash key: "/page/dashboard/application"
                when 'dashboard/roles'
                  SubdomainRoles key: "/page/dashboard/roles"
                else 
                  Proposal key: if @page.proposal then @page.proposal.key else @page

        Footer()

Root = ReactiveComponent
  displayName: 'Root'
  resetSelection: (e) ->
    if @root.selected_point
      window.writeToLog
        what: 'deselected a point'
        details:
          point: @root.selected_point

      @root.selected_point = null
      save @root


  render : -> 
    root = @data()

    ######
    # Handle application routing, derived from client state.
    query_parameters = Backbone.history.getQueryParameters()
    query_parameters = {}

    if @root.proposal_mode == 'results'
      query_parameters['results'] = true #the only query parameter we support now is ?results=true for proposal pages
    if @root.selected_point
      query_parameters['selected'] = @root.selected_point

    # Second, construct the proper url
    if root.page_name == 'homepage' 
      url = ''
    else if root.page_name == 'about'
      url = 'about'
    else #if we're rendering a proposal...
      url = window.app_router.toFragment root.page_name, query_parameters

    # Third, update the location bar if it's different
    if "#{window.location.pathname}#{window.location.search}" != "/#{url}"
      window.app_router.navigate url, {trigger : true}
    ####

    # Now let's render
    DIV onClick: @resetSelection,
      StateDash(),
      Page(key: "/page/#{root.page_name}"),
      Computer() # Doesn't actually render anything


# Displays warnings for some browsers
# Stores state about the current device. 
# Note that IE<9 users are redirected at
# an earlier point to an MS upgrade site. 
BrowserHacks = ReactiveComponent
  displayName: 'BrowserHacks'

  render : ->
    browser = fetch 'browser'
    if  browser.is_opera_mini #|| browser.is_android_browser
      DIV style: {backgroundColor: 'red', padding: '10px', textAlign: 'center', color: 'white', fontSize: 24}, 
        "This website does not work well with #{if browser.is_android_browser then 'the Android Browser' else 'Opera Mini'}. Please use "
        A href: "https://play.google.com/store/apps/details?id=com.android.chrome&hl=en", style: {color: 'white', textDecoration: 'underline'},
          'Chrome for Android' 
        ' if you experience difficulty. Thanks, and sorry for the inconvenience!'
    else 
      # Use third party script for detecting and warning users
      # of other outdated browsers. Sticking with
      # third party for now because of some complexities
      # in detecting some of these browser versions. In 
      # the future, probably want to extract the logic. 
      # "https://browser-update.org/update.html"
      SCRIPT type: 'text/javascript', src: '//browser-update.org/update.js'


  

# Fetch current user every 2 minutes so that if the user gets
# logged out (e.g. by server deploy after letting a browser window stay open), 
# their browser will accurately reflect reality. 
# Only do this if user is already logged in, so that we don't 
# accidently interfere with a login process.
# TODO: Remove this after we have true realtime updates
setInterval -> 
  current_user = fetch '/current_user'
  if current_user.logged_in
    arest.serverFetch('/current_user')
, 2 * 60 * 1000


# It is important that a user that just submitted a user picture see the picture
# on the results and in the header. However, this is a bit tricky because the avatars
# are cached on the server and the image is processed in a background task. 
# Therefore, we'll wait until the image is available and then make it available
# in the avatar cache.  
ensureCurrentUserAvatar = (attempts = 0) ->
  
  $.getJSON '/user_avatar_hack', (response) =>
    if response.b64_thumbnail          
      current_user = fetch '/current_user'
      $('head').append("<style type=\"text/css\">#avatar-#{current_user.id} { background-image: url('#{response.b64_thumbnail}');}</style>")
    
    else if attempts < 20
      # Ugly: wait a little while for offline avatar processing to complete, then refetch
      _.delay -> 
        ensureCurrentUserAvatar(attempts + 1)
      , 1000


##
# Backbone routing
# Note: not committed to backbone. Want to experiment with other routing techniques too.
window.root = null
Router = Backbone.Router.extend
  
  routes :
    "(/)" : "homepage"
    "about(/)" : "about"
    "edit_profile(/)" : "edit_profile"
    "proposal/new(/)" : "new_proposal"
    "proposal/:proposal/edit(/)": "edit_proposal"
    ":proposal(/)": "proposal"    
    "dashboard/:dash(/)": "dashboard"

  proposal : (slug, params) ->
    root = fetch('root')
    resetState(root)

    root.page_name = slug

    #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
    #      Right now activeREST doesn't allow wide consumption of a component's client state
    #      if its data is synced with the server. 


    root.proposal_mode = 'crafting'
    root.selected_point = null
    if params 
      root.proposal_mode = 'results' if params['results']
      root.selected_point = params['selected'] if params['selected']

    save root

    writeToLog
      what: 'loaded page',
      where: slug

  homepage : (params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = 'homepage'
    save root

    writeToLog
      what: 'loaded page',
      where: 'homepage'

  about : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'about'
    save root

    writeToLog
      what: 'loaded page',
      where: 'about'

  new_proposal : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'proposal/new'
    save root

  edit_proposal : (id, params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = "proposal/#{id}/edit"
    save root      

  dashboard : (dash, params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = "dashboard/#{dash}"    
    save root

  edit_profile : (params) -> 
    root = fetch('root')
    resetState(root)

    root.page_name = 'edit_profile'
    root.auth_mode = 'update'
    root.auth_reason = null

    save root


# Temporary method for handling resetting root state when switching between
# routes. Remove once we have a better activeREST answer. 
resetState = (root) ->
  root.auth_mode = null

  #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
  #      Right now activeREST doesn't allow wide consumption of a component's client state
  #      if its data is synced with the server. 
  root.proposal_mode = null    
  root.selected_point = null


# Handles router navigation for links so that a page reload doesn't happen
clickInternalLink = (event) ->
  href = $(event.currentTarget).attr('href')

  # Allow shift+click for new tabs, etc.
  if !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey
    event.preventDefault()
    # Instruct Backbone to trigger routing events
    window.app_router.navigate href, { trigger : true }
    return false

window.app_router = new Router()
window.on_ajax_error = () ->
  (root = fetch('root')).server_error = true
  save(root)
window.on_client_error = (e) ->
  save({ key: '/new/client_error', stack: JSON.stringify(e.stack) })

window.writeToLog = (entry) ->
  _.extend entry, 
    key: '/new/log'
    where: fetch('root').page_name

  save entry

# exports...
window.Point = Point
window.Comment = Comment
window.Avatar = Avatar
window.Button = Button
window.AutoGrowTextArea = AutoGrowTextArea
window.clickInternalLink = clickInternalLink
window.ProfileMenu = ProfileMenu
window.TechnologyByConsiderit = TechnologyByConsiderit
window.FBLike = FBLike
window.FBShare = FBShare
window.Tweet = Tweet

#######
# Start the app!

#static consider.it homepage doesn't want this stuff by default
if document.getElementById('content') 
  # add styles
  $('body').append("<style type='text/css'>#{styles}</style>")

  if 'ontouchend' in document #detect touch support
    React.initializeTouchEvents(true)

  Backbone.history.start {pushState: true}
  window.root = React.renderComponent(Root(), document.getElementById('content'))
