#////////////////////////////////////////////////////////////
# Exploratory reimplementation of considerit client in React
#////////////////////////////////////////////////////////////

# Ugliness in this prototype: 
#   - UI state and persisted data stored in same place (when saving, what to send to server?)
#   - Figuring out if the route was changed. Or more generally, knowing what the diff in state was
#     in the lifecycle methods now that we're not using @props or @state. Right now using a hack
#     (see use of _route_changed ActiveREST cache key)

####
# Make the DIV, SPAN, etc.
for el of React.DOM
  window[el.toUpperCase()] = React.DOM[el]

####
# Constants, especially used for layout styling
TRANSITION_SPEED = 700   # Speed of transition from results to crafting (and vice versa) 
BIGGEST_POSSIBLE_AVATAR_SIZE = 50

# layout constants
GRID_MINOR = 30
GRID_GUTTER = 18
GRID_MAJOR = GRID_MINOR + GRID_GUTTER #golden ratio
PAGE_WIDTH = 24 * GRID_MAJOR
CONTENT_WIDTH = PAGE_WIDTH - 4 * GRID_MAJOR
BODY_WIDTH = CONTENT_WIDTH - 8 * GRID_MAJOR - 2 * GRID_GUTTER
POINT_WIDTH = BODY_WIDTH / 2 - 20
POINT_CONTENT_WIDTH = POINT_WIDTH - 35 - GRID_GUTTER
HISTOGRAM_WIDTH = BODY_WIDTH    # Width of the slider / histogram base 
DECISION_BOARD_WIDTH = BODY_WIDTH + 4 # the four is for the border
REASONS_REGION_WIDTH = DECISION_BOARD_WIDTH + 2 * POINT_CONTENT_WIDTH + 4 * GRID_GUTTER + 4
MAX_HISTOGRAM_HEIGHT = 200
DESCRIPTION_WIDTH = BODY_WIDTH

# Colors
considerit_blue = '#2478CC'

cityclub_navy   = 'rgb(0,   68,  124)'
cityclub_green  = 'rgb(165, 206, 57)'
cityclub_blue   = 'rgb(0,   182, 236)'
cityclub_purple = 'rgb(154, 152, 203)'
cityclub_red    = 'rgb(241, 94,  94)'
#cityclub_orange: 
cityclub_beige  = 'rgb(241, 235, 211)'
cityclub_brown  = 'rgb(77,  76,  71)'
cream           = 'rgb(255, 254, 245)'
#cream = 'white'

##
# Helpers that should probably go elsewhere

capitalize = (string) -> string.charAt(0).toUpperCase() + string.substring(1)
L = loading_indicator = DIV null, 'Loading...'

# safari only respects -webkit-transform
crossbrowserTransformProperty = (props) -> _.extend props,
  '-webkit-transform' : props.transform
  '-ms-transform' : props.transform
  '-moz-transform' : props.transform


# Returns the top level Proposal component key. Components use this to grab data
# from its Proposal. This is a hack. Shadowing parent state would solve the problem.
# window.current_proposal = () ->
#         long_id = fetch('root')?.url.split('/')[1]
#         fetch('/page/' + long_id).proposal
getStanceSegment = (value) ->
  for i in [0..5]
    if value < stance_segment_boundaries[i + 1]
      return i
  return 6

userOpinion = (user_key) ->
  window.user_opinions[user_key]


_route_changed = false

togglePage = (proposal_mode, triggered_by) -> 
  $('.histogram_segment_pole').ensureInView
    offset_buffer: 150
    callback : -> 
      root = fetch('root')

      window.writeToLog
        what: 'toggle proposal mode'
        details: 
          from: root.proposal_mode
          to: proposal_mode
          triggered_by: triggered_by 

      root.proposal_mode = proposal_mode
      root.selected_point = null
      save root

      # Kludge for tracking when the page changes
      _route_changed = true
      _.delay -> 
        _route_changed = false
      , 1



stance_segment_boundaries = { 0 : -1, 1 : -.9999, 2 : -0.5, 3 : -0.05, 4 : 0.05, 5 : 0.5, 6 : .9999 } 

stance_names = 
  6 : 'Fully Support'
  0 : 'Fully Oppose'
  5 : 'Firmly Support'
  1 : 'Firmly Oppose'
  4 : 'Slightly Support'
  2 : 'Slightly Oppose'
  3 : 'Are Neutral'

##
# PageTransition mixin
# Helper for components that implement a page transition animation.
# Applies styles defined in the component that change
# depending on the route. 
#
# The styles will be added on every update and on component mount. 
# However, it will *animate* the styles only if the page has changed (_route_changed). 
# Otherwise it just directly applies the styles
PageTransition = 

  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) ->
    @applyStyles _route_changed

  applyStyles : (animate) ->
    duration = if animate then TRANSITION_SPEED else 0
    root = @root
    $el = $(@getDOMNode())


    # Each Component that implements this mixin can get triggered multiple times after a route change. 
    # So we're going to ensure that we apply styles only once for a given route change. 
    return if @transitioning == root.proposal_mode
    @transitioning = root.proposal_mode

    switch @name

      # The histogram will get transparent when moving to crafting page
      when 'histogram'
        opacity = if root.proposal_mode == 'crafting' then '0.2' else '1.0'
        $el.find('.histogram_bar').velocity {opacity: opacity}, {duration}

      # The position of the CommunityPoints will move to the wings on crafting, and 
      # be close together in results
      when 'communitypoints'

        if root.proposal_mode == 'crafting'
          offset_x = if @props.key == 'pros' then 0 else DECISION_BOARD_WIDTH
        else if root.proposal_mode == 'results'
          offset_x = DECISION_BOARD_WIDTH / 2

        $el.velocity { translateX: offset_x }, {duration}

      # The slider handle and mouth will change size and location when moving between crafting and results
      when 'slider'
        slider = @data('slider')

        direction = if slider.stance_segment >  3 then -1 else 1
        mouth_x      = if slider.stance_segment == 3 then  0 else -22

        handle_width = 22

        if root.proposal_mode == 'crafting'
          bubblemouth_style = { translateX: direction * mouth_x, translateY: 20, scaleX: direction * 1.5, scaleY: 1.5  }
          handle_style = { scale: 2.5 }
        else 
          bubblemouth_style = { translateX: direction * mouth_x, translateY: -4, scaleX: direction, scaleY: 1  }
          handle_style = { scale: 1 }

        $el.find('.bubblemouth').velocity bubblemouth_style, {duration}
        $el.find('.the_handle').velocity handle_style, {duration}

      # The decision board will have to expand for crafting and collapse into to the Give Opinion button in results
      when 'decisionboard'
        if root.proposal_mode == 'crafting'
          decision_board_style =
            translateX: 0
            translateY: 10
            width: DECISION_BOARD_WIDTH
            minHeight: 275

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.give_opinion_button').css 'visibility', 'hidden'
          _.delay => 
            #delay & check in case of quick switch between pages
            if root.proposal_mode == 'crafting'
              $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', ''
          , duration

        else 
          slider = @data('slider')
          slider_position = slider.clientX

          give_opinion_button_width = 200

          gutter = .1 * give_opinion_button_width
          opinion_region_x = -gutter + (DECISION_BOARD_WIDTH - give_opinion_button_width + 2 * gutter) * slider_position/HISTOGRAM_WIDTH

          decision_board_style =
            translateX: opinion_region_x
            translateY: -18
            width: give_opinion_button_width
            minHeight: 32
            marginTop: 0

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', 'none'
          _.delay => 
            #check in case of quick switch between pages
            if root.proposal_mode == 'results'
              $el.find('.give_opinion_button').css 'visibility', ''
          , duration  
      else
        throw "The #{@name} component does not define any styles to animate"

    _.delay => 
      @transitioning = null
    , duration


#####################
# React Components (needs to be updated)
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  displayName: 'Proposal'

  componentDidUpdate : ->
    $el = $(@getDOMNode())

    # Resizing the reasons region to solve a layout error when 
    # the height of the decision board (which is absolutely positioned) 
    # is taller than either of the wing point columns
    $el.find('.reasons_region').css {minHeight: $el.find('.opinion_region').height()} 

    # $el.find('.description_region').css
    #   top: $el.find('.proposal_heading').height() + 24


  renderDescriptionField : (field) ->
    DIV className: 'description_field', key: field.label,
      DIV className: 'field_heading', onClick: => 
        field.expanded = !field.expanded
        save(@local)
        if field.expanded 
          window.writeToLog
            what: 'expand proposal description'
            details: 
              description_type: field.label        
      ,
        SPAN className: "expand_arrow fa #{if field.expanded then 'fa-minus-circle' else 'fa-plus-circle'}" #, dangerouslySetInnerHTML: {__html: if field.expanded then '&#9660;' else '&#9658;'}
        SPAN className: 'field_name', field.label
      if field.expanded
        DIV className: 'field_body', dangerouslySetInnerHTML:{__html: field.html}

  renderDescriptionFieldGroup : (group) -> 
    DIV className: 'description_group', key: group.group,
      DIV className: 'description_group_name', 
        LABEL null, group.group
      for field in group.items
        @renderDescriptionField field

  ##
  # Make this thing!
  render : ->
    proposal = @proposal
    your_opinion = @data(proposal.your_opinion)
    included_points = your_opinion.point_inclusions
    current_user = @data('/current_user')

    description_region_style = {width: DESCRIPTION_WIDTH}

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in proposal.opinions
      window.user_opinions[opinion.user] = opinion

    proposer = @data(proposal.user)

    # New approach to Proposal description fields. 
    # Description fields are the expandable details that help people drill
    # into the proposal. They are very specific to the type of proposal (e.g. for
    # an LVG ballot measure, one of the fields might be "fiscal impact statement").  
    # We're now storing all these fields in proposal.description_fields
    # as a serialized JSON object of one of the following structures:
    #       [ {"label": "field one", "html": "<p>some details</p>"}, ... ] 
    #       [ {"group": "group name", "items": [ {"label": "field one", "html": "<p>some details</p>"}, ... ]}, ...]
    # If we choose to use this more flexible approach, we can migrate all the old 
    # data to this format, rename the column, and get rid of a bunch of columns on 
    # Proposal that will be made obsolete. 
    if !@local.description_fields
      # Deserialize the description fields. 
      # It would be nice if ActiveREST recognized that a field is a serialized data object!
      # This will fail for proposals that are not using the serialized JSON format; 
      # For now, we'll just catch the error and carry on 
      try 
        @local.description_fields = $.parseJSON(@data().description_fields)
        @local.expanded_field = null
      catch
        @local.description_fields = null


    color = @data('color')

    DIV className:'proposal', key:@props.long_id, 'data-page':@root.proposal_mode,

      StickyProposalHeading()

      if @root.auth_mode
        Auth()
      else 
        DIV null,
          #description
          DIV className:'description_region', style: description_region_style, 

            DIV className: 'proposal_details', dangerouslySetInnerHTML:{__html: proposal.description}

            if @local.description_fields
              DIV className: 'description_fields',
                for item in @local.description_fields
                  if item.group
                    @renderDescriptionFieldGroup item
                  else
                    @renderDescriptionField item

            if current_user.is_admin
              A style: {opacity: '.1'}, onClick: (-> window.app_router.navigate("#{proposal.key}/edit", {trigger: true})), 'Edit'
        
          #feelings
          DIV className:'feelings_region', style : { width: BODY_WIDTH },
            OpinionFilter()
            HistogramData()
            Histogram()

          #reasons
          DIV 
            className:'reasons_region'
            style : { width: REASONS_REGION_WIDTH },
              #community pros
              CommunityPoints { key: 'pros' }

              DecisionBoard()

              #community cons
              CommunityPoints { key: 'cons' }


StickyProposalHeading = ReactiveComponent
  displayName: 'StickyProposalHeading'

  componentDidMount : -> @initOrUpdateHeader()

  componentDidUpdate : -> @initOrUpdateHeader()

  initOrUpdateHeader : -> 
    $el = $(@getDOMNode())

    $header = $el.find('.proposal_heading.stickable')
    if $header.length > 0
      if @local.sticky_initialized
        $header.StickyElement('update')
      else 
        $header.StickyElement
          placeholder: $el.find('.proposal_heading.placeholder')[0]
          container: $el.parents('.proposal')
        @local.sticky_initialized = true
        save @local

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.find('.proposal_heading.stickable').StickyElement('destroy')

  mouseLeaveOtherCluster : (cluster) -> 
    if @local.show_cluster == cluster
      @local.show_cluster = null
      save(@local)

  render : ->
    proposal = @proposal
    color = @data('color')
    customer = @data('/customer')
    proposals = @data('/proposals')

    # If navigation bar is enabled, then we'll use a really short proposal name in the heading.
    # Otherwise we'll display the full question. This split doesn't come from
    # deep thought. Right now we'll just show the nav bar if the proposal belongs to a group
    use_navigation_bar = proposal.cluster && proposals
    
    DIV null, 
      if use_navigation_bar

        if proposals.clusters #don't want to error out if /proposals isn't loaded yet

          #extract the cluster this proposal belongs to
          this_proposal_cluster = _.findWhere proposals.clusters, {name: proposal.cluster}
          has_other_proposals_in_cluster = this_proposal_cluster && this_proposal_cluster.proposals.length > 1

          if !@local.next_proposal && has_other_proposals_in_cluster
            # the next proposal is the next proposal in the cluster, with 
            # preference for proposals the user has yet to submit an opinion for. 

            other_proposals_in_cluster = _.filter this_proposal_cluster.proposals, (prop) -> prop.id != proposal.id # remove this proposal from the list
            has_not_opined = _.filter other_proposals_in_cluster, (prop) => !prop.your_opinion || !@data(prop.your_opinion).published

            if has_not_opined.length > 0
              @local.next_proposal = _.sample has_not_opined
            else 
              @local.next_proposal = _.sample other_proposals_in_cluster
            save @local #save next_proposal so it doesn't change each rerender

        heading_height = 50
        DIV null,
          DIV className: 'proposal_heading placeholder', style: {height: heading_height} 
          DIV id: 'proposal_heading', className: 'proposal_heading stickable',  style : { height: heading_height, minWidth: PAGE_WIDTH, backgroundColor: color.proposal_header, textAlign: 'center' }, # minwidth is for width consistency when dropping into fixed sticky header
            # TODO: we need a way of knowing whether this subdomain has a homepage or not
            if customer.identifier == 'livingvotersguide'
              A
                className: 'homepage_link'
                onClick: (=> window.app_router.navigate("/", {trigger: true}))
                style: {position: 'absolute', display: 'inline-block', top: 10, left: 12},
                I className: 'fa fa-home', style: {fontSize: 28, color: 'white'}

            DIV className: 'current_proposal_cluster', proposal.cluster

            DIV className: 'proposal_navigation_menu_wrapper', style: {width: DESCRIPTION_WIDTH}, # set the width here so we can align it perfectly with the proposal description text
              DIV style: {width: PAGE_WIDTH}, # ...but let the stuff inside be big
                DIV 
                    className: 'proposal_navigation_menu'
                    onMouseEnter: (=> @local.dropped_down = true; save(@local))
                    onMouseLeave: (=> @local.dropped_down = false; save(@local))
                , 

                  DIV className: 'current_proposal', style: {backgroundColor: 'rgba(0,0,0,.2)'},
                    SPAN null,
                      "#{if proposal.designator && proposal.category then "#{proposal.category[0]}-#{proposal.designator} " else ''}#{proposal.name}?" 
                      I className: 'fa fa-caret-down', style: {paddingLeft: 8}

                  if @local.dropped_down
                    DIV className: 'proposal_navigation_dropdown', style: {width: 500, position: 'absolute', top: 38, paddingTop: 5},
                      DIV style: {backgroundColor: color.proposal_header, borderRadius: '4px'},
                        DIV style: {backgroundColor: 'rgba(0,0,0,.2)', padding: '14px 0', borderRadius: '4px'},
                          
                          if has_other_proposals_in_cluster
                            DIV null,
                              TABLE className: 'current_cluster', style: {width: '100%'}, 
                                TBODY null,
                                  for other_proposal in this_proposal_cluster.proposals
                                    TR href: "/#{other_proposal.long_id}", onClick: clickInternalLink, key: "tr/#{other_proposal.long_id}",
                                      TD style: {textAlign: 'left', paddingLeft: 20},
                                        A href: "/#{other_proposal.long_id}", onClick: clickInternalLink, style: {fontWeight: if other_proposal.id == proposal.id then 700 else 400},
                                          other_proposal.name
                                        
                                      TD style: {position: 'relative'},
                                        if !other_proposal.your_opinion || !@data(other_proposal.your_opinion).published
                                          SPAN style: {fontWeight: 400, color: 'rgb(205,205,205)', fontSize: 21}, '?'
                                        else
                                          # make a small slider summary
                                          opinion = @data(other_proposal.your_opinion)
                                          face_size = 20 # height/width of the summary slider bar
                                          eye_style = { width: 2, height: 2, borderRadius: '50%', backgroundColor: color.proposal_header, position: 'absolute', top: 6 }
                                          mouth_style = {fontSize: 12, color: color.proposal_header, left: face_size * .45, top: face_size * .28, position: 'absolute', transform: 'rotate(90deg)'}
                                          crossbrowserTransformProperty mouth_style
                                          if opinion.stance_segment < 3
                                            # frown!
                                            mouth = '('
                                          else if opinion.stance_segment == 3
                                            # confused!
                                            mouth = '|'
                                          else
                                            # pleased!
                                            mouth = ')'

                                          DIV style: {borderBottom: "1px solid white", width: 100, position: 'relative', top: 15},

                                            DIV {style: borderRadius: '50%', backgroundColor: 'white', width: face_size, height: face_size, position: 'absolute', top: -face_size / 2, marginLeft: -face_size / 2 , left: "#{100 * (-1 * opinion.stance + 1.0) / 2.0}%"},
                                              DIV style: _.extend {}, eye_style, {left: 6} # left eye
                                              DIV style: _.extend {}, eye_style, {left: face_size - 8} # right eye
                                              DIV style: mouth_style, mouth


                                      TD style: {paddingRight: 20}

                              DIV className: 'separator', style: {borderBottom: '1px dotted #dedede', width: '85%', margin: '28px auto 12px auto'}

                          DIV className: 'other_clusters', 
                            for cluster in proposals.clusters
                              if proposal.cluster != cluster.name && cluster.proposals.length > 0
                                do (cluster) =>
                                  DIV className: 'another_cluster', style: {padding: '0 50px', width: '100%', position: 'relative'}, onMouseEnter: (=> @local.show_cluster = cluster.name; save(@local)), onMouseLeave: (=> @mouseLeaveOtherCluster(cluster.name) ),
                                    SPAN style: {float: 'left', fontSize: 18, fontWeight: 400},
                                      cluster.name
                                    I className: 'fa fa-caret-right', style: {float: 'right'}
                                    DIV style: {clear: 'both'}

                                    if @local.show_cluster == cluster.name
                                      DIV style: {width: 300, backgroundColor: color.proposal_header, borderRadius: '4px', position: 'absolute', left: 498, top: -12},                                  
                                        UL className: 'other_proposal_list', style: {backgroundColor: 'rgba(0,0,0,.2)', borderRadius: '4px', padding: '8px 0' },
                                          for other_proposal in cluster.proposals
                                            LI style: {listStyle: 'none'}, key: "li/#{other_proposal.long_id}",
                                              A href: "/#{other_proposal.long_id}", onClick: clickInternalLink, style: {display: 'block', textAlign: 'left', padding: '2px 10px'},
                                                other_proposal.name
                        
                                    
                  if @local.next_proposal
                    DIV className: 'next_proposal', 
                      "Next: "
                      A onClick: (=> window.app_router.navigate("/#{@local.next_proposal.long_id}", {trigger: true})),
                        @local.next_proposal.name

      else 
        heading_style = { textAlign: 'center', minWidth: PAGE_WIDTH, backgroundColor: color.proposal_header, fontSize: 26, padding: '4px 90px' } # minwidth is for width consistency when dropping into fixed sticky header
        DIV null,
          DIV className: 'proposal_heading stickable',  style : heading_style,
            SPAN null,"#{if proposal.category && proposal.designator then proposal.category + ' ' + proposal.designator + ':' else ''}#{proposal.name}"

          DIV className: 'proposal_heading placeholder', style: heading_style,
            SPAN null,"#{if proposal.category && proposal.designator then proposal.category + ' ' + proposal.designator + ':' else ''}#{proposal.name}"




##
# HistogramData
# Doesn't render anything. Stores computed Histogram data. 
HistogramData = ReactiveComponent
  displayName: 'HistogramData'

  ##
  # Split up opinions into columns based on their stance.   
  render : ->
    # We only need to recompute this data if the distribution of stances has changed. 
    opinions = @data(@proposal).opinions || []
    last_computation_hash = JSON.stringify( _.map(opinions, (o) => @data(o.key).stance) )

    if @local.last_computation_hash != last_computation_hash

      ##
      # Size the avatars. Size of avatar shrinks proportional to 1/sqrt(num_opinions)
      avatar_size = Math.min BIGGEST_POSSIBLE_AVATAR_SIZE, 
        Math.floor(BIGGEST_POSSIBLE_AVATAR_SIZE / Math.sqrt( (opinions.length + 1) / 10 )  )

      # Calculate the number of columns in the histogram. But we want to ensure that there
      # are an _odd_ number of cols so that a neutral opinion falls into the exact 
      # center of the histogram. To ensure this, we'll manipulate avatar_size. 
      loop 
        columns_in_histogram = Math.floor(HISTOGRAM_WIDTH / avatar_size)
        break if columns_in_histogram % 2 == 1
        avatar_size -= 1

      columns = ([] for col in [0..columns_in_histogram-1])

      # Assign each Opinion to a column
      for opinion in opinions
        opinion = @data(opinion.key)
         
        round_method = if opinion.stance_segment < 3 then Math.floor else Math.ceil

        column = round_method (opinion.stance + 1) / 2.0 * (columns_in_histogram - 1)
        columns[column].push opinion

      # Spill out extremes into multiple columns. We'll cap the number of opinions
      # in a column to max_opinions_in_column. We'll keep the number of extreme columns
      # equal between supporters and opposers. 
      max_opinions_in_column = Math.floor MAX_HISTOGRAM_HEIGHT / avatar_size
      most_extreme_opinions = Math.max columns[0].length, columns[columns.length-1].length
      if most_extreme_opinions > max_opinions_in_column
        num_extreme_cols = Math.ceil most_extreme_opinions / max_opinions_in_column

        # split each extreme into num_extreme_cols. First supporters then opposers.
        for extreme, idx in [columns[0], columns[columns.length - 1]]
          for i in [0..num_extreme_cols - 2]
            if extreme.length > max_opinions_in_column
              opinions_for_new_col = extreme.splice(max_opinions_in_column, max_opinions_in_column)
            else
              opinions_for_new_col = []

            if idx == 0 
              columns.unshift opinions_for_new_col #add to beginning for supporters
            else 
              columns.push opinions_for_new_col #add to end for opposers

      columns.reverse() #we're going from 1 <=> -1 for supporters <=> opposers

      histogram_data = @data()
      histogram_data.columns = columns
      histogram_data.avatar_size = avatar_size
      @local.last_computation_hash = last_computation_hash

      save histogram_data
      save @local

    SPAN null #dummy DOM for React render 
  

##
# Histogram
Histogram = ReactiveComponent
  displayName : 'Histogram'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  onClickHistogram : (ev) ->
    if @root.proposal_mode == 'crafting'
      togglePage('results', 'click_histogram')

  onSelectSegment : (ev) ->
    if @root.proposal_mode == 'results'
      segment = $(ev.currentTarget).data('segment')
      hist = @data('histogram')

      selected_segment = hist.selected_segment

      # If clicking on already hard-selected segment, then we'll deselect. 
      if selected_segment == segment and selected_segment_isclicked
        segment = null

      click_select = ev.type == 'click' 

      #ignore mouseEnter and mouseLeave events if selection was via click
      return if selected_segment and selected_segment_isclicked and !click_select 

      hist.selected_segment = segment
      hist.selected_segment_isclicked = click_select and segment
      save(hist)
      ev.stopPropagation()

  render : ->
    selected_segment = @data('histogram').selected_segment
    users_to_highlight = @data('histogram').highlighted_users

    histogram_data = @data('histogramdata')
    columns = histogram_data.columns
    num_columns = columns.length
    avatar_size = histogram_data.avatar_size

    effective_histogram_width = num_columns * avatar_size + 2
    margin_adjustment = -(effective_histogram_width - HISTOGRAM_WIDTH) / 2 #- avatar_size / 4


    TABLE 
      className: 'histogram'
      onClick: @onClickHistogram
      # onMouseLeave: @onSelectSegment
      style: { width: effective_histogram_width, marginLeft: margin_adjustment }, 
        TBODY null,
          TR null, 
            TD key: 'supporters', className: "histogram_segment_pole supporters", 
              SPAN null, 'Supporters'

            for bar, idx in columns
              segment = if bar.length > 0 then bar[0].stance_segment else -1
              is_selected = selected_segment == segment

              TD 
                key: idx 
                className: "histogram_bar #{if is_selected then 'is_selected' else 'not_selected'}"
                style: {width: avatar_size, opacity: (if is_selected && !selected_segment? then '1' else '1'), minHeight: (if bar.length == 0 then 75 else 0)}
              ,
                for opinion in bar
                  user = opinion.user
                  Avatar 
                    tag: SPAN, 
                    key: user
                    user: user
                    hide_face: @root.proposal_mode == 'crafting'
                    hide_name: @root.proposal_mode == 'crafting'
                    'data-segment':segment
                    style:
                      height: avatar_size
                      width: avatar_size
                      opacity: if users_to_highlight && 
                        !_.contains(users_to_highlight, opinion.user) 
                        then '.15' 
                        else if selected_segment == null || is_selected 
                        then '1.0'
                        else '.15'

            TD key: 'opposers', className: "histogram_segment_pole opposers", 
              SPAN null, 'Opposers'

##
# Slider
# Manages the slider and the UI elements attached to it. 
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  # Kick off sliding 
  handleMouseDown: (e) -> 
    el = @getDOMNode()
    # Dragging has to start by dragging the slider handle
    return if !$(e.target).is('.the_handle')

    e.preventDefault()

    # Initiate dragging
    slider = @data('slider')
    slider.is_moving = true
    slider.offsetX = e.clientX or e.touches[0].clientX

    slider.startX = parseInt($(e.target)[0].style.left, 10) || 0
    save slider

    $(window).on "mousemove.slider", @handleMouseMove
    $(window).on "mouseup.slider", @handleMouseUp

  # Stop sliding
  handleMouseUp: (e) ->
    # Don't do anything if we're not actually dragging. We only hit this logic
    # if there is some delay in removing the event handlers.
    slider = @data 'slider'

    return if !slider.is_moving

    e.preventDefault()

    your_opinion = @data(@proposal.your_opinion)
    
    # Clicking on the slider handle should transition us between crafting <=> results. 
    # We should also transition to crafting when we've been dragging on the results page. 
    if slider.stance == your_opinion.stance || @root.proposal_mode == 'results'
      new_page = if @root.proposal_mode == 'results' then 'crafting' else 'results'
      togglePage new_page, 'click_slider'
      e.stopPropagation()

    # We save the slider's position to the server only on mouse-up.
    # This way you can drag it with good performance.
    if your_opinion.stance != slider.stance
      your_opinion.stance         = slider.stance
      your_opinion.stance_segment = slider.stance_segment
      save your_opinion
      window.writeToLog 
        what: 'move slider'
        details: {stance: slider.stance}

    # Turn off dragging
    slider.is_moving = false
    save slider

    $(window).off ".slider" # Remove event handlers

  # While sliding
  handleMouseMove: (e) ->
    e.preventDefault() # prevents text selection of surrounding elements

    slider = @data('slider')

    clientX = e.clientX or e.touches[0].clientX

    # Update position
    slider.clientX = slider.startX + clientX - slider.offsetX
    slider.clientX = 0 if slider.clientX < 0
    slider.clientX = @props.width if slider.clientX > @props.width
    slider.has_moved = true

    # convert position of handle to a slider value on [1, -1]
    slider.stance = -(2 * slider.clientX / @props.width - 1)
    slider.stance_segment = getStanceSegment slider.stance

    save slider


  render : ->
    slider = @data('slider')

    # Update the slider position when the server gets back to us
    your_opinion = @data(@proposal.your_opinion)

    if slider.stance != your_opinion.stance and !slider.is_moving
      slider.stance = your_opinion.stance
      slider.stance_segment = your_opinion.stance_segment
      slider.clientX = @props.width * (1 - slider.stance) / 2
      if your_opinion.stance
        slider.has_moved = true
      save(slider)


    page = @root.proposal_mode
    sticky = @data('decisionboard').sticky
    stance = slider.stance
    segment = slider.stance_segment

    # Can't be dynamically set b/c of integration with asset fingerprinting. 
    # This is also why this file is ERB.
    bubblemouth_srcs = 
      neutral : {crafting: "<%= asset_path 'bubblemouth_neutral-crafting.png' %>", results: "<%= asset_path 'bubblemouth_neutral-results.png' %>"}
      other : {crafting: "<%= asset_path 'bubblemouth-crafting.png' %>", results: "<%= asset_path 'bubblemouth-results.png' %>"}
    
    bubblemouth_src = if segment == 3 then bubblemouth_srcs['neutral'][page] else bubblemouth_srcs['other'][page]

    face_left_eye_style = 
      transform: 
        if false && segment in [0, 6] 
        then 'scale(.9, .8)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_right_eye_style = 
      transform: 
        if false && segment in [0, 6] 
        then 'scale(1.1, 1.2)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_mouth_style = 
      transform: 
        "scale(#{.4 + .3 * Math.abs(stance) }, #{.08 + .4 * stance}) 
         translate(0, #{-2 - 5 * Math.abs(stance)}px) 
         rotate(45deg) 
         skew(#{if segment in [0,6] then '10deg' else '0deg'})"

    crossbrowserTransformProperty sty for sty in [
      face_left_eye_style, face_right_eye_style, face_mouth_style]

    # Keep feedback centered over handle, but keep within the bounds of the slider region 
    # when the slider is in an extreme position. 
    feedback_left = @props.width * -(stance-1) / 2.0 
    if sticky 
      feedback_width = if slider.has_moved then 190 else 400
      if feedback_left > @props.width / 2
        feedback_left = Math.min(@props.width - feedback_width/2 + 35, feedback_left)
      else if feedback_left < @props.width / 2
        feedback_left = Math.max(feedback_width/2 - 35, feedback_left)
    else
      feedback_width = 450

    slider_feedback_style = 
      visibility: 'visible'
      left: feedback_left
      marginLeft: -feedback_width / 2
      width: feedback_width
      fontSize: if sticky then '18px' else '29px'
      top: if sticky then '-65px' else '-80px'

    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point =  selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)

    slider_base_style = {width: @props.width}
    handle_style = {left: slider.clientX}
    bubblemouth_style = {left: slider.clientX}

    if selected_point
      handle_style.backgroundColor = "#ccc"
      handle_style.boxShadow = "0px 1px 0px #aaa"
      slider_base_style.backgroundColor = "#ddd"
      bubblemouth_style.visibility = 'hidden' # TODO: use grayscale filter when !selected_wing_point instead of hidding

    DIV className: 'slider', style : { left: - (@props.width - DECISION_BOARD_WIDTH) / 2 },
      DIV className:'slider_base', style : slider_base_style, 
        DIV 
          className:'slider_feedback'
          style: slider_feedback_style
        , if !slider.has_moved then 'Give Your Overall Opinion' else "You #{stance_names[segment]}"

        DIV className: 'the_handle', style: handle_style, onMouseUp: @handleMouseUp, onMouseDown: @handleMouseDown, onTouchStart: @handleMouseDown, onTouchMove: @handleMouseMove, onTouchEnd: @handleMouseUp, onTouchCancel: @handleMouseUp,
          if page == 'crafting'
            DIV className: 'face',            
              DIV className: 'face_mouth face_part', style: face_mouth_style
              DIV className: 'face_left_eye face_eye face_part', style: face_left_eye_style
              DIV className: 'face_right_eye face_eye face_part', style: face_right_eye_style
          # DIV className: 'drag_arrow right', '>' if page == 'crafting' && !slider.has_moved
          # DIV className: 'drag_arrow left', '<' if page == 'crafting' && !slider.has_moved

        IMG className:'bubblemouth', src: bubblemouth_src, style: bubblemouth_style
    

##
# OpinionFilter
# Filters whose opinions are displayed
OpinionFilter = ReactiveComponent
  displayName: 'OpinionFilter'

  onSelectSegment : (segment) ->
    hist = @data('histogram')
    if !segment? || hist.selected_segment == segment
      # Deselect
      hist.selected_segment = null
      hist.selected_segment_isclicked = null
    else
      # Select
      hist.selected_segment = segment
      hist.selected_segment_isclicked = true

      window.writeToLog
        what: 'filter results by segment'
        details: 
          segment: segment


    save hist


  render : ->
    hist = @data('histogram')

    # Remove filter when on crafting page
    if @root.proposal_mode == 'crafting'
      hist.selected_segment = null
      hist.selected_segment_isclicked = null

    filter_options = ['show all opinions',
        'only full opposers',
        'only firm opposers',
        'only slight opposers',
        'only neutrals',
        'only slight supporters',
        'only firm supporters',
        'only full supporters']

    DIV className: 'opinion_filter_region',
      for phrase, i in filter_options

        # Shift i by 1, and start with null
        i = i-1
        if i == -1
          i = null

        c = "filter_option"
        if hist.selected_segment == i
          c = c + ' selected'

        # I had to make this wrapper to make a new context for i
        wrapper = (i) => (=> @onSelectSegment(i))
        A key: "segment-#{i}", className: c, onClick: wrapper(i), phrase


##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render : ->
    root = @root
    current_user = @data('/current_user')
    
    your_opinion = @data(@proposal.your_opinion)
    published = your_opinion.published

    selected_point = @root.selected_point && root.proposal_mode == 'crafting'
    selected_wing_point = selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)
    
    opinion_region_style = {width: DECISION_BOARD_WIDTH}
    decision_board_style = {}
    if selected_wing_point
      decision_board_style.filter = 'grayscale(1)'
      decision_board_style['-webkit-filter'] = 'grayscale(1)'
      decision_board_style.opacity = '.4'
    else if selected_point
      decision_board_style.borderColor = "#ccc"

    DIV className:'opinion_region focal_wrapper', style: opinion_region_style,
      Slider
        width: HISTOGRAM_WIDTH

      DIV 
        className:'decision_board_body'
        style: decision_board_style
        onClick: => if root.proposal_mode == 'results' then togglePage('crafting', 'give_opinion_button')
      ,

        DIV null, 
          # only shown during crafting, but needs to be present always for animation
          DIV className: 'your_points',
            # your pros
            YourPoints { key: 'your_pro_points', valence: 'pros' }

            # your cons
            YourPoints { key: 'your_con_points', valence: 'cons' }

          # only shown during results, but needs to be present always for animation
          A 
            className:'give_opinion_button primary_button'
          , if published then 'Update your Opinion' else 'Give your Opinion'

      DIV className: 'decision_board_footer', style: decision_board_style, 
        DIV 
          className:'save_opinion_button primary_button'
          onClick: @saveYourOpinion
        , if published then 'See the results' else 'Save your opinion and see results'

        if root.proposal_mode == 'crafting'
          A className:'follow_proposal',
            INPUT
              type:      'checkbox'
              id:        "follow_proposal"
              name:      "follow_proposal"
              checked:   @proposal.is_following
              onChange: =>
                @proposal.is_following = !@proposal.is_following
                save @proposal
            LABEL htmlFor: "follow_proposal", title:'We\'ll send periodic email notifications summarizing activity on the proposal, as well as alerts about new pro and con points. You can easily unsubscribe later.', 'Notify me about new activity'

        if !published
          A 
            className:'cancel_opinion_button primary_cancel_button'
            onClick: (=> togglePage('results', 'cancel_button'))
          , 'or just skip to the results'  


  componentDidMount : ->
    @setStickyHeader()

    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = @data(@proposal.your_opinion)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)

            window.writeToLog
              what: 'included point'
              details: 
                point: ui.draggable.parent().data('id')

          $el.removeClass "user_is_hovering_on_a_drop_target"
      out : (ev, ui) => 
        $el.removeClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')
      over : (ev, ui) => 
        $el.addClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.StickyElement('destroy')

  componentDidUpdate : -> 
    $el = $(@getDOMNode())    
    root = @data('root')

    # hack to get around a problem where the browser's remembered scroll position messes
    # up the sticky location after initialization
    if !@initial_position_fixed
      $el.StickyElement('fix_initial_position')
      @initial_position_fixed = true
    else if root.proposal_mode == 'results' #fix problem where it would stay sticky moving to results page
      $el.StickyElement('update')

  setStickyHeader : ->
    $el = $(@getDOMNode())

    slider_region_height =  115 #$el.find('.slider .the_handle').outerHeight() + $el.find('.slider .slider_feedback').outerHeight() + 15 + 20 #15 is bubblemouth

    $el.StickyElement
      container: $('.reasons_region')
      top_offset: $('.proposal_heading').outerHeight() + slider_region_height
      bottom_offset: 20
      unsticks: =>
        d = @data()
        d.sticky = false
        save(d)
      sticks: =>
        d = @data()
        d.sticky = true
        save(d)
      conditional: => 
        # Text input is bad on iOS when nested in a fixed position element. So if the user
        # is trying to edit text, we'll shut off the sticky decisionboard.
        # TODO/BUG: this is not detecting text input when editing a point, or for editing a comment. 
        ios_fix = !@data('browser').is_iOS || (!@data('your_pro_points').adding_new_point && !@data('your_con_points').adding_new_point)

        @root.proposal_mode == 'crafting' && ios_fix 

  # When user clicks the big bold button at the bottom of the crafting page
  saveYourOpinion : -> 
    your_opinion = @data (@proposal.your_opinion)
    if @data('/current_user').logged_in
      your_opinion.published = true
      save (your_opinion)
      togglePage('results', 'save_button')
    else
      @root.auth_mode = 'register'
      #we'll need to publish this opinion after auth is completed
      @root.opinions_to_publish.push(@proposal.your_opinion)
      save(@root)

##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  handleAddPointBegin : ->
    if @data('browser').is_iOS
      # Text input is bad on iOS when nested in a fixed position element. So if the user
      # is trying to edit text, we'll shut off the sticky decisionboard.
      $(window).scrollTop $('.feelings_region').offset().top

    your_points = @data()
    your_points.adding_new_point = true
    save your_points

    writeToLog
      what: 'click new point'

  render : ->
    root = @data('root')
    included_points = @data(@proposal.your_opinion).point_inclusions
    left_or_right = if @props.valence == 'pros' then 'left' else 'right'

    your_points = @data @props.key,
      editing_points : []
      adding_new_point : false

    DIV 
      className:"points_on_decision_board #{@props.valence}_on_decision_board"
      style: { width: POINT_WIDTH }
    ,
      DIV className:'points_heading_label',
        "Give Your #{capitalize(@props.valence)}"

      UL null,
        for point in included_points
          if @data(point).is_pro == (@props.valence == 'pros')
            if point in your_points.editing_points
              EditPoint { key: point, fresh: false, valence: @props.valence, your_points_key: @props.key }
            else
              Point { key: point, location_class: 'decision_board_point', your_points_key: @props.key }

        DIV className:'add_point_drop_target',
          DIV className: "drop_target_circle_#{left_or_right}"
          IMG className:'drop_target', src: "<%= asset_path 'drop_target.png' %>"
          SPAN className:'drop_prompt',
            #"Drag #{@props.valence} points from the #{if @props.valence == 'pro' then 'left' else 'right'} that resonate with you."
            "Drag a #{capitalize(if @props.valence=='pros' then 'pro' else 'con')} from the #{left_or_right}"


        if !your_points.adding_new_point
          DIV className:'newpoint_prompt',
            SPAN className:'qualifier', 
              'or '
            SPAN className:'newpoint_bullet', dangerouslySetInnerHTML:{__html: '&bull;'}
            A className:'newpoint_link', 'data-action':'write-point', onClick: @handleAddPointBegin,
            "Write a new #{capitalize(if @props.valence == 'pros' then 'pro' else 'con')}"
        else
          EditPoint { key: "new_point_#{@props.valence}", fresh: true, valence: @props.valence, your_points_key: @props.key }



##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting
  render : ->
    selected_segment = @data('histogram').selected_segment

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key
    pro_is_selected = @root.selected_point and @data(@root.selected_point).is_pro

    # TODO: The minheight below is not a principled or complete solution to two sizing issues: 
    #           1) resizing the reasons region when the height of the decision board 
    #              (which is absolutely positioned) grows taller the wing points
    #           2) when filtering the points on result page to a segment without many inclusions,
    #              the document height can jarringly fluctuate
    DIV
      className: "points_by_community #{@props.key}_by_community"
      style:
        width: POINT_CONTENT_WIDTH
        minHeight: (if @proposal.points.length > 4 then jQuery(window).height() else 400)
        zIndex: if pro_is_selected and @props.key == 'pros'
                  '6'
    ,
      DIV className:'points_heading_label',
        if @data('root').proposal_mode == 'results' then "Top #{label}" else "Others' #{label}"
        P className:'points_segment_label', style: {visibility: if selected_segment == null then 'hidden' else 'visible'},
          if selected_segment == null then '-' else "for those who #{stance_names[selected_segment]}"          

      UL null,
        if points.length > 0
          for point in points
            Point
              key: point.key,
              is_new: Date.parse(point.created_at) > newpoint_threshold
              location_class : 'community_point'
        else
          LI className: 'empty_point', "No #{label} listed"

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @proposal.points || []
    newpoint_threshold = 
      (_.sortBy points, (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = @data('root').proposal_mode == 'results'
    selected_segment = @data('histogram').selected_segment
    included_points = @data(@proposal.your_opinion).point_inclusions
    points = @proposal.points
    opinions = @proposal.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_segment?
      # If there is a histogram segment selected, we'll have to filter down 
      # to the points that users in this segment think are important, and 
      # order them by resonance to those users. I'm doing this quite inefficiently.
      point_inclusions_per_point_for_segment = {} # map of points to including users
      _.each opinions, (opinion) =>
        if opinion.stance_segment == selected_segment && opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point_for_segment)
              point_inclusions_per_point_for_segment[point] = 1
            else
              point_inclusions_per_point_for_segment[point] += 1

      points = 
        _.filter points, (pnt) -> pnt.key of point_inclusions_per_point_for_segment
      points = 
        _.sortBy points, (pnt) -> -point_inclusions_per_point_for_segment[pnt.key]
    else
      # Default sort order
      points = 
        _.sortBy points, (pnt) => - if is_results then pnt.score else pnt.last_inclusion

    points





##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  render : ->
    point = @data()

    is_selected = @root.selected_point == @props.key

    selected_segment = @data('histogram').selected_segment
    author_opinion = @data(userOpinion(point.user))
    current_user = @data('/current_user')

    point_content_style = { width: POINT_CONTENT_WIDTH }
    if is_selected
      _.extend point_content_style,
        border: "3px solid #{considerit_blue}"
        left: -3
        top: -3
        width: point_content_style.width + 6
        backgroundColor: 'white'
        marginBottom: 2

    if is_selected and @props.location_class == 'decision_board_point'
      _.extend point_content_style,
        padding: 8
        borderRadius: 8
        marginTop: -8
        marginLeft: -8
        width: point_content_style.width + 16

    LI
      className: "point closed_point #{@props.location_class}
        #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
      onClick: @selectPoint
    ,
    
      if @props.location_class == 'community_point' && @props.is_new
        @renderNewIndicator()

      DIV className:'includers', onMouseEnter: @highlightIncluders, onMouseLeave: @unHighlightIncluders, 
        if @props.location_class == 'community_point'
          @renderIncluders()

        if !selected_segment || ( author_opinion && author_opinion.stance_segment == selected_segment )
          Avatar tag: SPAN, key: point.user, className:"point_author_avatar", hide_face: point.hide_name

      DIV className:'point_content', style : point_content_style,
        if @props.location_class == 'community_point' or is_selected
          IMG
            className: 'community_point_mouth'
            src: if is_selected then "<%= asset_path 'community_point_mouth_selected.png' %>" else "<%= asset_path 'community_point_mouth.png' %>"

        DIV className:'point_nutshell',
          point.nutshell
          if point.text
            if is_selected or
              (point.nutshell.length + point.text.length) < 210
                # Split the point details into paragraphs
                paragraphs = point.text.split(/(\r?\n|<br>|<br\/>|<br \/>|<p>)/g)
                DIV className: 'point_details',
                  for para in paragraphs
                    P null, para
            else
              SPAN className: 'point_details_tease',
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text() + "... [more]"

      if current_user.user == point.user && @props.location_class == 'decision_board_point'
        DIV null,
          # Should we only allow editing of a point before it is published?
          # Is an author allowed to edit a point after someone else has included it?
          A className: 'edit_point', onClick: (=> points = @data(@props.your_points_key); points.editing_points.push(@props.key); save(points)), 
            SPAN null, 'edit'

          # Allow the point author to delete this point before it is published.
          # After it gets published, however, it can influence other people, so the author shouldn't be able to delete.
          # Later they can just remove it from their list if they don't believe it anymore. 
          if point.includers.length == 0 || (point.includers.length == 1 && point.includers[0] == current_user.user)
            A className: 'delete_point', onClick: @deletePoint,
              SPAN null, 'delete'

      if is_selected
        point_included = _.contains(@data(@proposal.your_opinion).point_inclusions, point.key)
        Discussion
          key:"/comments/#{point.id}"
          is_pro: point.is_pro
          in_wings: @root.proposal_mode == 'crafting' and not point_included

  componentDidMount : ->
    @setDraggability()

  componentDidUpdate : -> 
    @setDraggability()

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page


    disable = @data('root').proposal_mode == 'results'

    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.location_class == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = @data(@proposal.your_opinion)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, @props.key
          save(your_opinion)
          window.writeToLog
            what: 'removed point'
            details: 
              point: @props.key

        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable


  selectPoint: (e) ->
    e.stopPropagation()
    if @root.selected_point == @props.key # deselect
      @root.selected_point = null
      what = 'deselected a point'
    else
      what = 'selected a point'
      @root.selected_point = @props.key

    save @root

    window.writeToLog
      what: what
      details: 
        point: @props.key


  deletePoint : -> 
    destroy @props.key

  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  highlightIncluders : -> 
    if @data('root').proposal_mode == 'results'
      includers = @data().includers
      point = @data()

      # For point authors who chose not to sign their points, remove them from 
      # the users to highlight. This is particularly important if the author 
      # is the only one who "included" the point. Then it is very eash for 
      # anyone to discover who wrote this point. 
      if point.hide_name
        includers = _.without includers, point.user
      hist = @data('histogram')
      if hist.highlighted_users != includers
        hist.highlighted_users = includers
        save(hist)

  unHighlightIncluders : -> 
    if @data('root').proposal_mode == 'results'
      hist = @data('histogram')
      hist.highlighted_users = null
      save(hist)


  buildIncluders : -> 
    point = @data()
    to_remove = [point.user]

    # only show includers from this stance segment if a segment is selected
    selected_segment = @data('histogram').selected_segment
    if selected_segment?
      for includer in point.includers
        stance_segment = @data(userOpinion(includer)).stance_segment

        if stance_segment && stance_segment != selected_segment
          to_remove.push(includer)

    _.difference point.includers, to_remove

        
  renderIncluders : ->

    if @data().includers

      includers = @buildIncluders()

      s = #includers_style
        rows: 8
        dx: 2
        dy: 5
        col_gap: 8
        side_offset: 32 + 14 + 1

      # Now we'll go through the list from back to front
      i = includers.length

      for includer in includers
        i -= 1
        curr_column = Math.floor(i / s.rows)
        side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
        top_offset = (i % s.rows) * s.dy + 4
        left_right = if @data().is_pro then 'left' else 'right'
        style = { top: top_offset }
        style[left_right] = -side_offset

        # Finally draw the guys
        Avatar
          key: includer
          tag: SPAN
          className: "point_includer_avatar"
          style: style

  renderNewIndicator : ->
    if @data().includers
      side_offset = 48
      left_right = if @data().is_pro then 'left' else 'right'
      style = 
        position: 'absolute'
        color: 'rgb(255,22,3)'
        fontSize: '11px'
        top: -14
        #backgroundColor: 'white'
        zIndex: 5
        fontVariant: 'small-caps'
        fontWeight: 'bold'

      style[left_right] = "#{-side_offset}"
      SPAN {style: style}, '-new-'



Discussion = ReactiveComponent
  displayName: 'Discussion'

  render : -> 
    logged_in = fetch('/current_user').logged_in
    
    discussion_style =
      width: DECISION_BOARD_WIDTH
      border: "3px solid #{considerit_blue}"
      position: 'absolute'
      zIndex: 100
      padding: '20px 40px'
      borderRadius: 16
      backgroundColor: 'white'

    bubble_mouth_style =
      position: 'absolute'
      top: 14
      width: 27
      height: 63

    # Reconfigure discussion board position
    side = if @props.is_pro then 'left' else 'right'
    if @props.in_wings
      discussion_style[side] = 215
      discussion_style['top'] = 44
    else
      discussion_style[side] = if @props.is_pro then -30 else -23
      discussion_style['marginTop'] = 13

    # Reconfigure bubble mouth position
    if @props.in_wings
      bubble_mouth_style.right = if @props.is_pro then undefined else -27
      bubble_mouth_style.left  = if @props.is_pro then -27       else undefined
    else
      trans_func = 'rotate(270deg)'
      if not @props.is_pro
        trans_func += ' scaleY(-1)'

      _.extend bubble_mouth_style,
        left: if @props.is_pro then 100 else 335
        top: -45
        transform:            trans_func
        '-ms-transform':      trans_func
        '-moz-transform':     trans_func
        '-webkit-transform':  trans_func
        '-o-transform':       trans_func

    DIV style: discussion_style, onClick: ((e) -> e.stopPropagation()),
      IMG
        src: "<%= asset_path 'bubblemouth-discussions.png' %>"
        className: if @props.is_pro then 'flipped' else ''
        style: bubble_mouth_style

      H1
        style:
          textAlign: 'center'
          fontSize: 41
          color: considerit_blue
          marginBottom: 5
        'Discuss this Point'
      
      DIV className: 'comments',
        for comment in @discussion.comments
          DIV style: {marginTop: 45, minHeight: 60},

            # Comment author name
            DIV
              style:
                position: 'absolute'
                marginTop: -25
                fontWeight: 'bold'
                color: '#666'
              fetch(comment.user).name + ':'

            # Comment author icon
            Avatar
              style:
                position: 'absolute'
                width: 50
                height: 50
              tag: DIV
              key: comment.user
              hide_name: true

            # Comment body
            DIV
              style:
                marginLeft: 60
                wordWrap: 'break-word'
              comment.body

      # Write a new comment
      if logged_in
        DIV style: {marginTop: 45},

          # Comment author name
          DIV
            style:
              position: 'absolute'
              marginTop: -25
              fontWeight: 'bold'
              color: '#666'
            (fetch('/current_user').name or 'You') + ':'

          # Icon
          Avatar
            style:
              position: 'absolute'
              width: 50
              height: 50
              backgroundColor: if not logged_in then 'transparent'
              border:          if not logged_in then '1px dashed grey'

            tag: DIV
            key: fetch('/current_user').user
            hide_name: true

          if not logged_in
            SPAN
              onClick: =>
                @root.auth_mode = 'register'
                save(@root)
              style:
                position: 'absolute'
                margin: '14px 0 0 70px'
                textDecoration: 'underline'
                color: cityclub_navy
               'Log in to write a comment'


          AutoGrowTextArea
            className: 'new_comment'
            placeholder: (logged_in and 'Write a new comment') or ''
            disabled: not logged_in
            onChange: (e) => @local.new_comment = e.target.value; save(@local)
            style:
              marginLeft: 60
              width: 390
              height: 60
              lineHeight: 1.4
              fontSize: 16
              border: if not logged_in then 'dashed 1px'

          DIV style: {textAlign: 'right'},
            DIV
              style:
                backgroundColor: considerit_blue
                borderRadius: 8
                color: 'white'
                width: 138
                padding: '3px 10px'
                fontWeight: 600
                textAlign: 'center'
                marginLeft: 314
              onClick: (e) =>
                e.stopPropagation()
                console.log('Gonna add comment', @local.new_comment)
              'Save comment'

##
# EditPoint
# Form for editing or creating a point. Used by NewPoint component & when someone
# edits their point. 
EditPoint = ReactiveComponent
  displayName: 'EditPoint'

  render : ->
    @local = @data @local_key,
      sign_name : if @props.fresh then true else !@data().hide_name
      add_details : false

    DIV className:'newpoint_form',
      INPUT id:'is_pro', name: 'is_pro', type: 'hidden', value: "#{@props.valence == 'pros'}"
      LABEL htmlFor:'nutshell', 'Your point'
      CharacterCountTextInput 
        id:'nutshell'
        className:'newpoint_nutshell'
        maxLength:140
        name:'nutshell'
        pattern:'^.{3,}'
        placeholder:'Make this summary succinct.'
        required:'required'
        defaultValue: if @props.fresh then null else @data().nutshell

      
      DIV null,
        A className: 'add_details', onClick: @handleToggleDetails, title: 'Provide background and/or back your point up with evidence.',
          I className: if @local.add_details then 'fa-caret-down fa' else 'fa-caret-right fa'
          SPAN null, 'Expand on your point'

        if @local.add_details
          DIV null, 
            AutoGrowTextArea 
              id:'text'
              className:'newpoint_description'
              name:'text'
              placeholder:'Provide background and/or back your point up with evidence.'
              required:'required'
              min_height: 170
              defaultValue: if @props.fresh then null else @data().text


      DIV className:'newpoint_hide_name',
        INPUT
          className: 'newpoint-anonymous'
          type:      'checkbox'
          id:        "sign_name-#{@props.valence}"
          name:      "sign_name-#{@props.valence}"
          checked:   @local.sign_name
          onChange: =>
            @local.sign_name = !@local.sign_name
            save(@local)
        LABEL htmlFor: "sign_name-#{@props.valence}", title:'Signing your name lends your point more weight with other participants.', 'Sign your name'
      
      DIV className:'newpoint-submit',
        INPUT className:'button primary_button', action:'submit-point', type:'submit', value:'Done', onClick: @savePoint

        A className:'newpoint-cancel primary_cancel_button', onClick: @handleAddPointCancel,
          'cancel'  

  componentDidMount : ->
    $el = $(@getDOMNode())
    $el.find('#nutshell').focus()
    $el.find('.newpoint-cancel').ensureInView {scroll: false, position: 'bottom'}

  handleToggleDetails : (ev) ->
    @local.add_details = !@local.add_details
    save(@local)

  done : ->
    your_points = @data @props.your_points_key
    if @props.fresh
      your_points.adding_new_point = false
    else
      your_points.editing_points = _.without your_points.editing_points, @props.key
    save your_points

  savePoint : (ev) ->
    $form = $(@getDOMNode())
    root = @data('root')

    nutshell = $form.find('#nutshell').val()
    text = $form.find('#text').val()
    hide_name = !$form.find("#sign_name-#{@props.valence}").is(':checked')

    if !@props.fresh
      # If we're updating an existing point, we just have to update
      # some of the fields from the form
      point = @data()
      point.nutshell = nutshell
      point.text = text
      point.hide_name = hide_name
    else
      current_user = @data('/current_user').user
      point =
        key : '/new/point'
        is_pro : @props.valence == 'pros'
        user : current_user
        comment_count : 0
        includers : [current_user]
        proposal : @proposal.key
        nutshell : nutshell
        text : text
        hide_name : hide_name

    save point

    @done()

    # This is a kludge cause activerest sucks for pre-rendering
    # changes before the server returns them
    @data(@proposal.your_opinion).point_inclusions.push(point.key)
    re_render([@proposal.your_opinion])

  handleAddPointCancel : (ev) -> @done()


##
# Avatar
# Displays a user's avatar
# Supports straight up img src, or using the CSS-embedded b64 for each user
Avatar = ReactiveComponent
  has_multiple_instances_with_same_key: true
  displayName: 'Avatar'
  
  render : ->
    user = @data()

    @local = @data @local_key,
      show_details : false

    className = "avatar #{if @props.className then @props.className else ''}"

    id = if @props.hide_face then "avatar-hidden" else "avatar-#{user.key.split('/')[2]}"

    if @props.img_style && user.key != -1
      avatar_file_name = user.avatar_file_name

      console.log("Mike hasn't made this avatar's image work yet!  Fix the file line below:")
      if avatar_file_name
        filename = "/system/avatars/#{@props.key}/#{@props.img_style}/#{avatar_file_name}"

    attrs =
      className: className
      id: id
      'data-id': @props.key
      onMouseEnter: @showDetails
      onMouseLeave: @hideDetails

    attrs.src = filename if filename

    @transferPropsTo @props.tag attrs

  getDefaultProps : ->
    key: '/user/-1' # defaults to anonymous user
    tag: IMG
    img_style: null #null defaults to the css-based b64 embedded images
    hide_face: false

  componentWillUpdate : -> 
    if @local.show_details && !@props.hide_name
      @insertUserName()

  insertUserName : ->
    $el = $(@getDOMNode())
    pos = $el.offset()
    display_name = if @props.hide_face then 'Anonymous' else @data().name
    $name = $("<span class='hover_avatar_name'>#{display_name}</span>")
    $('body').append $name   # ugly!

    # if we're at the top of the page, stick the name below
    direction = if $el.offset().top < 50 then 1 else -1
    $name.css 
      left: pos.left - $name.width() / 2 + $el.width()/2
      top: pos.top + direction * $name.height()

  showDetails : (ev) -> 
    @local.show_details = true
    save(@local)

  hideDetails : (ev) -> 
    $('.hover_avatar_name').remove()
    @local.show_details = false
    save(@local)




AutoGrowTextArea = ReactiveComponent
  displayName: 'AutoGrowTextArea'  

  # You can pass an onChange() handler in to props that will get
  # called
  onChange: (e) ->
    @props.onChange?(e)
    scroll_height = @getDOMNode().scrollHeight
    if scroll_height > @getDOMNode().clientHeight
      @local.height = scroll_height + 5
      save(@local)

  render : -> 
    if !@local.height
      @local.height = @props.min_height

    @transferPropsTo TEXTAREA onChange: @onChange, style: {height: @local.height} 


CharacterCountTextInput = ReactiveComponent
  displayName: 'CharacterCountTextInput'
  componentWillMount : -> @data(@local_key).count = 0
  render : -> 
    class_name = "is_counted"
    DIV style: {position: 'relative'}, 
      @transferPropsTo TEXTAREA className: class_name, onChange: (=>
         @local.count = $(@getDOMNode()).find('textarea').val().length
         save(@local))
      SPAN className: 'count', @props.maxLength - @local.count


Auth = ReactiveComponent
  displayName: 'Auth'

  componentDidMount : -> 
    $(document).scrollTop $(@getDOMNode()).find('.auth_heading').offset().top - 10
    window.writeToLog
      what: 'accessed authentication'


  startThirdPartyAuth : (provider) ->
    root = @root
    new ThirdPartyAuthHandler
      provider : provider
      callback : (new_data) => 
        # Yay we got a new current_user object!  But this hasn't gone
        # through the normal arest channel, so we gotta save it in
        # sneakily with updateCache()
        arest.updateCache(new_data)

        # We know that the user has authenticated, but we don't know
        # whether they've completed OUR registration process including
        # the pledge.  The server tells us this via the existence of a
        # `user' object in current_user.

        current_user = @data('/current_user')
        if current_user.logged_in
          # We are logged in!  The user has completed registration.
          # Let's transition to results.
          root.proposal_mode = 'results'
          root.auth_mode = null
          if current_user.csrf
            arest.csrf(current_user.csrf)

          # @publishOpinionsAfterAuth()
          save(root)
        else 
          # We still need to show the pledge!
          root.auth_mode = 'register'
          save(root)

  submitAuth : (ev) -> 
    ev.preventDefault()
    current_user = @data('/current_user')

    $el = $(@getDOMNode())
    current_user.signed_pledge = $el.find('.pledge-input').length == $el.find('.pledge-input:checked').length
    local = @local
    local.submitting = true
    save(local)

    # It is important that a user that just submitted a user picture see the picture
    # on the results and in the header. However, this is a bit tricky because the avatars
    # are cached on the server and the image is processed in a background task. 
    # Therefore, we'll wait until the image is available and then make it available
    # in the avatar cache.  
    ensureCurrentUserAvatar = (attempts = 0) ->
      if current_user.b64_thumbnail
        $('head').append("<style type=\"text/css\">#avatar-#{current_user.id} { background-image: url('#{current_user.b64_thumbnail}');}</style>")
      else if attempts < 20
        # Ugly: wait a little while for offline avatar processing
        # to complete, then refetch
        arest.serverFetch('/current_user')
        _.delay -> 
          ensureCurrentUserAvatar(attempts + 1)
        , 1000

    # hack for submitting file data in ActiveREST for now
    # we'll just submit the file form after user is signed in
    # TODO: investigate alternatives for submitting form data
    if @submit_avatar_form
      save(current_user)
      $('#user_avatar_form').ajaxSubmit
        type: 'PUT'
        data: 
          authenticity_token: current_user.csrf
        success: (current_user_data, status, xhr) -> 
          current_user.errors = current_user_data.errors or []
          current_user.csrf = current_user_data.csrf
          save current_user, =>
            local.submitting = false
            save(local)
            ensureCurrentUserAvatar()
    else
      save(current_user, =>
        local.submitting = false
        save(local))

      if current_user.avatar_remote_url
        ensureCurrentUserAvatar()


  sendResetPassword : -> 

    # Tell the server to email us a token
    (current_user = @data('/current_user')).reset_my_password = true
    save(current_user, =>
      if not (current_user.errors?.reset_password?.length > 0)
        # Switch to reset_password mode
        @root.auth_mode = 'reset_password'
        save(@root)
      else
        # Tell the login screen to show the reset_password errors
        current_user.errors.login = current_user.errors.reset_password
        # console.log("Waiting for user to fix errors #{current_user.errors?.reset_password}")
        arest.updateCache(current_user)
      )
  toggleAuthMode : -> 
    current_user = @data('/current_user')
    @root.auth_mode = if @root.auth_mode == 'register' then 'login' else 'register'
    current_user.errors = {}
    save(@root)

  render: -> 
    current_user = @data('/current_user')
    root = @data('root')

    # When we switch to new auth_mode screens, wipe out all the old
    # errors, cause we're startin' fresh!
    if not @local.last_auth_mode or @local.last_auth_mode != root.auth_mode
      @local.last_auth_mode = root.auth_mode
      for error_type in (current_user.errors or {})
        current_user.errors[error_type] = []

    # Once the user logs in, we will stop showing the log-in screen
    if current_user.logged_in
      root.auth_mode = null
      # @publishOpinionsAfterAuth()

      save(root)
      setTimeout((() -> togglePage('results', 'after_save')), 700)
      return loading_indicator

    focal_wrapper_style = 
      margin: 'auto'
      position: 'relative'
      display: 'block'
      #left: '50%'
      width: DECISION_BOARD_WIDTH
      #marginLeft: -DECISION_BOARD_WIDTH / 2

    # Let's set up some useful helpers
    submitOnEnter = (event) =>
      if event.which == 13
        event.preventDefault()
        @submitAuth(event)

    input_box = (name, placeholder, type, onChange, pattern) ->
      type = type || 'text'
      onChange = onChange || (event) => 
        current_user[name] = event.target.value

      INPUT
        id: 'user_' + name
        defaultValue: current_user[name]
        name: "user[#{name}]"
        key: "#{name}_input_box"
        placeholder: placeholder
        required: "required"
        type: type
        onChange: onChange
        onKeyPress: submitOnEnter
        pattern: pattern

    name_input_field     = input_box('name', 'first and last name')
    email_input_field    = input_box('email', 'email@address', 'email')

    password_input_field =
      input_box('password',
                 if root.auth_mode == 'login' then "password" else "choose a new password",
                 'password',
                 null,
                 if root.auth_mode == 'register' then ".{5,}" else '')

    reset_password_token_field =
      INPUT
        id: "reset_password_token"
        name: "reset_password_token"
        key: "reset_password_token_input_box"
        placeholder: "verification code"
        required: "required"
        type: "text"
        defaultValue: current_user.reset_password_token
        onKeyPress: submitOnEnter
        onChange: (event) => current_user.reset_password_token = event.target.value

    providers = ['facebook', 'google']
    if root.auth_mode in ['login', 'reset_password']
      providers.push('twitter')

    third_party_authenticated = current_user.facebook_uid || current_user.twitter_uid || current_user.google_uid

    ## We'll be displaying the Auth header using the position and styling of the slider
    root = @data('root')
    slider = @data('slider')
    stance =  slider.stance
    segment = slider.stance_segment

    # Can't be dynamically set b/c of integration with asset fingerprinting. This is 
    # also why this file is ERB
    if segment == 3
      bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
    else
      bubblemouth_src = "<%= asset_path 'bubblemouth-crafting.png' %>"

    direction = if segment > 3 then -1 else 1
    mouth_x =      if segment == 3 then 0 else -22

    bubble_mouth_props = 
      transform: "translate(#{direction * mouth_x}px, 11px) scale(#{direction * 1.5}, 1.5)"
      left: slider.clientX
    handle_props = 
      left: slider.clientX - 15

    crossbrowserTransformProperty bubble_mouth_props
    crossbrowserTransformProperty handle_props

    auth_heading_style = 
      visibility: 'visible'
      left: HISTOGRAM_WIDTH * -(stance-1) / 2.0
      marginLeft: -225
      width: 450
      fontSize: 29
      position: 'relative'

      #top: '-80px'

    pledges = ['I will participate with only one account', 
               'I will speak only on behalf of myself', 
               'I will not attack or mock others']

    DIV className:'auth_region focal_wrapper', style: focal_wrapper_style,
      DIV className: 'auth_header', style : {width: HISTOGRAM_WIDTH}, 
        DIV className:'auth_heading', style: auth_heading_style,
          'Please Introduce Yourself' 

          if root.auth_mode in ['login', 'register']
            DIV className: 'switch_auth_mode', 
              SPAN null, if root.auth_mode == 'register' then 'If you already have an account, ' else 'If you don\'t have an account, '
              A className: 'toggle_auth', onClick: @toggleAuthMode, if root.auth_mode == 'register' then 'Log In' else 'Create an Account'

        DIV className: 'the_handle', style: handle_props
        IMG className:'bubblemouth', src: bubblemouth_src, style: bubble_mouth_props

      DIV className:'auth decision_board_body' + (if @local.submitting then ' waiting' else ''),
        if root.auth_mode in ['login', 'register'] && !current_user.provider && !third_party_authenticated
          DIV className: 'third_party_auth',
            LABEL className: 'third_party_call', 'Instantly:'
            for provider in providers
              do (provider) =>
                BUTTON className: "third_party_option #{provider}", onClick: (=> @startThirdPartyAuth(provider)),
                  I className: "fa fa-#{provider}"
                  SPAN null, provider

            DIV className: 'separator', dangerouslySetInnerHTML:{__html: "&mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;  <label>or</label>  &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;"}

        if root.auth_mode in ['login', 'reset_password']
          # logging in or resetting password

          DIV null, 
            if root.auth_mode == 'login'
              LABEL className: 'auth_section_label', 'By email address:'
            else
              DIV null,
                LABEL className: 'reset_password_section_label', 'Reset your password'
                DIV style: {'margin-bottom': 16}, "We just sent you a verification code via email to #{current_user.email}. Check your email, and enter the code here:"
            TABLE className: 'auth_fields login',
              TBODY null,
                if root.auth_mode == 'reset_password'
                  TR null,
                    TD null, 'We just emailed you a code. Enter it here:'
                  TR null, 
                    TD className: 'label_cell', 
                      LABEL htmlFor: 'user_verification_code', 'code:'

                    TD className: 'field_cell', 
                      reset_password_token_field,
                      DIV className: 'password_verification_explanation', "Find code in an email just sent to you."
                else
                  TR null,
                    TD className: 'label_cell',
                      LABEL htmlFor: 'user_email', 'email:'
                    TD className: 'field_cell',
                      email_input_field

                TR null,
                  TD {style: (if root.auth_mode == 'reset_password' then {width: '37%'} else {}), className: 'label_cell'},
                    switch root.auth_mode
                      when 'login'
                        LABEL htmlFor: 'user_password', 'password:'
                      when 'reset_password'
                        LABEL htmlFor: 'user_password', 'new password:'

                  TD className: 'field_cell', 
                    password_input_field,
                    if root.auth_mode == 'login'
                      A className: 'forgot_password', onClick: @sendResetPassword, 'I forgot! Email me password instructions.'


        else 
          # creating new account
          TABLE className: 'auth_fields register', 
            TBODY null,
              TR null, 
                TD className: 'label_cell',
                  LABEL htmlFor: 'user_name', 'Hi, my name is:'
                TD className: 'field_cell', 
                  if third_party_authenticated
                    DIV null, current_user.name
                  else 
                    name_input_field

              if third_party_authenticated 
                p = if current_user.google_uid then 'google' else if current_user.facebook_uid then 'facebook' else 'twitter'
                TR null, 

                  TD className: 'label_cell',
                    LABEL htmlFor: 'user_provider', 
                      if third_party_authenticated then 'I login via:' else 'I login as:'
                  TD className: 'field_cell', 
                    BUTTON className: "third_party_option #{p}", style: {cursor: 'default'},
                      I className: "fa fa-#{p}"
                      SPAN null, p

              else

                TR null, 

                  TD className: 'label_cell',
                    LABEL htmlFor: 'user_email', 'I login as:'
                  TD className: 'field_cell', 
                    if !Modernizr.input.placeholder
                      LABEL htmlFor: 'user_email', 'Email:'
                    email_input_field,

                    if !Modernizr.input.placeholder
                      LABEL htmlFor: 'user_password', 'Password:'
                    password_input_field

              # We're not going to bother with letting IE9 users set a profile picture. Too much hassle. 
              if window.FormData

                TR null, 
                  TD className: 'label_cell', 
                    LABEL htmlFor: 'user_avatar', 'I look like this:'
                  TD className: 'field_cell',
                    # hack for submitting file data in ActiveREST for now
                    # we'll just submit the file form after user is signed in


                    FORM id: 'user_avatar_form', action: Routes.current_user_path(), 

                      DIV className: 'avatar_preview_enclosure',
                        IMG id: 'avatar_preview', src: if current_user.avatar_remote_url then current_user.avatar_remote_url else null #todo: make sure that if user overrides image_url, that the new image is used
                    


                      INPUT id: 'user_avatar', name: "avatar", type: "file", onChange: (ev) => 
                        @submit_avatar_form = true
                        input = $('#user_avatar')[0]
                        if input.files && input.files[0]
                          reader = new FileReader()
                          reader.onload = (e) ->
                            $("#avatar_preview").attr 'src', e.target.result
                          reader.readAsDataURL input.files[0]
                          #current_user.avatar = input.files[0]
                        else
                          $("#avatar_preview").attr('src', "<%= asset_path 'no_image_preview.png' %>")

              
              TR null,
                TD className: 'label_cell', 
                  LABEL null, 'Community pledge:'
                TD className: 'field_cell',
                  UL className: 'pledges',
                    for pledge, idx in pledges
                      LI className: 'pledge', 
                        INPUT className:"pledge-input", type:'checkbox', id:"pledge-#{idx}", name:"pledge-#{idx}"
                        LABEL htmlFor: "pledge-#{idx}", pledge

        if current_user.errors && current_user.errors[root.auth_mode] && current_user.errors[root.auth_mode].length > 0
          DIV className: "auth_errors", 
            I className: 'fa fa-exclamation-circle'
            SPAN null, "#{current_user.errors[root.auth_mode].join(', ')}"


      DIV null, 
        DIV 
          className:'auth_button primary_button' + (if @local.submitting then ' disabled' else '')
          onClick: @submitAuth
        , if root.auth_mode == 'register' then 'Create account and save your opinion' else 'Login and save your opinion'

        A 
          className:'cancel_auth_button primary_cancel_button'
          onClick: (=>
            root.auth_mode = null
            root.publish_this_opinion = null
            save(root))
        , 'cancel log in'


ProposalSummary = ReactiveComponent
  displayName: 'ProposalSummary'

  render : ->
    customer = @data('/customer')
    color = @data('color')

    proposal = @data()
    hover_class = if @local.hovering_on == proposal.id then 'hovering' else ''

    cell_border = "1px solid #{if @local.hovering_on then color.link_hover_color else 'rgb(191, 192, 194)'}"
    TR 
      className: "proposal_summary " + hover_class
      style:
        cursor: 'pointer'
        height: ''
        padding: '0 30px'
        display: 'block'
        borderLeft: cell_border
      onMouseEnter: (=> @local.hovering_on = true; save(@local))
      onMouseLeave: (=> @local.hovering_on = false; save(@local))
      onClick: (=> window.app_router.navigate("/#{proposal.long_id}", {trigger: true}))              
    ,
      if customer.identifier == 'livingvotersguide'
        TD className: 'summary_measure_designator',
          if proposal.category && proposal.designator
            A onClick: clickInternalLink, href: "/#{proposal.long_id}", style: {color: "#{if @local.hovering_on then color.link_hover_color else ''}"},
              "#{proposal.category[0]}-#{proposal.designator}"

      TD className: 'summary_name', style: {width: (if customer.identifier == 'livingvotersguide' then 270 else 320)},
        A onClick: clickInternalLink, href: "/#{proposal.long_id}", style: {color: "#{if @local.hovering_on then color.link_hover_color else ''}"},
          proposal.name
      TD className: 'summary_decide', style: {borderLeft: cell_border, borderRight: cell_border},
        if !proposal.your_opinion || !@data(proposal.your_opinion).published || @data(proposal.your_opinion).stance_segment == 3
          style = {fontWeight: 400, color: 'rgb(158,158,158)', fontSize: 21}
          if @local.hovering_on
            style.color = 'black'
            style.fontWeight = 600
          SPAN style: style, '?'
        else if @data(proposal.your_opinion).stance_segment < 3
          SPAN style: {position: 'relative', left: 14},
            IMG 
              className: 'summary_opinion_marker'
              src: "<%= asset_path 'no_x.svg' %>"
              style: {width: 24, position: 'absolute', left: -28}
            SPAN style: {color: 'rgb(239,95,98)', fontSize: 18, fontWeight: 600}, 'No'
        else
          SPAN style: {position: 'relative', left: 14},
            IMG 
              className: 'summary_opinion_marker'
              src: "<%= asset_path 'yes_check.svg' %>"
              style: {width: 24, position: 'absolute', left: -28}

            SPAN style: {color: 'rgb(166,204,70)', fontSize: 18, fontWeight: 600}, 'Yes'

      TD className: 'summary_share',
        if proposal.top_point
          DIV className: 'top_point community_point con', style : { width: 270, position: 'relative' },
            # Avatar tag: SPAN, key: proposal.top_point.user, className:"point_author_avatar", hide_face: proposal.top_point.hide_name

            DIV className:'point_content', style : { },
              IMG 
                className: 'community_point_mouth'
                src: "<%= asset_path 'community_point_mouth.png' %>"

              DIV className:'point_nutshell', style: {fontSize: 15},
                "#{proposal.top_point.nutshell[0..30]}..."


Homepage = ReactiveComponent
  displayName: 'Homepage'

  componentDidMount : -> @initOrUpdateHeader()

  componentDidUpdate : -> @initOrUpdateHeader()

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.find('.sticky_header.stickable').StickyElement('destroy')

  initOrUpdateHeader : -> 
    $el = $(@getDOMNode())

    $header = $el.find('.sticky_header.stickable')
    if $header.length > 0
      if @local.sticky_initialized
        $header.StickyElement('update')
      else 
        $header.StickyElement
          placeholder: $el.find('.sticky_header.placeholder')[0]
          container: $el
        @local.sticky_initialized = true
        save @local

  render : ->
    customer = @data('/customer')
    color = @data('color')
    proposals = @data('/proposals')

    learn_decide_share_style = {backgroundColor: color.proposal_header, color: 'white'}
    if customer.identifier == 'livingvotersguide'
      learn_decide_share_style.backgroundColor = cream
      learn_decide_share_style.color = cityclub_brown

    # The "Welcome to the community!" people
    contributors = @page.contributors.filter((u)-> fetch(u).avatar_file_name)
    welcome_column =
      TH className: 'welcome_column',
        if contributors.length > 0
          [
            DIV className: 'learn_decide_share1', style: learn_decide_share_style, 'Join'
            DIV className: 'learn_decide_share2', style: learn_decide_share_style, 'the contributors'
            DIV className: 'people',
              for user in _(contributors).first(90)
                Avatar key: user, tag: SPAN, className: 'welcome_avatar', style: {height: 32, width: 32, margin: 1}
          ]
        else
          ''


    # Columns of the sticky header for the proposal list.
    if customer.identifier == 'livingvotersguide'
      columns = [ {heading: 'Learn', details: 'about your ballot'}, {heading: 'Decide', details: 'how you\'ll vote'}, {heading: 'Share', details: 'your opinion'}]
    else
      columns = [ {heading: 'Learn', details: 'about the issues'}, {heading: 'Decide', details: 'what you think'}, {heading: 'Share', details: 'your opinion'}]

    sticky_header_height = 79

    drawCluster = (cluster, is_first=false) =>
      if cluster.proposals?.length > 0 
        TABLE
          style:
            borderLeft: '0px solid rgb(191, 192, 194)'
            margin: '20px auto'
            position: 'relative'

          TBODY null,
            TR null,
              # Draw the cluster name off to the side
              TH className: 'proposal_cluster',
                cluster.name

              # Draw the welcome column... let's find a better place for it.
              if is_first
                welcome_column

            # Draw each proposal summary
            for proposal in cluster.proposals
              ProposalSummary
                key: proposal.key
                cluster: cluster.name


    DIV className: 'homepage',
      # Draw the header
      DIV className: "sticky_header placeholder", style: {width: '100%', height: sticky_header_height}
      DIV 
        className: "sticky_header stickable"
        style: _.extend({}, learn_decide_share_style, {height: sticky_header_height, width: '100%', zIndex: 9999, minWidth: PAGE_WIDTH}) #minwidth is for when dropping into sticky, position fixed mode
      ,
        TABLE style: {margin: 'auto'},
          TBODY null,
            TR null,
              for col in columns
                TD style: {display: 'inline-block', width: 250},
                  DIV className: 'learn_decide_share1', style: learn_decide_share_style,
                    col.heading
                  DIV className: 'learn_decide_share2', style: learn_decide_share_style,
                    col.details

      # Draw the proposal summaries
      for cluster, index in proposals.clusters or []
        [
          if index == 1 and customer.identifier == 'livingvotersguide'
            ZipcodeBox()
          
          drawCluster(cluster, index == 0)

          # TODO: There are probably lots of cases where we want to add more details to
          #       a cluster of proposals.  For example, saying that proposals in cluster
          #       "Council meeting 6/7" will be open for discussion at the upcoming
          #       meeting. Keep an eye on this possible generality (and eliminate this
          #       edge case if we do generalize it)
          if cluster.name == 'Advisory votes' and customer.identifier == 'livingvotersguide'
            DIV
              style:
                color: 'rgb(108,107,98)'
                fontSize: 16
                paddingLeft: 164
                paddingTop: 12
                margin: 'auto'
                width: PAGE_WIDTH
              "* Advisory Votes are not binding. They are a consequence of "
              A href: "http://en.wikipedia.org/wiki/Washington_Initiative_960", style: {fontWeight: 600, color: 'rgb(108,107,98)'}, 'Initiative 960' 
              " passing in 2007."
        ]

ZipcodeBox = ReactiveComponent
  displayName: 'ZipcodeBox'
  render: ->
    c = @data('/current_user')
    extra_text = if Modernizr.input.placeholder then '' else ' Zip Code'
    onChange = (event) =>
      if event.target.value.match(/\d\d\d\d\d/)
        c.tags.zip = event.target.value
        save(c)

      else if event.target.value.length == 0
        c.tags.zip = undefined
        @local.stay_around = true
        save(c)
        save(@local)

    onBlur = =>
      @local.stay_around = false
      save(@local)

    if c.tags.zip or @local.stay_around
      # Render the completed zip code box
      DIV
        className: 'filled_zip'
        style:
          padding: '13px 23px'
          backgroundColor: '#F5F4ED'
          fontSize: 18
          fontWeight: 400
          width: 245
          margin: 'auto'
        'Customized for:'
        INPUT
          type: 'text'
          key: 'zip_input'
          defaultValue: c.tags.zip or ''
          onChange: onChange
          onBlur: onBlur

    else
      # Render the ragged input box
      DIV style: {margin: '55px 0'},
        DIV className: 'ragged_top'
        DIV className: 'ragged_middle',
          DIV
            style:
              fontSize: 24
              width: PAGE_WIDTH
              color: cream
              margin: 'auto'
              padding: '35px 0'
              paddingLeft: '170px'
            'Customize this guide for your' + extra_text
            INPUT
              type: 'text'
              key: 'zip_input'
              placeholder: 'Zip Code'
              style: {margin: '0 0 0 12px', fontSize: 24, height: 42, width: 152, padding: '4px 20px'}
              onChange: onChange
            BR null
            SPAN style: {fontSize: 18}, 'Your local congressional race and measures will be revealed!'

        DIV className: 'ragged_bottom'


LogoutButton = ReactiveComponent
  displayName: 'LogoutButton'

  logout : -> 
    current_user = @data('/current_user')
    current_user.logged_in = false

    @root.auth_mode = null

    save current_user, =>
      # We need to get a fresh your_opinion object
      # after logging out. 

      # TODO: the server should dirty keys on the client when the
      # current_user logs out
      arest.clear_matching_objects((key) -> key.match( /\/proposal\// ))

    save @root

  render : -> 
    current_user = @data('/current_user')
    customer = @data('/customer')
    color = @data('color')

    # DIV null,
    #   if current_user.logged_in
    #     userbar_style = {}
    #     link_style = {}
    #     if customer.identifier == 'livingvotersguide' #to deal with the weird cream header for LVG
    #       userbar_style = {backgroundColor: color.background}

    #       if @root.page_name not in ['homepage', 'about']
    #         userbar_style = { top: 51, right: 2, left: 'auto' }
    #         link_style = { color: '#777', fontWeight: 600, fontSize: 15 }
    link_style = {}
    if customer.identifier != 'livingvotersguide'
      link_style = {position: 'absolute', right: 20, top: 4}
    SPAN className: 'userbar', style: link_style,
      #Avatar key: current_user.user, tag: SPAN, className: 'userbar_avatar', style: {height: 26, width: 26, marginTop: -2}
      A style: {}, 'data-action': 'logout', onClick: @logout, 'Logout'

Header = ReactiveComponent
  displayName: 'Header'

  render : ->
    current_user = @data('/current_user')
    customer = @data('/customer')
    color = @data('color')

    DIV className: 'l_header', style: {backgroundColor: color.header_bg, minWidth: PAGE_WIDTH},
      if customer.identifier != "livingvotersguide"
        LogoutButton()

      DIV null, 
        # Define all the customer-specific styles for non-repeated elements directly. 
        # This lets us iterate quicker and minimize where customer specific code lives.
        switch customer.identifier
          when 'cityoftigard'
            logo_style = {height: 117, backgroundColor: 'white', borderRight: '2px solid white'}
            DIV null,
              DIV style: {height: 38},
                A href: '/', onClick: @clickInternalLink, style: {position: 'absolute', top:0, zIndex: 999999},
                  IMG className: 'logo', src: "<%= asset_path 'cityoftigard/logo.png' %>", style: logo_style 
                # SPAN style: {color: 'white', fontSize: 28, display: 'inline-block', margin: '20px 0 0 110px'}, 
                #   'Engage with the '
                #   A href: 'http://www.tigard-or.gov', style: {color: 'white', fontWeight: 600}, 'City of Tigard'
              # DIV style: {backgroundColor: color.proposal_header, width: '100%', height: 50}
          when 'tigard'
            logo_style = {height: 60}
            DIV null,
              A href: '/', onClick: @clickInternalLink, style: {padding: 12, display: 'inline-block'},
                IMG className: 'logo', src: "<%= asset_path 'tigard/logo.jpg' %>", style: logo_style 
              SPAN style: {color: '#707070', fontSize: 24, display: 'inline-block', margin: '20px 0 0 50px', fontWeight: 800, textTransform: 'uppercase', position: 'relative', top: -20}, 
                'Help plan '
                A href: 'http://riverterracetigard.com/', style: {color: '#78d18b', fontWeight: 600}, 'River Terrace'
                ', Tigard\'s newest neighborhood' 


          # when 'ihub'
          #   logo_style = {height: 42, position: 'absolute', bottom: 4, zIndex: 999999, left: 8}
          #   DIV style: {height: 50},
          #     A href: 'http://disruptingmedicine.org/about-the-innovation-hub/',
          #       IMG className: 'logo', src: "<%= asset_path 'ihub/logo.png' %>", style: logo_style 

          when 'livingvotersguide'
            show_full = @root.page_name in ['homepage', 'about']

            logo_style =
              position: 'absolute'
              left: if show_full then 62 else 154
              top: if show_full then 27 else 73
              width: if show_full then 222 else 130
              zIndex: 1

            DIV null,
              # Top cream area
              DIV
                style:
                  height: 69
                  width: '100%'
                  textAlign: 'right'
                  backgroundColor: cream
                  paddingRight: 80
                  fontSize: 21
                  paddingTop: 20
                  color: cityclub_navy

                DIV null,
                  A style: {}, href:'/about', onClick: clickInternalLink, 'About'
                  if @data('/current_user').logged_in
                    SPAN null,
                      ' | '
                      LogoutButton()
                  # else 
                  #   A style: {}, href: '#', onClick: clickInternalLink, 'Log in'

              # Logo
              A href: (if @root.page_name == 'homepage' then '/about' else '/'), onClick: clickInternalLink,
                IMG className: 'logo', src: "<%= asset_path 'livingvotersguide/logo.svg' %>", style: logo_style

              # Blue + green areas
              DIV
                style:
                  backgroundColor: if show_full then cityclub_green else cityclub_blue
                  color: cream
                  height: 137
                  marginBottom: if show_full then 23 else 0
                  clear: 'both'

                # Online Intelligence for Washington Voters
                DIV
                  style:
                    fontSize: 32
                    padding: '22px 40px 0 332px'
                    backgroundColor: cityclub_blue
                    width: 838
                    height: '100%'
                    float: 'left'
                  SPAN style:{fontWeight: 400}, 'Created by the people '
                  'and for the people of Washington state'

                DIV
                  style:
                    fontSize: 18
                    padding: '14px 40px 0 26px'
                    float: 'left'
                    width: 280
                    height: '100%'
                  DIV null, 'Hosted by'
                  A {href: 'http://seattlecityclub.org'}, B(style:{fontWeight:'bold', color: 'white'}, 'Seattle CityClub')
                  DIV style: {marginTop: 8}, 'with fact-checks from'
                  A {href: 'http://spl.org'}, B(style:{fontWeight:'bold', color: 'white'}, 'The Seattle Public Library')
                  
      DIV null, 
        if @root.page_name == 'about'
          # TODO: we need a way of knowing whether this subdomain has a homepage or not
          if customer.identifier == 'livingvotersguide'
            A className: 'homepage_link', onClick: (=> window.app_router.navigate("/", {trigger: true})), style: {position: 'absolute', display: 'inline-block', zIndex: 999, marginTop: 8, marginLeft: 16, fontWeight: 600}, 
              I className: 'fa fa-home', style: {fontSize: 28, color: '#bbb'}
              SPAN style: {fontSize: 15, paddingLeft: 6, color: '#777', verticalAlign: 'text-bottom'}, 'Home'


      DIV style: { backgroundColor: '#eee', color: '#f00', padding: '5px 20px', display: if @root.server_error then 'block' else 'none'},
        'Warning: there was a server error!'


SharingButtons = ReactiveComponent
  displayName: 'SharingButtons'
  render: ->
    SPAN null,

      IFRAME 
        style: {border: 'none', overflow: 'hidden', width: 90, height: 21}
        src: "//www.facebook.com/plugins/like.php?href=http://www.facebook.com/pages/Living-Voters-Guide/157151824312366&send=false&layout=button_count&width=450&show_faces=false&action=like&colorscheme=light&font=lucida+grande&height=21"
        scrolling: "no"
        frameBorder: "0"
        allowTransparency: "true"

      IFRAME 
        src: "https://platform.twitter.com/widgets/tweet_button.1410542722.html#_=1410827370943&amp;count=none&amp;hashtags=lvguide&amp;id=twitter-widget-0&amp;lang=en&amp;original_referer=https%3A%2F%2Flivingvotersguide.org%2F&amp;related=lvguide&amp;size=m&amp;text=I%20flexed%20my%20civic%20muscle%20%40lvguide.&amp;url=https%3A%2F%2Flivingvotersguide.org%2F"
        scrolling: "no"
        frameBorder: "0"
        allowTransparency: "true"
        className: "twitter-share-button twitter-tweet-button twitter-share-button twitter-count-none"
        style: {width: 57; height: 20}


Footer = ReactiveComponent
  displayName: 'Footer'
  render : -> 
    customer = @data('/customer')
    color = @data('color')

    DIV className: 'l_footer',  
      if customer.identifier == 'livingvotersguide'
        DIV null,
          DIV style: {color: cream, backgroundColor: cityclub_blue, marginTop: 48, padding: 18},
            DIV style: {fontSize: 18, fontStyle: 'italic', textAlign: 'left', width: 690, fontStyle: 'italic', margin: 'auto'},
              'Unlike voter guides generated by government, newspapers or advocacy organizations, Living Voters Guide is created '
              SPAN style: {fontWeight: 600}, 'by the people'
              ' and '
              SPAN style: {fontWeight: 600}, 'for the people'
              ' of Washington State. Its your platform to learn about candidate and ballot measures, decide how to vote and express your ideas. We believe that sharing our diverse opinions leads to making wiser decisions together. '
              A style: {color: cream, textDecoration: 'underline', fontWeight: 'normal'}, href: '/about', onClick: clickInternalLink, 'Learn more'
              '.'

            DIV style: {marginTop: 20},
              SharingButtons()

          DIV style: {paddingTop: 24, paddingBottom: 12, fontSize: 18, fontWeight: 500, color: 'rgb(77,76,71)'},
            'Bug to report? Have a comment? Confused? '
            A href: "mailto:admin@livingvotersguide.org", style: {color: 'rgb(77,76,71)'},
              'Email us'

          DIV style: {paddingBottom: 18},

            # DIV style: {textAlign: 'left', padding: '0 12px', color: 'rgb(131,131,131)', display: 'inline-block', fontSize: 15},
            #   A href: "http://seattlecityclub.org", style: {position: 'relative', top: 3, fontWeight: 400},
            #     IMG src: "<%= asset_path 'livingvotersguide/cityclub.svg' %>"

            DIV style: {textAlign: 'left', padding: '0 12px', color: 'rgb(131,131,131)', display: 'inline-block', fontSize: 15},
              "Technology by "
              A href: 'http://consider.it', style: {textDecoration: 'none', color: 'rgb(131,131,131)', fontWeight: 600}, target: '_blank', 'Considerit'

            # DIV style: {textAlign: 'left', padding: '0 12px', color: 'rgb(131,131,131)', display: 'inline-block', fontSize: 15},
            #   "Fact-checking by "
            #   A href: 'http://spl.org', style: {textDecoration: 'none', color: 'rgb(131,131,131)', display: 'block', fontWeight: 600}, target: '_blank', 'The Seattle Public Library'

      else
        DIV null,
          "Technology by "
          A href: 'http://consider.it', target: '_blank', 'Considerit'
          SPAN className: 'separator', ''
          'Bug to report? '
          A href: "mailto:admin@consider.it", 'Email us'


# top secret proposal creation component
EditProposal = ReactiveComponent
  displayName: 'EditProposal'

  saveProposal : -> 
    $el = $(@getDOMNode())

    name = $el.find('#name').val()
    description = $el.find('#description').val()
    long_id = $el.find('#long_id').val()
    cluster = $el.find('#cluster').val()
    cluster = null if cluster == ""

    if @props.fresh
      proposal =
        key : '/new/proposal'
        name : name
        description : description
        cluster : cluster
        long_id : long_id

    else 
      proposal = @data()
      _.extend proposal, 
        cluster: cluster
        name: name
        long_id: long_id
        description: description

    save proposal, -> window.app_router.navigate "/#{long_id}", {trigger : true}

  render : ->
    user = @data('/current_user')
    
    return DIV null, 'Nothing to see here, move on' if !user.logged_in || !user.is_admin || (!@props.fresh && !@data().long_id )

    block_style = { width: CONTENT_WIDTH, padding: '2px 8px', marginBottom: 20 }
    input_style = {marginLeft: 18, fontSize: 18, width: CONTENT_WIDTH - 200, padding: '2px 4px'}
    label_style = {verticalAlign: 'top', fontSize: 18, width: 150, display: 'inline-block'}

    DIV style: { width: PAGE_WIDTH, margin: 'auto', padding: '5em 0' },
      H1 style: {fontSize: 28, marginBottom: 20},
        "Top secret create new proposal page. Shhhhh..."

      DIV style: block_style,
        LABEL htmlFor:'long_id', style: label_style, 'URL'
        INPUT 
          id:'long_id'
          name:'long_id'
          pattern:'^.{3,}'
          placeholder:'e.g. consider.it/I_am_the_url. Just letters, numbers, underscores, dashes.'
          required:'required'
          defaultValue: if @props.fresh then null else @data().long_id
          style: input_style

      DIV style: block_style,
        LABEL htmlFor:'name', style: label_style, 'Topic question'
        INPUT 
          id:'name'
          name:'name'
          pattern:'^.{3,}'
          placeholder:'Make this super succinct with a <verb> <noun>.'
          required:'required'
          defaultValue: if @props.fresh then null else @data().name
          style: input_style

      DIV style: block_style,
        LABEL htmlFor:'description', style: label_style, 'Description'
        TEXTAREA 
          id:'description'
          name:'description'
          pattern:'^.{3,}'
          placeholder:'Make this good :)'
          required:'required'
          defaultValue: if @props.fresh then null else @data().description
          style: _.extend {}, input_style, {height: 150}

      DIV style: block_style,
        LABEL htmlFor:'cluster', style: label_style, 'Group (optional)'
        INPUT 
          id:'cluster'
          name:'cluster'
          pattern:'^.{3,}'
          placeholder:'The group to which this proposal belongs, if any.'
          defaultValue: if @props.fresh then null else @data().cluster
          style: input_style

      DIV null,
        INPUT className:'button primary_button', type:'submit', value:'Publish', onClick: @saveProposal


About = ReactiveComponent
  displayName: 'About'

  componentWillMount : ->
    @local.embed_html_directly = true
    @local.html = null
    @local.save

  componentDidMount : -> @handleContent()
  componentDidUpdate : -> @handleContent()

  handleContent : -> 
    $el = $(@getDOMNode())

    if @local.embed_html_directly
      # have to use appendChild rather than dangerouslysetinnerhtml
      # because scripts in the about page html won't get executed
      # when using dangerouslysetinnerhtml
      if @local.html
        $el.find('.embedded_about_html').append @local.html

    else
      # REACT iframes don't support onLoad, so we need to figure out when 
      #               to check the height of the loaded content ourselves      
      $el.prop('tagName').toLowerCase() == 'iframe'
      iframe = $el[0]
      _.delay ->
        try 
          iframe.height = iframe.contentWindow.document.body.scrollHeight + "px"
        catch e
          iframe.height = "2000px"
          console.error 'Couldn\'t set about page iframe height because of http/https mismatch. Should work in production.'
          console.error e
      , 1000


  render : -> 
    customer = @data('/customer') 

    if @local.embed_html_directly && !@local.html && customer.about_page_url
      # fetch the about page HTML directly
      $.get customer.about_page_url, (response) => @local.html = response; save @local

    DIV style: {marginTop: 20},
      if !customer.about_page_url
        DIV null, 'No about page defined'
      else if !@local.embed_html_directly
        IFRAME src: customer.about_page_url, width: PAGE_WIDTH, style: {display: 'block', margin: 'auto'}
      else
        DIV className: 'embedded_about_html'

Root = ReactiveComponent
  displayName: 'Root'
  resetSelection: (e) ->
    if @root.selected_point
      console.log('Got a click on',e.target)
      window.writeToLog
        what: 'deselected a point'
        details:
          point: @root.selected_point

      @root.selected_point = null
      save @root


  render : -> 
    root = @data()

    ######
    # Handle application routing, derived from client state.
    query_parameters = Backbone.history.getQueryParameters()
    query_parameters = {}

    if @root.proposal_mode == 'results'
      query_parameters['results'] = true #the only query parameter we support now is ?results=true for proposal pages
    if @root.selected_point
      query_parameters['selected'] = @root.selected_point

    # Second, construct the proper url
    if root.page_name == 'homepage' 
      url = ''
    else if root.page_name == 'about'
      url = 'about'
    else #if we're rendering a proposal...
      url = window.app_router.toFragment root.page_name, query_parameters

    # Third, update the location bar if it's different
    if "#{window.location.pathname}#{window.location.search}" != "/#{url}"
      window.app_router.navigate url, {trigger : true}
    ####

    # Now let's render
    DIV onClick: @resetSelection,
      StateDash(),
      Page(key: "/page/#{root.page_name}"),
      Computer() # Doesn't actually render anything
      Colors() # Doesn't actually render anything

Page = ReactiveComponent
  displayName: 'Page'

  componentDidMount : ->
    fetchAvatars()

  render: ->

    color = @data('color')

    DIV style: {minWidth: PAGE_WIDTH, backgroundColor: color.background}, 'data-authmode': @root.auth_mode, #authmode controls styling during authentication process
      BrowserHacks()
      Header()
      DIV id: 'body', style : { minWidth: PAGE_WIDTH }, 
        DIV id: 'inner_body', #style : { width: CONTENT_WIDTH },
          if @root.page_name == 'homepage'
            Homepage key: @page.key
          else if @root.page_name == 'about'
            About()
          else if @root.page_name == 'proposal/new'
            EditProposal key: "new_proposal", fresh: true
          else if @root.page_name.match(/(.+)\/edit/)
            EditProposal key: "/#{@root.page_name.match(/(.+)\/edit/)[1]}", fresh: false
          else 
            Proposal key: @page.proposal.key

      Footer()

Computer = ReactiveComponent
  # This doesn't actually render anything.  It just processes state
  # changes to current_user for CSRF and logging in and out.
  displayName: 'Computer'
  render : ->
    current_user = @data('/current_user')
    if current_user.csrf
      arest.csrf(current_user.csrf)

    #console.log("Maybe we will publish: '#{@root.opinions_to_publish}' #{current_user.logged_in}")

    # Publish pending opinions if we can
    while @root.opinions_to_publish.length > 0 and current_user.logged_in
      opinion = @data(@root.opinions_to_publish.pop()); save(@root)
      if opinion.published
        break
      console.log("Publishing the opinion. It's", opinion)
      opinion.published = true
      save(opinion)

    return SPAN null, ''


# Non-rendering component that makes customer-specific colors available for use
Colors = ReactiveComponent
  displayName: 'Color'
  render : ->
    customer = @data('/customer')
    color = @data('color')

    # initialize colors if they haven't already been set
    if !color.background && customer.identifier
      # default colors
      # I didn't want to put these in the defaults section below because 
      # it would be annoying to refer back and forth to them here.
      _.extend color,
        background: 'white'
        proposal_header: '#E37765'
        header_bg: '#E37765'
        link_hover_color: 'black'

      # Define colors for different customers. 
      switch customer.identifier
        when 'livingvotersguide'
          color.header_bg = color.proposal_header = cityclub_green #'rgb(0,182,236)'
          color.background = cream
          color.link_hover_color = 'rgb(118,148,41)'
        when 'cityoftigard'
          color.header_bg =  '#253967'
          color.proposal_header = '#46A046'          
        when 'tigard'          
          color.header_bg =  'white'
          color.proposal_header = '#78d18b'
        when 'ihub'
          color.header_bg =  color.proposal_header = "rgb(150,150,150)"

      save color

    SPAN null, ''


# Displays warnings for some browsers
# Stores state about the current device. 
# Note that IE<9 users are redirected at
# an earlier point to an MS upgrade site. 
BrowserHacks = ReactiveComponent
  displayName: 'BrowserHacks'

  render : ->
    browser = @data('browser')
    if !browser.is_iOS?
      rxaosp = window.navigator.userAgent.match /Android.*AppleWebKit\/([\d.]+)/ 
      browser.is_android_browser = !!(rxaosp && rxaosp[1]<537)  # stock android browser (not chrome)
      browser.is_opera_mini = !!navigator.userAgent.match /Opera Mini/
      browser.is_ie9 = !!(document.documentMode && document.documentMode == 9)
      browser.is_iOS = !!navigator.platform.match(/(iPad|iPhone)/)
      save browser
    
    if browser.is_android_browser || browser.is_opera_mini
      DIV style: {backgroundColor: 'red', padding: '10px', textAlign: 'center', color: 'white', fontSize: 24}, 
        "This website does not work well with #{if browser.is_android_browser then 'the Android Browser' else 'Opera Mini'}. Please use "
        A href: "https://play.google.com/store/apps/details?id=com.android.chrome&hl=en", style: {color: 'white', textDecoration: 'underline'},
          'Chrome for Android' 
        ' if you experience difficulty. Thanks, and sorry for the inconvenience!'
    else 
      # Use third party script for detecting and warning users
      # of other outdated browsers. Sticking with
      # third party for now because of some complexities
      # in detecting some of these browser versions. In 
      # the future, probably want to extract the logic. 
      # "https://browser-update.org/update.html"
      SCRIPT type: 'text/javascript', src: '//browser-update.org/update.js'


## ########################
## Initialize defaults for client data

fetch 'histogram',
  highlighted_users : null
  selected_segment : null
  selected_segment_isclicked : null

fetch 'slider',
  has_moved : false
  is_moving : false
  stance : null
  stance_segment : null

fetch 'decisionboard',
  sticky : false

fetch 'root',
  auth_mode : null
  opinions_to_publish : []

fetch('/current_user')


##
# load users' pictures

fetchAvatars = ->
  $.get Routes.get_avatars_path(), (data) -> 
    if $('#b64-avatars').length > 0
      $('#b64-avatars').remove()
    if data
      $('head').append data


##
# Backbone routing
# Note: not committed to backbone. Want to experiment with other routing techniques too.
window.root = null
Router = Backbone.Router.extend
  
  routes :
    "(/)" : "homepage"
    "about(/)" : "about"
    "proposal/new(/)" : "new_proposal"
    "proposal/:proposal/edit(/)": "edit_proposal"
    ":proposal(/)": "proposal"    

  proposal : (long_id, params) ->
    root = fetch('root')
    root.page_name = long_id

    #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
    #      Right now activeREST doesn't allow wide consumption of a component's client state
    #      if its data is synced with the server. 
    root.proposal_mode = 'crafting'
    root.selected_point = null
    if params 
      root.proposal_mode = 'results' if params['results']
      root.selected_point = params['selected'] if params['selected']
    save root

    writeToLog
      what: 'loaded page',
      where: long_id

  homepage : (params) -> 
    root = fetch('root')
    root.page_name = 'homepage'

    #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
    #      Right now activeREST doesn't allow wide consumption of a component's client state
    #      if its data is synced with the server. 
    root.proposal_mode = null
    root.selected_point = null
    save root

    writeToLog
      what: 'loaded page',
      where: 'homepage'

  about : (params) ->
    root = fetch('root')
    root.page_name = 'about'
    root.proposal_mode = null
    root.selected_point = null
    save root

    writeToLog
      what: 'loaded page',
      where: 'about'

  new_proposal : (params) ->
    root = fetch('root')
    root.page_name = 'proposal/new'
    root.proposal_mode = null    
    root.selected_point = null
    save root

  edit_proposal : (id, params) ->
    root = fetch('root')
    root.page_name = "proposal/#{id}/edit"
    root.proposal_mode = null
    root.selected_point = null
    save root      

# Handles router navigation for links so that a page reload doesn't happen
clickInternalLink = (event) ->
  href = $(event.currentTarget).attr('href')

  # Allow shift+click for new tabs, etc.
  if !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey
    event.preventDefault()
    # Instruct Backbone to trigger routing events
    window.app_router.navigate href, { trigger : true }
    return false

window.app_router = new Router()
window.on_ajax_error = () ->
  (root = fetch('root')).server_error = true
  save(root)
window.on_client_error = (e) ->
  save({ key: '/new/client_error', stack: JSON.stringify(e.stack) })

window.writeToLog = (entry) ->
  _.extend entry, 
    key: '/new/log'
    where: fetch('root').page_name

  save entry

window.arest.trans_in = (object) ->
  fix_comments = (o) ->
    if o.key?.match(/\/comments\//)
      o.comments = for comment in o.comments
        comment.key = "/comment/#{comment.id}"
        comment.user = "/user/#{comment.user_id}"
        delete comment.id
        delete comment.user_id
        comment

  #arest.deep_map(fix_comments, object)
  return object

$(document).ready -> 
  if 'ontouchend' in document #detect touch support
    React.initializeTouchEvents(true)

  Backbone.history.start {pushState: true}
  window.root = React.renderComponent(Root(), document.getElementById('content'))


  # google analytics
  ga = document.createElement('script')
  ga.type = 'text/javascript'
  ga.async = true
  ga.src = (if 'https:' == document.location.protocol then 'https://ssl' else 'http://www') + '.google-analytics.com/ga.js'
  s = document.getElementsByTagName('script')[0] 
  s.parentNode.insertBefore(ga, s)
