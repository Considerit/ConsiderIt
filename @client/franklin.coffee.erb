#////////////////////////////////////////////////////////////
# Core considerit client code
#////////////////////////////////////////////////////////////

DO_NOT_COMPRESS_THIS_FILE = true

## ########################
## Initialize defaults for client data

fetch 'histogram',
  highlighted_users : null
  # region_selection_width controls the size of the selection region when hovering 
  # over the histogram. It defines the opinion bounds within which opinions
  # are selected. Opinions = [-1, 1]. region_selection_width is on this scale. 
  region_selection_width : .25
  selected_opinion : null
  selected_opinions : null # use null instead of [] because an empty selection 
                           # can happen that we treat differently than no selection

fetch 'slider',
  has_moved : false
  is_moving : false
  stance : null

fetch 'decisionboard',
  sticky : false
  
fetch 'root',
  auth_mode : null
  opinions_to_publish : []

fetch '/current_user'

rxaosp = window.navigator.userAgent.match /Android.*AppleWebKit\/([\d.]+)/ 
window.browser = 
  is_android_browser : !!(rxaosp && rxaosp[1]<537)  # stock android browser (not chrome)
  is_opera_mini : !!navigator.userAgent.match /Opera Mini/
  is_ie9 : !!(document.documentMode && document.documentMode == 9)
  is_iOS : !!navigator.platform.match(/(iPad|iPhone)/)
  touch_enabled : 'ontouchend' in document
  high_density_display : ((window.matchMedia && (window.matchMedia('only screen and (min-resolution: 124dpi), only screen and (min-resolution: 1.3dppx), only screen and (min-resolution: 48.8dpcm)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3)').matches)) || (window.devicePixelRatio && window.devicePixelRatio > 1.3))

window.lefty = false

window.proposal_url = (proposal) =>
  # The special thing about this function is that it only links to
  # "?results=true" if the proposal has an opinion.
  result = '/' + proposal.slug
  if false and proposal.top_point
    result += '?results=true'
  return result

window.isNeutralOpinion = (stance) -> 
  return Math.abs(stance) < 0.05

window.sliderPole = (scope, valence) -> 
  subdomain = fetch('/subdomain')

  customizations[subdomain.name]?.slider_pole_labels?[scope]?[valence] or
    customizations.default.slider_pole_labels[scope][valence]


userOpinion = (user_key) ->
  window.user_opinions[user_key]

_route_changed = false

window.togglePage = (proposal_mode, triggered_by) ->
  $('.slider_pole_label').ensureInView
    offset_buffer: 150
    callback : -> 
      root = fetch('root')

      window.writeToLog
        what: 'toggle proposal mode'
        details: 
          from: root.proposal_mode
          to: proposal_mode
          triggered_by: triggered_by 

      root.proposal_mode = proposal_mode
      root.selected_point = null
      save root

      # Kludge for tracking when the page changes
      _route_changed = true
      _.delay -> 
        _route_changed = false
      , 1


##
# PageTransition mixin
# Helper for components that implement a page transition animation.
# Applies styles defined in the component that change
# depending on the route. 
#
# The styles will be added on every update and on component mount. 
# However, it will *animate* the styles only if the page has changed (_route_changed). 
# Otherwise it just directly applies the styles
PageTransition = 

  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) ->
    @applyStyles _route_changed

  applyStyles : (animate) ->
    duration = if animate then TRANSITION_SPEED else 0
    root = @root
    $el = $(@getDOMNode())

    # Each Component that implements this mixin can get triggered multiple times after a route change. 
    # So we're going to ensure that we apply styles only once for a given route change. 
    return if @transitioning == root.proposal_mode

    @transitioning = root.proposal_mode

    switch @name

      # The histogram will get transparent when moving to crafting page
      when 'histogram'
        opacity = if root.proposal_mode == 'crafting' then '0.2' else '1.0'
        $el.find('.histogram_bar').velocity {opacity: opacity}, {duration}

      # The position of the CommunityPoints will move to the wings on crafting, and 
      # be close together in results
      when 'communitypoints'

        if root.proposal_mode == 'crafting'
          offset_x = if @props.key == 'cons' then 0 else DECISION_BOARD_WIDTH
        else if root.proposal_mode == 'results'
          offset_x = DECISION_BOARD_WIDTH / 2

        $el.velocity { translateX: offset_x }, {duration}

      # The slider handle and mouth will change size and location when moving between crafting and results
      when 'slider'
        slider = fetch 'slider'

        direction = if slider.stance > 0 && !isNeutralOpinion(slider.stance) then 1 else -1
        mouth_x   = if isNeutralOpinion(slider.stance) then 0 else -SLIDER_HANDLE_SIZE

        if root.proposal_mode == 'crafting'
          bubblemouth_style = { translateX: direction * mouth_x, translateY: 20, scaleX: direction * 1.5, scaleY: 1.5  }
        else 
          bubblemouth_style = { translateX: direction * mouth_x, translateY: -4, scaleX: direction, scaleY: 1  }

        handle_style = { scale: if root.proposal_mode == 'results' || fetch('decisionboard').sticky then 1 else 2.5}

        $el.find('.bubblemouth').velocity bubblemouth_style, {duration}
        $el.find('.the_handle').velocity handle_style, {duration}

      # The decision board will have to expand for crafting and collapse into to the Give Opinion button in results
      when 'decisionboard'
        if root.proposal_mode == 'crafting'
          decision_board_style =
            translateX: 0
            translateY: 10
            width: DECISION_BOARD_WIDTH
            minHeight: 275

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.give_opinion_button').css 'visibility', 'hidden'
          _.delay => 
            #delay & check in case of quick switch between pages
            if root.proposal_mode == 'crafting'
              $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', ''
          , duration

        else 
          slider = fetch 'slider'
          slider_position = slider.clientX

          give_opinion_button_width = 200

          gutter = .1 * give_opinion_button_width
          opinion_region_x = -gutter + (DECISION_BOARD_WIDTH - give_opinion_button_width + 2 * gutter) * slider_position/HISTOGRAM_WIDTH

          decision_board_style =
            translateX: opinion_region_x
            translateY: -18
            width: give_opinion_button_width
            minHeight: 32
            marginTop: 0

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', 'none'
          _.delay => 
            #check in case of quick switch between pages
            if root.proposal_mode == 'results'
              $el.find('.give_opinion_button').css 'visibility', ''
          , duration  
      else
        throw "The #{@name} component does not define any styles to animate"

    _.delay => 
      @transitioning = null
    , duration


#####################
# React Components (needs to be updated)
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  displayName: 'Proposal'

  render : ->
    options = customizations[fetch('/subdomain').name]?.cluster_options?[@proposal.cluster] || {}

    your_opinion = fetch @proposal.your_opinion
    current_user = fetch('/current_user')
    subdomain = fetch '/subdomain'
    @max_description_height = options.collapse_descriptions_at

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    # change to results page if user entered crafting page when it is not permitted
    if @root.proposal_mode == 'crafting' && !(can_opine in [Permission.PERMITTED, Permission.UNVERIFIED_EMAIL, Permission.NOT_LOGGED_IN, Permission.INSUFFICIENT_INFORMATION] || (can_opine == Permission.DISABLED && your_opinion.published))
      @root.proposal_mode = 'results'
      save @root

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in @page.opinions
      window.user_opinions[opinion.user] = opinion

    proposer = fetch(@proposal.user)

    # Description fields are the expandable details that help people drill
    # into the proposal. They are very specific to the type of proposal (e.g. for
    # an LVG ballot measure, one of the fields might be "fiscal impact statement").  
    # We're now storing all these fields in proposal.description_fields
    # as a serialized JSON object of one of the following structures:
    #       [ {"label": "field one", "html": "<p>some details</p>"}, ... ] 
    #       [ {"group": "group name", "items": [ {"label": "field one", "html": "<p>some details</p>"}, ... ]}, ...]
    if !@local.description_fields
      # Deserialize the description fields. 
      # It would be nice if ActiveREST recognized that a field is a serialized data object!
      # This will fail for proposals that are not using the serialized JSON format; 
      # For now, we'll just catch the error and carry on 
      try 
        @local.description_fields = $.parseJSON(@data().description_fields)
        @local.expanded_field = null
      catch
        @local.description_fields = null


    # whether part of the histogram is focused
    hist = fetch('histogram')
    has_histogram_focus = hist.selected_opinions || hist.selected_opinion

    DIV className:'proposal', key:@props.slug, 'data-page':@root.proposal_mode,

      (customizations[subdomain.name]?.ProposalHeader or customizations.default.ProposalHeader)()

      DIV null,
        #description
        DIV 
          style: 
            width: DESCRIPTION_WIDTH
            position: 'relative'
            margin: 'auto'
            marginLeft: if lefty then 300
            #marginRight: if lefty then 0
            fontSize: 16
            marginBottom: 18

          if !@proposal.active
            SPAN style: {display: 'inline-block', color: 'rgb(250, 146, 45)', padding: '4px 0px', marginTop: 10},
              I className: 'fa fa-info-circle', style: {paddingRight: 7}
              'Closed to new contributions at this time.'

          # TODO: now that we're accepting user contributed proposals, we need to SANITIZE the description
          DIV
            className: 'proposal_details'
            style:
              paddingTop: '1em'
              fontSize: 18
              position: 'relative'
              maxHeight: if @local.description_collapsed then @max_description_height
              overflowY: 'hidden'
            if @local.description_collapsed
              DIV
                style:
                  backgroundColor: 'white'
                  backgroundColor: '#f9f9f9'
                  width: '100%'
                  position: 'absolute'
                  bottom: 0
                  textDecoration: 'underline'
                  cursor: 'pointer'
                  paddingTop: 10
                  paddingBottom: 10
                  fontWeight: 600
                  textAlign: 'center'
                onMouseDown: => @local.description_collapsed = false; save(@local)
                'Expand full text'
            SPAN dangerouslySetInnerHTML:{__html: @proposal.description}


          if @local.description_fields
            DIV style: {marginTop: '1em'},
              for item in @local.description_fields
                if item.group
                  @renderDescriptionFieldGroup item
                else
                  @renderDescriptionField item

          if permit('update proposal', @proposal) > 0
            DIV null,
              A 
                style: {color: '#888'}
                onClick: => window.app_router.navigate("#{@proposal.key}/edit", {trigger: true})
                'Edit'
              A 
                style: {color: '#888', padding: 10, backgroundColor: if @local.edit_roles then '#fafafa' else 'transparent'}
                onClick: => 
                  @local.edit_roles = !@local.edit_roles
                  save @local
                'Share'

              if permit('delete proposal', @proposal) > 0
                A
                  style: {color: '#888'}
                  onClick: => 
                    if confirm('Delete this proposal forever?')
                      destroy(@proposal.key)
                      window.app_router.navigate("/", {trigger: true})
                  'Delete'

          if @local.edit_roles
            DIV 
              style:
                width: BODY_WIDTH
                margin: 'auto'
                backgroundColor: '#fafafa'
                padding: '10px 60px'
                marginLeft: (if lefty then 0)
              ProposalRoles key: @proposal
            
        #feelings
        DIV
          style:
            width: BODY_WIDTH
            margin: '0 auto'
            marginLeft: if lefty then 300
            position: 'relative'
          Histogram()

        #reasons
        DIV 
          className:'reasons_region'
          style : 
            width: REASONS_REGION_WIDTH            
            position: 'relative'
            margin: '48px auto 4em auto'
            marginLeft: if lefty then 65


          if has_histogram_focus
            DIV 
              style: 
                width: BODY_WIDTH + 80
                border: "3px solid #{if !has_histogram_focus then 'transparent' else if @root.selected_point then '#ccc' else focus_blue }"
                height: '100%'
                position: 'absolute'
                borderRadius: 16
                marginLeft: if lefty then 200 else -BODY_WIDTH/2 - 40
                left: if lefty then 0 else '50%'
                top: 18

              Bubblemouth {target: 'histogram'}

          #community cons
          CommunityPoints { key: 'cons' }

          DecisionBoard()

          #community pros
          CommunityPoints { key: 'pros' }


      if your_opinion.published && customizations[subdomain.name]?.ThanksForYourOpinion && @root.proposal_mode == 'results'
        customizations[subdomain.name].ThanksForYourOpinion()

  componentDidUpdate : ->
    $el = $(@getDOMNode())

    # Resizing the reasons region to solve a layout error when 
    # the height of the decision board (which is absolutely positioned) 
    # is taller than either of the wing point columns
    $el.find('.reasons_region').css {minHeight: $el.find('.opinion_region').height()} 


  componentDidMount : ->
    if (@max_description_height and @local.description_collapsed == undefined \
        and $('.proposal_details').height() > @max_description_height)
      @local.description_collapsed = true; save(@local)

    # when you go from homepage to a proposal, seek to proposal description
    # top, otherwise you can be stuck in the middle of the proposal. 
    # $('.proposal').moveToTop()   # Disabled until we resolve https://github.com/tkriplean/ConsiderIt/commit/0561b9bdb6ae03705c3718d2283d8d8345fad632

  renderDescriptionField : (field) ->
    DIV 
      className: 'description_field'
      key: field.label
      style: {padding: '.25em 0'}

      DIV 
        style: {cursor: 'pointer'}
        onClick: => 
          field.expanded = !field.expanded
          save(@local)
          if field.expanded 
            window.writeToLog
              what: 'expand proposal description'
              details: 
                description_type: field.label        
        SPAN 
          className: "fa #{if field.expanded then 'fa-minus-circle' else 'fa-plus-circle'}" 
          style: 
            opacity: .7
            position: 'relative'
            left: -4
            paddingRight: 6

        SPAN 
          style: {lineHeight: 1.6, fontSize: 18}
          field.label

      if field.expanded
        DIV 
          style: 
            padding: '10px 0'
            width: 700
            overflow: 'hidden'
          dangerouslySetInnerHTML:{__html: field.html}

  renderDescriptionFieldGroup : (group) -> 
    DIV 
      className: 'description_group'
      key: group.group,
      style: 
        position: 'relative'
        marginBottom: 10
        borderLeft: '1px solid #e1e1e1'
        paddingLeft: 20
        left: -20

      DIV 
        style: 
          position: 'absolute'
          width: 200
          left: -217
          textAlign: 'right'
          top: 4
          fontWeight: if browser.high_density_display then 300 else 400

        LABEL null, group.group
      for field in group.items
        @renderDescriptionField field

# TODO: Refactor the below and make sure that the styles applied to the 
#       user generated fields are in sync with the styling in the 
#       wysiwyg editor. 
styles += """
.proposal_details br, .description_field br {
  padding-bottom: 0.5em; }
.proposal_details p, 
.proposal_details ul, 
.description_field ul, 
.proposal_details ol, 
.description_field ol, 
.proposal_details table, 
.description_field p, 
.description_field table {
  margin-bottom: 0.5em; }
.proposal_details td, .description_field td {
  padding: 0 3px; }
.proposal_details li, .description_field li {
  list-style: outside; }
.proposal_details ol li, .proposal_details ol li {
  list-style-type: decimal; }  
.proposal_details ul, .description_field ul,
.proposal_details ol, .description_field ol {
  padding-left: 20px;
  margin-left: 20px; }
.proposal_details a, .description_field a {
  text-decoration: underline; }
.proposal_details blockquote, .description_field blockquote {
  opacity: 0.7;
  padding: 10px 20px; }
.proposal_details table, .description_field table {
  padding: 20px 0px; }
"""

##
# Histogram
#
# Controls the display of the users arranged on a histogram. 
# 
# The user avatars are arranged imprecisely on the histogram
# based on the user's opinion, using a physics simulation. 
#
# The pros and cons can be filtered to specific opinion regions
# (individual and collective). 
# 
##
# The interaction rules: 
#
# Selection
#   * Click on a user in the histogram, show that user's opinion:
#      - Filter decision board points to those included by this user
#      - Show a second, larger image of the user and their name in
#         the region between the histogram and decision board
#   * Click an area of the histogram unoccupied by a user, when 
#     not already in selection mode, to enter selection mode:
#      - Show the collective opinions of the users in that region. 
#         Rerank the points in the decision board accordingly.
#   * Move the mouse in histogram when in group selection mode:
#      - selected opinions dynamically updated based on mouse position 
#      - selection region stays entirely within the histogram 
#   * Drag the edges of the region selection top edge to resize the selection
#
# Deselection
#   * If a single user is selected, clicking anywhere outside of that 
#     user's picture in the histogram or opinion area will deselect
#   * If a region is selected, clicking anywhere except within the 
#     decision board will deselect the region.
#
##
# Selected region background
#   * A selection region background follows the mouse in the histogram if:
#      - we're in group selection mode
#      - we're hovering over the histogram in 
#   * Show a border at the top if in group selection mode
#
# The selection region is imprecise. It defines
# a selection region based on the real values of the users' opinions,
# _not_ the imprecise location of the avatar's position on the 
# histogram. This can cause some confusion as to who will be 
# highlighted. 
#
# Other components can also request that certain users be 
# highlighted in the histogram, though the pros/cons will 
# NOT be filtered as a consequence of the highlighting. 
# This occurs when someone mouses over the inclusion pogs
# for a point. 
#
# State design for histogram:
#
# Global state stored at 'histogram':
#   selection_opinion
#      If set, an opinion key for an avatar that was clicked
#   selected_opinions
#      Array of opinion keys defining the current set of selected opinions. 
#   selected_opinion_value
#      The opinion value around which the current selection is defined  
#   region_selection_width
#      The width of the opinion selection region. 
#   highlighted_users
#      Users that other components want to have highlighted in the 
#      histogram. In the render, this is intersected with the users whose 
#      opinions are selected to determine which avatars are highlighted. 
#   avatar_size
#      The base size of the avatars, as determined by the physics 
#      simulation. This piece of state would be local, but it needs
#      to be settable from the physics simulation.
#   dragging
#      Whether the user is currently dragging the mouse through the
#      histogram. 
#
# Local state: 
#   simulation_opinion_hash
#      Hash of all opinion stances. Used to determine if the physics
#      simulation needs to be rerun on a rerender.
#   mouse_opinion_value
#      Stores the mapped opinion value of the current mouse position
#      within the histogram. 
#   last_selection_via_drag
#      Whether the last time the selection region moved was done by dragging
#      in the histogram. This is used to resolve a technicality with 
#      the order in which mouseUp and mouseClick events are fired. 

Histogram = ReactiveComponent
  displayName : 'Histogram'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render: -> 

    hist = fetch('histogram')
    opinions = fetch('/page/' + @proposal.slug).opinions || []

    # Controls the size of the vertical space at the top of 
    # the histogram that gives some space for users to hover over 
    # the most populous areas
    region_selection_vertical_padding = 30 

    # There are a few avatar styles that might be applied depending on state:
    # 1) Regular, for when no user is selected
    regular_avatar_style =
      width: hist.avatar_size
      height: hist.avatar_size
    # 2) The style of a selected avatar
    selected_avatar_style = _.extend {}, regular_avatar_style, 
      zIndex: 9
      backgroundColor: focus_blue
    css.crossbrowserify selected_avatar_style
    # 3) The style of an unselected avatar when some other avatar(s) is selected
    unselected_avatar_style = _.extend {}, regular_avatar_style, 
      opacity: .2
      WebkitFilter: 'grayscale(100%)'
      filter: 'grayscale(100%)'
    # 4) The style of the avatar on the crafting page
    crafting_page_avatar_style = _.extend {}, unselected_avatar_style, 
      opacity: .1

    # highlighted users are the users whose avatars are colorized and fully opaque in the histogram.
    # It is based on the current opinion selection and the highlighted_users state, 
    # which can be manipulated by other components. 
    highlighted_users = hist.highlighted_users
    selected_users = if hist.selected_opinion then [hist.selected_opinion] else hist.selected_opinions
    if selected_users
      if highlighted_users
        highlighted_users = _.intersection highlighted_users, (fetch(o).user for o in selected_users)
      else 
        highlighted_users = (fetch(o).user for o in selected_users)

    # whether to show the shaded opinion selection region in the histogram
    draw_selection_area = !hist.selected_opinion && 
                            @root.proposal_mode == 'results' &&
                            ((!@local.touched && hist.selected_opinions) || 
                              (@local.mouse_opinion_value && !@local.hoving_over_avatar)) 

    DIV 
      className: 'histogram'
      style: 
        width: BODY_WIDTH
        height: HISTOGRAM_HEIGHT + region_selection_vertical_padding
        position: 'relative'

      onClick: @onClick
      onMouseMove: @onMouseMove
      onMouseLeave: @onMouseLeave
      onMouseUp: @onMouseUp
      onMouseDown: @onMouseDown

      onTouchStart: (ev) => 
        ev.preventDefault()
        @onClick(ev)
        hist.dragging = true
        @local.touched = true
        save hist
        save @local

      onTouchMove: (ev) => ev.preventDefault(); @onMouseMove(ev)
      onTouchEnd: (ev) => ev.preventDefault(); @onMouseUp(ev)
      onTouchCancel: (ev) => ev.preventDefault(); @onMouseUp(ev)

      # A little padding at the top to give some space for selecting
      # opinion regions with lots of people stacked high      
      DIV style: {height: region_selection_vertical_padding}

      # Draw the poles of the slider
      DIV 
        key: 'opposers'
        className: "slider_pole_label"

        style: 
          left: -160
          width: 145 
        SPAN null,
          sliderPole((if @root.proposal_mode == 'crafting' then 'individual' else 'group'), 'oppose') 

      DIV 
        key: 'supporters'
        className: "slider_pole_label"
        style: 
          right: -160
          width: 130
        SPAN null,
          sliderPole((if @root.proposal_mode == 'crafting' then 'individual' else 'group'), 'support') 


      # Draw the opinion selection area + region resizing border
      if draw_selection_area
        anchor = hist.selected_opinion_value or @local.mouse_opinion_value
        left = ((anchor + 1)/2 - hist.region_selection_width/2) * BODY_WIDTH
        base_width = hist.region_selection_width * BODY_WIDTH
        selection_width = Math.min(Math.min(base_width, base_width + left), BODY_WIDTH - left)
        selection_left = Math.max 0, left

        DIV null,
          if hist.selected_opinions
            DIV 
              className: 'selection_region_resizer'
              style: 
                borderBottom: "3px solid #{focus_blue}"
                height: 15
                width: selection_width
                position: 'absolute'
                left: selection_left
                top: -15
                cursor: 'col-resize'


          DIV 
            style:
              height: HISTOGRAM_HEIGHT + region_selection_vertical_padding
              position: 'absolute'
              width: selection_width
              backgroundColor: "rgb(246, 247, 249)"
              cursor: 'pointer'
              left: selection_left
              top: 0

            if !hist.selected_opinions
              DIV
                style:
                  fontSize: 12
                  textAlign: 'center'
                  whiteSpace: 'nowrap'
                  marginTop: -18
                  userSelect: 'none'
                  pointerEvents: 'none'

                'Select these opinions'

      # Draw the avatars in the histogram. Placement will be determined later
      # by the physics sim
      DIV 
        ref: 'histo'
        style: 
          height: HISTOGRAM_HEIGHT
          position: 'relative'
          cursor: if @root.proposal_mode == 'results' then 'pointer'

        for opinion in opinions
          user = opinion.user
          fetch(opinion) # subscribe ...

          if highlighted_users
            if _.contains(highlighted_users, opinion.user)   
              avatar_style = selected_avatar_style
            else
              avatar_style = unselected_avatar_style
          else if @root.proposal_mode == 'crafting'
            avatar_style = crafting_page_avatar_style
          else
            avatar_style = regular_avatar_style

          Avatar 
            key: user
            user: user
            hide_tooltip: @root.proposal_mode == 'crafting'
            style: avatar_style


  onClick: (ev) -> 

    ev.stopPropagation()
    hist = fetch('histogram')

    if @root.proposal_mode == 'crafting'
      togglePage('results', 'click_histogram')

    else
      if ev.type == 'touchstart'
        @local.mouse_opinion_value = @getOpinionValueAtFocus(ev)

      opinions = fetch('/page/' + @proposal.slug).opinions || []
      is_clicking_user = ev.target.className.indexOf('avatar') != -1

      if is_clicking_user
        user_key = "/user/#{ev.target.getAttribute('id').substring(7, ev.target.getAttribute('id').length)}"
        user_opinion = _.findWhere opinions, {user: user_key}
        is_deselection = hist.selected_opinion == user_opinion.key && !@local.last_selection_via_drag
        if is_deselection
          hist.selected_opinion = null
        else 
          hist.selected_opinion = user_opinion.key
          hist.selected_opinions = null
      else

        is_deselection = hist.selected_opinions && 
                          !@local.last_selection_via_drag            
        if is_deselection
          hist.selected_opinions = null
          if ev.type == 'touchstart'
            @local.mouse_opinion_value = null
        else
          hist.selected_opinion = null
          hist.selected_opinions = @getOpinionsInCurrentRegion()

      has_selection = hist.selected_opinion || hist.selected_opinions
      hist.selected_opinion_value = if !has_selection then null else if !is_clicking_user then @local.mouse_opinion_value else user_opinion.stance
      @local.last_selection_via_drag = false

      save hist
      save @local


  getOpinionValueAtFocus: (ev) -> 
    # Calculate the mouse_opinion_value (the slider value about which we determine
    # the selection region) based on the mouse offset within the histogram element.
    h_x = @getDOMNode().getBoundingClientRect().left + window.pageXOffset
    h_w = @getDOMNode().offsetWidth
    m_x = ev.pageX or ev.touches[0].pageX

    2 * (m_x - h_x) / h_w - 1

  onMouseMove: (ev) -> 
    return if fetch('slider').is_moving

    if @root.proposal_mode == 'results'
      hist = fetch('histogram')
      ev.stopPropagation()

      # handle drag resizing selection area
      if hist.dragging
        h_w = @getDOMNode().offsetWidth
        mouse_x = ev.pageX
        change_in_selection_region = 2 * (mouse_x - @local.mouse_x_of_last_resize) / h_w
        hist.region_selection_width += change_in_selection_region
        hist.region_selection_width = Math.min(1, Math.max(.03, hist.region_selection_width))
        @local.mouse_x_of_last_resize = mouse_x
        @local.last_selection_via_drag = true
        save @local
        save hist
      else if $(ev.target).closest('.selection_region_resizer').length == 0
        @local.hoving_over_avatar = ev.target.className.indexOf('avatar') != -1
        @local.mouse_opinion_value = @getOpinionValueAtFocus(ev)

        if @local.mouse_opinion_value + hist.region_selection_width >= 1
          @local.mouse_opinion_value = 1 - hist.region_selection_width
        else if @local.mouse_opinion_value - hist.region_selection_width <= -1
          @local.mouse_opinion_value = -1 + hist.region_selection_width
        
        # dynamic selection on drag
        if hist.selected_opinions &&
            @local.mouse_opinion_value # this last conditional is only for touch interactions
                                       # where there is no mechanism for "leaving" the histogram
          hist.selected_opinions = @getOpinionsInCurrentRegion()
          hist.selected_opinion_value = @local.mouse_opinion_value 
          save hist

        save @local

  onMouseLeave: (ev) -> 
    return if fetch('slider').is_moving
    @local.mouse_opinion_value = null
    save @local

  onMouseUp: (ev) -> 
    return if fetch('slider').is_moving
    hist = fetch('histogram')     
    
    if hist.dragging
      hist.dragging = false
      save hist

  onMouseDown: (ev) -> 
    return if fetch('slider').is_moving
    ev.stopPropagation()

    hist = fetch('histogram')
    if $(ev.target).closest('.selection_region_resizer').length > 0 && hist.selected_opinions      
      hist.dragging = true
      @local.mouse_x_of_last_resize = ev.pageX
      save hist

    return false 
      # The return false prevents text selections
      # of other parts of the page when dragging
      # the selection region around.


  getOpinionsInCurrentRegion : -> 
    # return the opinions whose stance is within +/- region_selection_width 
    # of the moused over area of the histogram
    hist = fetch('histogram')
    all_opinions = fetch('/page/' + @proposal.slug).opinions || []    
    selected_opinions = (o.key for o in all_opinions when o.stance <= @local.mouse_opinion_value + hist.region_selection_width && o.stance >= @local.mouse_opinion_value - hist.region_selection_width)
    selected_opinions

  attach_mini_histo: ->
    # We only need to rerun the sim if the distribution of stances has changed. 
    opinions = fetch('/page/' + @proposal.slug).opinions || []

    # We round the stance to two decimals to avoid more frequent recalculations than necessary
    # (one way this happens is with the server rounding opinion data differently than the javascript
    #  does when moving one's slider)
    simulation_opinion_hash = JSON.stringify( _.map(opinions, (o) => Math.round(fetch(o.key).stance * 100) / 100 ) )

    if @refs && @refs.histo && simulation_opinion_hash != @local.simulation_opinion_hash
      page = fetch('/page/' + @proposal.slug)
      histo = @refs.histo.getDOMNode()
      icons = histo.childNodes
      opinions = for opinion, i in page.opinions
        {stance: opinion.stance, icon: icons[i]}
      mini_histo(BODY_WIDTH, HISTOGRAM_HEIGHT, histo, opinions)
      @local.simulation_opinion_hash = simulation_opinion_hash
      save @local

  componentDidMount: -> @attach_mini_histo()
  componentDidUpdate: -> @attach_mini_histo()



styles += """
.histogram {
  user-select: none; -moz-user-select: none; -webkit-user-select: none;-ms-user-select: none;
}
.slider_pole_label {
  position: absolute;
  font-size: 30px;
  bottom: -20px;
  pointer-events: none; 
  user-select: none; -moz-user-select: none; -webkit-user-select: none;-ms-user-select: none;}
  .slider_pole_label span {
    position: absolute;
    bottom: 0; }

.histogram .avatar {
  background-color: #{default_avatar_in_histogram_color}; 
  position: absolute;
  cursor: pointer;}

"""

# Used by the SimpleHomepage to create the small histogram for each proposal summary
MiniHisto = ReactiveComponent
  displayName: 'mini_histo'
  render: ->
    options = customizations[fetch('/subdomain').name]?.cluster_options?[@props.proposal.cluster] || {}
    filter_func = options.homie_histo_filter

    # We'll only pass SOME opinions to the histogram
    @opinions = fetch('/page/' + @props.proposal.slug).opinions
    @opinions = (opinion for opinion in @opinions when \
                 not filter_func or filter_func(fetch(opinion.user)))

    icons = for opinion in @opinions
      neutral = Math.abs(opinion.stance) < .1
      Avatar
        key: opinion.user
        user: opinion.user
        style:
          position: 'absolute'
          backgroundColor: '#d3d3d3'
          # filter:           if not @local.hover then 'grayscale(1)'
          # '-webkit-filter': if not @local.hover then 'grayscale(1)'
          # opacity:          if not @local.hover then .5
          # border:  if neutral then 'solid 1px black'
          # opacity: if neutral then .2

    DIV
      style:
        height: @props.height
        width: @props.width
        position: 'relative'
        borderBottom: '1px solid #999'
        display: if icons.length == 0 then 'none'
      # onMouseEnter: => @local.hover = true;  save(@local)
      # onMouseLeave: => @local.hover = false; save(@local)
      SPAN
        style:
          position: 'absolute'
          left: -21
          bottom: -12
          fontSize: 19
          fontWeight: 500
          color: '#999'
        'â€“'
      SPAN
        style:
          position: 'absolute'
          right: -21
          bottom: -13
          fontSize: 19
          fontWeight: 500
          color: '#999'
        '+'
      DIV
        ref: 'histo'
        icons

  attach_mini_histo: ->
    if @refs and @refs.histo and not @mounted
      page = fetch('/page/' + @props.proposal.slug)
      histo = @refs.histo.getDOMNode()
      icons = histo.childNodes
      opinions = for opinion, i in @opinions
        {stance: opinion.stance, icon: icons[i]}
      mini_histo(@props.width, @props.height-1, histo, opinions)
      @mounted = true
  componentDidMount: ->
    @attach_mini_histo()
  componentDidUpdate: ->
    @attach_mini_histo()
  componentWillUnmount: ->
    @mounted = false




##
# Slider
# Manages the slider and the UI elements attached to it. 
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  # Kick off sliding 
  handleMouseDown: (e) -> 
    el = @getDOMNode()
    # Dragging has to start by dragging the slider handle
    return if !$(e.target).is('.the_handle')

    e.preventDefault()

    # Initiate dragging
    slider = fetch('slider')
    slider.is_moving = true
    slider.offsetX = e.clientX or e.touches[0].clientX

    slider.startX = parseInt($(e.target)[0].style.left, 10) || 0
    save slider

    $(window).on "mousemove.slider", @handleMouseMove
    $(window).on "mouseup.slider", @handleMouseUp

  # Stop sliding
  handleMouseUp: (e) ->
    # Don't do anything if we're not actually dragging. We only hit this logic
    # if there is some delay in removing the event handlers.
    slider = fetch 'slider'

    return if !slider.is_moving

    e.preventDefault()

    your_opinion = fetch(@proposal.your_opinion)
    
    # Clicking on the slider handle should transition us between crafting <=> results. 
    # We should also transition to crafting when we've been dragging on the results page. 
    if slider.stance == your_opinion.stance || @root.proposal_mode == 'results'
      new_page = if @root.proposal_mode == 'results' then 'crafting' else 'results'
      togglePage new_page, 'click_slider'
      e.stopPropagation()

    # We save the slider's position to the server only on mouse-up.
    # This way you can drag it with good performance.
    if your_opinion.stance != slider.stance
      your_opinion.stance = slider.stance
      save your_opinion
      window.writeToLog 
        what: 'move slider'
        details: {stance: slider.stance}

    # Turn off dragging
    slider.is_moving = false
    save slider

    $(window).off ".slider" # Remove event handlers

  # While sliding
  handleMouseMove: (e) ->
    e.preventDefault() # prevents text selection of surrounding elements

    slider = fetch('slider')

    clientX = e.clientX or e.touches[0].clientX

    # Update position
    slider.clientX = slider.startX + clientX - slider.offsetX
    slider.clientX = 0 if slider.clientX < 0
    slider.clientX = @props.width if slider.clientX > @props.width
    slider.has_moved = true

    # convert position of handle to a slider value on [1, -1]
    slider.stance = slider.clientX / @props.width * 2 - 1

    save slider


  render : ->

    stanceLabel = (stance) -> 
      subdomain = fetch('/subdomain')
      if isNeutralOpinion(stance)
        "are Undecided"
      else 

        degree = Math.abs(stance)
        strength_of_opinion = if degree > .999
                                "Fully "
                              else if degree > .5
                                "Firmly "
                              else
                                "Slightly " 
        valence = sliderPole('individual', if stance > 0 then 'support' else 'oppose')

        "#{strength_of_opinion} #{valence}"


    slider = fetch('slider')
    hist = fetch('histogram')

    # Update the slider position when the server gets back to us
    your_opinion = fetch(@proposal.your_opinion)

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    enable_opining = !(hist.selected_opinions || hist.selected_opinion) &&
                      (can_opine in [Permission.PERMITTED, Permission.UNVERIFIED_EMAIL, Permission.NOT_LOGGED_IN, Permission.INSUFFICIENT_INFORMATION] || 
                        (can_opine == Permission.DISABLED && your_opinion.published) )

    if slider.stance != your_opinion.stance and !slider.is_moving
      slider.stance = your_opinion.stance
      slider.clientX = @props.width * (slider.stance / 2 + .5)
      if your_opinion.stance
        slider.has_moved = true
      save(slider)

    page = @root.proposal_mode
    sticky = fetch('decisionboard').sticky
    stance = slider.stance

    # Can't be dynamically set b/c of integration with asset fingerprinting. 
    # This is also why this file is ERB.
    bubblemouth_srcs = 
      neutral : {crafting: "<%= asset_path 'bubblemouth_neutral-crafting.png' %>", results: "<%= asset_path 'bubblemouth_neutral-results.png' %>"}
      other : {crafting: "<%= asset_path 'bubblemouth-crafting.png' %>", results: "<%= asset_path 'bubblemouth-results.png' %>"}

    bubblemouth_src = if isNeutralOpinion(slider.stance) then bubblemouth_srcs['neutral'][page] else bubblemouth_srcs['other'][page]

    eye_style = 
      backgroundColor: 'white'
      top: 6
      width: 3
      height: 3
      transform: "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_mouth_style = 
      bottom: -1
      width: SLIDER_HANDLE_SIZE - 4
      left: 2
      height: SLIDER_HANDLE_SIZE - 4
      boxShadow: '3px 3px 0 0 white'
      transform: 
        "scale(#{.4 + .3 * Math.abs(stance) }, #{.08 + .4 * stance}) 
         translate(0, #{-2 - 5 * Math.abs(stance)}px) 
         rotate(45deg)"

    css.crossbrowserify sty for sty in [eye_style, face_mouth_style]
    _.extend(face_part, {position: 'absolute', pointerEvents: 'none', borderRadius: '50%' }) for face_part in [eye_style, face_mouth_style]

    if @root.proposal_mode == 'crafting'
      # Slider feedback
      slider_feedback = if !slider.has_moved then 'Slide Your Overall Opinion' else "You #{stanceLabel(slider.stance)}"
      feedback_style = 
        pointerEvents: 'none' # clicking on feedback interferes with slider and toggle state
        fontSize: if sticky then 18 else 29
        fontWeight: 700
        color: focus_blue

      # Keep feedback centered over handle, but keep within the bounds of the slider region 
      # when the slider is in an extreme position. 
      feedback_left = @props.width * (stance/2 + .5)
      feedback_width = widthWhenRendered slider_feedback, feedback_style

      if sticky 
        if slider.stance > 0
          feedback_left = Math.min(@props.width - feedback_width/2, feedback_left)
        else
          feedback_left = Math.max(feedback_width/2, feedback_left)

      _.extend feedback_style, 
        position: 'absolute'      
        top: if sticky then -38 else -80      
        left: feedback_left
        marginLeft: -feedback_width / 2
        width: feedback_width


    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point =  selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)

    slider_base_style = 
      width: @props.width
      height: 6
      backgroundColor: if page == 'crafting' then '#AFD7FF' else '#787878'

    handle_style =
      boxShadow: "0px 1px 0px black, inset 0 1px 2px rgba(255,255,255, .4), 0px 0px 0px 1px #{focus_blue}"            
      backgroundColor: focus_blue      
      left: slider.clientX
      zIndex: 10
      borderRadius: '50%'
      width: if can_opine != Permission.INSUFFICIENT_PRIVILEGES then SLIDER_HANDLE_SIZE else 0
      height: if can_opine != Permission.INSUFFICIENT_PRIVILEGES then SLIDER_HANDLE_SIZE else 0
      marginLeft: -SLIDER_HANDLE_SIZE / 2
      top: -9
      position: 'relative'

    css.crossbrowserify handle_style

    bubblemouth_style = {left: slider.clientX}

    if selected_point
      handle_style.backgroundColor = "#ccc"
      handle_style.boxShadow = "0px 1px 0px #aaa"
      slider_base_style.backgroundColor = "#ddd"
      bubblemouth_style.visibility = 'hidden' # TODO: use grayscale filter when !selected_wing_point instead of hiding

    DIV 
      className: 'slider'
      style : 
        left: - (@props.width - DECISION_BOARD_WIDTH) / 2 + 2
        position: 'absolute'
        top: -48
        margin: 'auto'
      DIV 
        className:'slider_base'
        style : slider_base_style

        if @root.proposal_mode == 'crafting'
          DIV 
            style: feedback_style
            slider_feedback


        if enable_opining
          [DIV 
            className: 'the_handle' 
            onMouseUp: @handleMouseUp
            onTouchEnd: @handleMouseUp
            onTouchCancel: @handleMouseUp

            onMouseDown: @handleMouseDown
            onTouchStart: @handleMouseDown

            onTouchMove: @handleMouseMove
            style: handle_style

            if page == 'crafting'
              DIV className: 'face',            
                DIV 
                  className: 'face_mouth'
                  style: face_mouth_style
                DIV 
                  className: 'face_eye'
                  style: _.extend {}, eye_style,
                    left: 6
                DIV 
                  className: 'face_eye'
                  style: _.extend {}, eye_style,
                    right: 6

            if page == 'crafting' && !slider.has_moved
              [DIV 
                className: 'drag_arrow'
                style: 
                  right: -15
                  position: 'absolute'
                  top: 3
                  color: focus_blue
                  fontSize: 12              
                '>' 
              DIV 
                className: 'drag_arrow'
                style: 
                  left: -15
                  position: 'absolute'
                  top: 3
                  color: focus_blue
                  fontSize: 12                
                '<']

          IMG className:'bubblemouth', src: bubblemouth_src, style: bubblemouth_style
          ]

styles += """
#{css.grab_cursor('.the_handle')}

.bubblemouth {
  position: absolute;
  width: 18px;
  pointer-events: none;
  z-index: 10;
  margin-left: -#{SLIDER_HANDLE_SIZE/2}px; }

"""


##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')
    hist = fetch('histogram')
    
    your_opinion = fetch(@proposal.your_opinion)

    register_dependency = fetch('slider').clientX #to keep bubble mouth in sync with slider

    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point = selected_point && !_.contains(your_opinion.point_inclusions, @root.selected_point)
    
    decision_board_style =
      borderRadius: 16
      borderStyle: 'dashed'
      borderWidth: 3
      borderColor: focus_blue


    if @local.user_hovering_on_drop_target
      decision_board_style.borderStyle = 'solid'

    if @root.proposal_mode == 'results'
      _.extend decision_board_style,
        borderStyle: 'solid'
        backgroundColor: focus_blue
        boxShadow: '0px 2px 0px black'
        cursor: 'pointer'

    if selected_wing_point
      decision_board_style.filter = 'grayscale(1)'
      decision_board_style['-webkit-filter'] = 'grayscale(1)'
      decision_board_style.opacity = '.4'
    else if selected_point
      decision_board_style.borderColor = "#ccc"

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    enable_opining = can_opine != Permission.INSUFFICIENT_PRIVILEGES && 
                      (can_opine != Permission.DISABLED || your_opinion.published ) && 
                      !(hist.selected_opinions || hist.selected_opinion)
    DIV 
      className:'opinion_region'
      style: 
        position: 'absolute'
        width: DECISION_BOARD_WIDTH
        zIndex: 0 #so that points being dragged are above opinion region
        display: 'inline-block'
        verticalAlign: 'top'

      Slider
        width: HISTOGRAM_WIDTH - 10


      if enable_opining
        # only shown during results, but needs to be present for animation
        if @root.proposal_mode == 'results'
          give_opinion_style = 
            display: 'block'
            color: 'white'
            padding: '.25em 18px'
            margin: 0
            fontSize: 16
            boxShadow: 'none'
        else
          give_opinion_style = {}

        [DIV 
          className:'decision_board_body'
          style: decision_board_style
          onClick: => if @root.proposal_mode == 'results' then togglePage('crafting', 'give_opinion_button')

          DIV null, 
            # only shown during crafting, but needs to be present always for animation
            DIV 
              className: 'your_points'
              style: 
                padding: '0 18px'
                marginTop: -3 # To undo the 3 pixel border
              YourPoints { key: 'your_con_points', valence: 'cons' }
              YourPoints { key: 'your_pro_points', valence: 'pros' }


            A 
              className: 'give_opinion_button primary_button'
              style: give_opinion_style

              if your_opinion.published 
                'Update your Opinion' 
              else 
                'Give your Opinion'

        DIV className: 'decision_board_footer', 

          # Big bold button at the bottom of the crafting page
          DIV 
            className:'save_opinion_button primary_button'
            onClick: => 
              your_opinion = fetch(@proposal.your_opinion)
              if can_opine > 0
                your_opinion.published = true
                save your_opinion
                togglePage('results', 'save_button')
              else
                if can_opine == Permission.UNVERIFIED_EMAIL
                  auth_form = 'verify email'
                  current_user.trying_to = 'send_verification_token'
                  save current_user
                else if can_opine == Permission.INSUFFICIENT_INFORMATION
                  auth_form = 'user questions'
                else
                  auth_form = 'create account'

                @root.auth = {form: auth_form, goal: 'Save your Opinion', ask_questions: true}

                # We'll need to publish this opinion after auth is completed
                @root.opinions_to_publish.push(@proposal.your_opinion)

                save @root

            if your_opinion.published 
              'See the results' 
            else 
              'Save your opinion and see results'

          if @root.proposal_mode == 'crafting'
            A 
              style: 
                marginTop: '.5em'
                padding: 3
                display: 'inline-block'

              INPUT
                type:      'checkbox'
                id:        "follow_proposal"
                name:      "follow_proposal"
                checked:   @proposal.is_following
                style: 
                  fontSize: 21
                  cursor: 'pointer'
                onChange: =>
                  @proposal.is_following = !@proposal.is_following
                  save @proposal
              LABEL 
                htmlFor: "follow_proposal"
                title:'We\'ll send periodic email notifications summarizing activity on the proposal, as well as alerts about new pro and con points. You can easily unsubscribe later.'
                style: 
                  marginLeft: 6
                  fontSize: 16
                  color: '#888'
                  cursor: 'pointer'   
                'Notify me about new activity'

          if !your_opinion.published
            A 
              className:'cancel_opinion_button primary_cancel_button'
              onClick: => togglePage('results', 'cancel_button')
              'or just skip to the results'  
        ]


  componentDidMount : ->
    @setStickyHeader()

    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = fetch(@proposal.your_opinion)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)

            window.writeToLog
              what: 'included point'
              details: 
                point: ui.draggable.parent().data('id')

          @local.user_hovering_on_drop_target = false
          save @local

      out : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = false
          save @local

      over : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = true
          save @local

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.StickyElement('destroy')

  componentDidUpdate : -> 
    $el = $(@getDOMNode())    
    root = fetch('root')

    # hack to get around a problem where the browser's remembered scroll position messes
    # up the sticky location after initialization
    if !@initial_position_fixed
      $el.StickyElement('fix_initial_position')
      @initial_position_fixed = true
    else if root.proposal_mode == 'results' #fix problem where it would stay sticky moving to results page
      $el.StickyElement('update')

  setStickyHeader : ->
    $el = $(@getDOMNode())

    slider_region_height =  115

    $el.StickyElement
      container: $('.reasons_region')
      top_offset: $('.proposal_heading').outerHeight() + slider_region_height
      bottom_offset: 20
      unsticks: =>
        d = @data()
        d.sticky = false
        save(d)
      sticks: =>
        d = @data()
        d.sticky = true
        save(d)
      conditional: => 
        @root.proposal_mode == 'crafting'


##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  render : ->
    included_points = fetch(@proposal.your_opinion).point_inclusions    
    left_or_right = if @props.valence == 'pros' then 'right' else 'left'

    can_add_new_point = permit 'create point', @proposal

    your_points = @data @props.key,
      editing_points : []
      adding_new_point : false

    DIV 
      className:"points_on_decision_board #{@props.valence}_on_decision_board"
      style: 
        width: POINT_WIDTH
        marginTop: 28

      DIV 
        className:'points_heading_label'
        style: 
          fontWeight: 700
          color: focus_blue
        "Give Your #{capitalize(@props.valence)}"

      UL null,
        for point in included_points

          if fetch(point).is_pro == (@props.valence == 'pros')
            if point in your_points.editing_points
              EditPoint { key: point, fresh: false, valence: @props.valence, your_points_key: @props.key }
            else
              Point { key: point, rendered_as: 'decision_board_point', your_points_key: @props.key }

        #drop target
        DIV 
          style: 
            padding: '0 0 .25em 9px'
            position: 'relative'

          IMG 
            src: "<%= asset_path 'drop_target.png' %>"
            style: css.crossbrowserify
              transform: if @props.valence == 'cons' then '' else 'scaleX(-1)'
              width: 223

          SPAN 
            style:
              fontSize: 14
              position: 'absolute'
              top: '1.4em'
              left: if @props.valence == 'cons' then 36 else 29
              width: 180

            "Drag a #{capitalize(if @props.valence=='pros' then 'pro' else 'con')} from the #{left_or_right}"

        if can_add_new_point != Permission.INSUFFICIENT_PRIVILEGES
          if !your_points.adding_new_point
            DIV 
              style: 
                padding: '.25em 0'
                marginTop: '1em'
                marginLeft: 20
                fontSize: 14

              SPAN 
                style: {fontWeight: if browser.high_density_display then 300 else 400}
                'or '
              SPAN 
                style: {padding: '0 6px'}
                dangerouslySetInnerHTML:{__html: '&bull;'}
              A 
                style:
                  textDecoration: 'underline'
                  color: focus_blue
                onClick: => 
                  if can_add_new_point == Permission.NOT_LOGGED_IN
                    @root.auth = {form: 'create account', goal: 'write a point'}
                    save @root
                  else if can_add_new_point == Permission.UNVERIFIED_EMAIL
                    @root.auth = {form: 'verify email', goal: 'write a point'}
                    save @root
                    current_user.trying_to = 'send_verification_token'
                    save current_user

                  else
                    your_points.adding_new_point = true
                    save your_points

                  writeToLog {what: 'click new point'}

                "Write a new #{capitalize(if @props.valence == 'pros' then 'pro' else 'con')}"

          else
            EditPoint { key: "new_point_#{@props.valence}", fresh: true, valence: @props.valence, your_points_key: @props.key }

styles += """
.points_by_community, .points_on_decision_board {
  display: inline-block;
  vertical-align: top; }

.points_heading_label {
  text-align: center;
  margin-bottom: 18px;
  margin-top: 7px;
  font-size: 30px; }

"""


##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting
  render : ->

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key
    con_is_selected = @root.selected_point and not fetch(@root.selected_point).is_pro

    # TODO: The minheight below is not a principled or complete solution to two sizing issues: 
    #           1) resizing the reasons region when the height of the decision board 
    #              (which is absolutely positioned) grows taller the wing points
    #           2) when filtering the points on result page to a group of opinions with few inclusions,
    #              the document height can jarringly fluctuate
    DIV
      className: "points_by_community #{@props.key}_by_community"
      style:
        width: POINT_CONTENT_WIDTH
        minHeight: (if @page.points.length > 4 then jQuery(window).height() else 400)
        zIndex: if con_is_selected and @props.key == 'cons' then 6 else 2
        margin: '38px 18px 0 18px'
        position: 'relative'

      DIV 
        className:'points_heading_label'
        style: 
          position: 'relative'
          #fontWeight: if browser.high_density_display then 300 else 400
          left: if @props.key == 'cons' then -20 else 20
            # Mike: I wanted the headers to be centered over the ENTIRE
            # points including avatars, not just bubbles.  But the
            # avatars are sticking out on their own, so I simulated
            # a centered look with these -20px and +20px offsets

        if fetch('root').proposal_mode == 'results' then "Top #{label}" else "Others' #{label}"

      UL null,
        if points.length > 0
          for point in points
            Point
              key: point.key,
              is_new: Date.parse(point.created_at) > newpoint_threshold
              rendered_as : 'community_point'
        else
          LI 
            style: 
              marginTop: 50
              fontStyle: 'italic'
              listStyle: 'none'
              textAlign: 'center'
              fontWeight: if browser.high_density_display then '300' else '400'

            "No #{label} listed"

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @page.points || []
    newpoint_threshold = 
      (_.sortBy points, (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = fetch('root').proposal_mode == 'results'
    hist = fetch('histogram')

    selected_opinions = if hist.selected_opinion then [hist.selected_opinion] else hist.selected_opinions

    included_points = fetch(@proposal.your_opinion).point_inclusions
    points = @page.points
    opinions = @page.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_opinions
      # Filter down to the points included in the selection opinions, and 
      # order them by resonance to those users.

      point_inclusions_per_point = {} # map of points to including users
      _.each selected_opinions, (opinion_key) =>
        opinion = fetch(opinion_key)
        if opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point)
              point_inclusions_per_point[point] = 1
            else
              point_inclusions_per_point[point] += 1

      points = (pnt for pnt in points when pnt.key of point_inclusions_per_point)
      points = _.sortBy points, (pnt) -> -point_inclusions_per_point[pnt.key]
    else
      # Default sort order
      points = _.sortBy points, (pnt) => - if is_results then pnt.score else pnt.last_inclusion

    points

styles += """

"""


##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  render : ->
    point = @data()

    is_selected = @root.selected_point == @props.key

    current_user = fetch('/current_user')


    renderIncluders = (draw_all_includers) =>

      if @data().includers

        if !draw_all_includers
          includers = [point.user]
        else 
          includers = @buildIncluders()

        s = #includers_style
          rows: 8
          dx: 2
          dy: 5
          col_gap: 8
          side_offset: if @props.rendered_as == 'decision_board_point' then 10 else 47

        if includers.length == 0
          includers = [point.user]

        # Now we'll go through the list from back to front
        i = includers.length

        for includer in includers
          i -= 1
          curr_column = Math.floor(i / s.rows)
          side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
          top_offset = (i % s.rows) * s.dy 
          left_right = if @data().is_pro then 'right' else 'left'
          style = { top: top_offset }
          style[left_right] = -side_offset

          # Finally draw the guys
          Avatar
            key: includer
            className: "point_includer_avatar"
            style: style
            hide_tooltip: @props.rendered_as == 'under_review' 
            anonymous: point.user == includer && point.hide_name

    renderNewIndicator = =>
      if @data().includers
        side_offset = 48
        left_right = if @data().is_pro then 'right' else 'left'
        style = 
          position: 'absolute'
          color: 'rgb(255,22,3)'
          fontSize: '11px'
          top: -14
          #backgroundColor: 'white'
          zIndex: 5
          fontVariant: 'small-caps'
          fontWeight: 'bold'

        style[left_right] = "#{-side_offset}"
        SPAN {style: style}, '-new-'


    point_content_style = { width: POINT_CONTENT_WIDTH }
    if is_selected
      _.extend point_content_style,
        border: "3px solid #{focus_blue}"
        left: -3
        top: -3
        width: point_content_style.width + 6
        backgroundColor: 'white'
        marginBottom: 2

      if @props.rendered_as == 'decision_board_point'
        _.extend point_content_style,
          padding: 8
          borderRadius: 8
          marginTop: -8
          marginLeft: -8
          width: point_content_style.width + 16

    if @props.rendered_as == 'under_review'
      _.extend point_content_style, {width: 500}


    needs_expansion_to_see_details = point.text && (point.nutshell.length + point.text.length) > 210

    select_enticement = []

    if needs_expansion_to_see_details
      select_enticement.push SPAN key: 1,
        SPAN dangerouslySetInnerHTML: {__html: '&hellip;'}
        ' ('
        A className: 'select_point',
          'read more'
        ')'

    if point.comment_count > 0 || !needs_expansion_to_see_details
      select_enticement.push SPAN key: 2, style: {whiteSpace: 'nowrap'},
        " ("
        A className: 'select_point',
          "#{point.comment_count} comment#{if point.comment_count != 1 then 's' else ''}"
        ")"

    if point.assessment
      select_enticement.push SPAN key: 3,
        I
          className: 'fa fa-search'
          title: 'Click to read a fact-check of this point'
          style: 
            color: '#5E6B9E'
            fontSize: 14
            cursor: 'help'
            paddingLeft: 4


    point_style = 
      position: 'relative'
      listStyle: 'none outside none'

    if @props.rendered_as == 'decision_board_point'
      _.extend point_style, 
        marginLeft: 9
        padding: '0 18px 1em 18px'

    draw_all_includers = @props.rendered_as == 'community_point'
    LI
      className: "point #{@props.rendered_as} #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
      onClick: @selectPoint
      onTouchEnd: @selectPoint
      style: point_style

      if @props.rendered_as == 'community_point' && @props.is_new
        renderNewIndicator()

      DIV className:'includers', onMouseEnter: @highlightIncluders, onMouseLeave: @unHighlightIncluders,
        if @props.rendered_as == 'decision_board_point'
          SPAN 
            style: {position: 'absolute', top: -1, left: -7, fontFamily: 'courier'}
            dangerouslySetInnerHTML:{__html: if point.is_pro then '+' else '-'}
        else
          renderIncluders(draw_all_includers)

      DIV className:'point_content', style : point_content_style,
        if @props.rendered_as == 'community_point' || @props.rendered_as == 'under_review' || is_selected
          IMG
            className: 'community_point_mouth'
            src: if is_selected then "<%= asset_path 'community_point_mouth_selected.png' %>" else "<%= asset_path 'community_point_mouth.png' %>"

        DIV className:'point_nutshell',
          splitParagraphs point.nutshell

          DIV className: "point_details#{if is_selected || @props.rendered_as == 'under_review' then '' else '_tease'}",
            if point.text && point.text.length > 0
              if is_selected || !needs_expansion_to_see_details || @props.rendered_as == 'under_review'
                splitParagraphs(point.text)
              else 
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text()

            if !is_selected && select_enticement && @props.rendered_as != 'under_review'
              select_enticement

        DIV null,
          if permit('update point', point) > 0 && @props.rendered_as == 'decision_board_point'
            A
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8

              onClick: ((e) =>
                e.stopPropagation()
                points = fetch(@props.your_points_key)
                points.editing_points.push(@props.key)
                save(points))
              SPAN null, 'edit'

          if permit('delete point', point) > 0 && @props.rendered_as == 'decision_board_point'
            A 
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8
              onClick: (e) =>
                e.stopPropagation()
                if confirm('Delete this point forever?')
                  destroy @props.key
              SPAN null, 'delete'

      if is_selected
        point_included = _.contains(fetch(@proposal.your_opinion).point_inclusions, point.key)
        Discussion
          key:"/comments/#{point.id}"
          is_pro: point.is_pro
          in_wings: @root.proposal_mode == 'crafting' and not point_included

  componentDidMount : ->
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  componentDidUpdate : -> 
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  # Hack that fixes a couple problems:
  #   - Scroll to the point when following a link from an email notification to a point
  #   - Scroll to new point when scrolled down to bottom of long discussion & click 
  #     a new point below it
  ensureDiscussionIsInViewPort : ->
    if @root.selected_point == @props.key
      $(@getDOMNode()).ensureInView {scroll: false}

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page

    return if @props.rendered_as == 'under_review'

    disable = fetch('root').proposal_mode == 'results'

    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.rendered_as == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = fetch(@proposal.your_opinion)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, @props.key
          save(your_opinion)
          window.writeToLog
            what: 'removed point'
            details: 
              point: @props.key

        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable


  selectPoint: (e) ->
    # android browser needs to respond to this via a touch event;
    # all other browsers via click event. iOS fails to select 
    # a point if both touch and click are handled...sigh...
    return unless browser.is_android_browser || e.type == 'click'

    return if @props.rendered_as == 'under_review'

    e.stopPropagation()

    if @root.selected_point == @props.key # deselect
      @root.selected_point = null
      what = 'deselected a point'
    else
      what = 'selected a point'
      @root.selected_point = @props.key

    save @root

    window.writeToLog
      what: what
      details: 
        point: @props.key


  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  highlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      point = @data()
      includers = point.includers

      # For point authors who chose not to sign their points, remove them from 
      # the users to highlight. This is particularly important if the author 
      # is the only one who "included" the point. Then it is very eash for 
      # anyone to discover who wrote this point. 
      if point.hide_name
        includers = _.without includers, point.user
      hist = fetch 'histogram'
      if hist.highlighted_users != includers
        hist.highlighted_users = includers
        save(hist)

  unHighlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      hist = fetch 'histogram'
      hist.highlighted_users = null
      save(hist)


  buildIncluders : -> 
    point = @data()
    author_has_included = _.contains point.includers, point.user
    to_remove = [point.user]

    includers = point.includers

    hist = fetch('histogram')
    selected_opinions = if hist.selected_opinion then [hist.selected_opinion] else hist.selected_opinions
    if selected_opinions?.length > 0      
      # only show includers from the current opinion selection
      selected_users = (fetch(o).user for o in selected_opinions)
      includers = _.intersection includers, selected_users
      author_has_included = _.contains selected_users, point.user

    includers = _.difference includers, to_remove
    if author_has_included 
      includers.push point.user
    includers
        

styles += """
.community_point_mouth {
  position: absolute;
  width: #{COMMUNITY_POINT_MOUTH_WIDTH}px;
  top: 8px;
  z-index: 1; }

.community_point.con .community_point_mouth, .under_review .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

.community_point.pro .community_point_mouth {
  right: -#{COMMUNITY_POINT_MOUTH_WIDTH}px;
  #{css.crossbrowserify({transform: 'scaleX(-1)'}, true)}; }

.decision_board_point .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

/* war! disabled jquery UI draggable class defined with !important */
.point_content.ui-draggable-disabled {
  cursor: pointer !important; }

#{css.grab_cursor('.point_content.ui-draggable')}

.community_point .point_content, .under_review .point_content {
  border-radius: 16px;
  padding: 0.5em 9px;
  margin-bottom: 0.5em;
  background-color: #f6f7f9;
  box-shadow: #b5b5b5 0 1px 1px 0px;
  min-height: 34px; }

.point_nutshell {
  word-wrap: break-word;
  font-size: 14px; }

.point_details_tease, .point_details {
  margin-top: 0.5em;
  font-size: 14px;
  word-wrap: break-word; 
  font-weight: #{if browser.high_density_display then 300 else 400}; }
  .point_details_tease a, .point_details a {
    text-decoration: underline;
    word-break: break-all; }

.point_details {
  display: block; }

.point_details_tease {
  cursor: pointer; }
  .point_details_tease a.select_point {
    text-decoration: none; }
    .point_details_tease a.select_point:hover {
      text-decoration: underline; }

.point_details p {
  margin-bottom: 1em; }

.point_details p:last-child {
  margin-bottom: 0; }

.point_includer_avatar {
  position: absolute;}

.under_review .point_includer_avatar {
  top: 0px;
  width: 50px;
  height: 50px;
  left: -73px;
  box-shadow: -1px 2px 0 0 #eeeeee; }

.point_includer_avatar {
  width: 22px;
  height: 22px; }

.community_point.con .point_includer_avatar {
  box-shadow: -1px 2px 0 0 #eeeeee; }

.community_point.pro .point_includer_avatar {
  box-shadow: 1px 2px 0 0 #eeeeee; }

.decision_board_point.pro .point_includer_avatar {
  left: -10px; }

"""

Comment = ReactiveComponent
  displayName: 'Comment'

  render: -> 
    comment = @data()

    if comment.editing
      # Sharing keys, with some non-persisted client data getting saved...
      EditComment fresh: false, point: comment.point, key: comment.key

    else

      DIV className: 'comment_entry',

        # Comment author name
        DIV className: 'comment_entry_name',
          fetch(comment.user).name + ':'

        # Comment author icon
        Avatar
          className: 'comment_entry_avatar'
          key: comment.user
          hide_tooltip: true

        # Comment body
        DIV className: 'comment_entry_body',
          splitParagraphs(comment.body)

        # Delete/edit button
        if permit('update comment', comment) > 0
          comment_action_style = 
            color: '#444'
            textDecoration: 'underline'
            cursor: 'pointer',
            paddingRight: 10
          DIV style: { marginLeft: 60}, 
            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                if confirm('Delete this comment forever?')
                  destroy(key)
              'delete'

            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                comment.editing = true
                save comment
              'edit'          

# fact-checks, edit comments, comments...
styles += """
.comment_entry {
  margin-bottom: 45px;
  min-height: 60px;
  position: relative; }

.comment_entry_name {
  font-weight: bold;
  color: #666666; }

.comment_entry_avatar {
  position: absolute;
  width: 50px;
  height: 50px; }

.comment_entry_body {
  margin-left: 60px;
  word-wrap: break-word;
  position: relative; }
  .comment_entry_body a {
    text-decoration: underline; }
  .comment_entry_body strong {
    font-weight: 600; }
  .comment_entry_body p {
    margin-bottom: 1em; }
"""

FactCheck = ReactiveComponent
  displayName: 'FactCheck'

  render : -> 
    assessment = @data()
    DIV className: 'comment_entry',

      # Comment author name
      DIV className: 'comment_entry_name',
        'Seattle Public Library Fact check:'

      # Comment author icon
      DIV className: 'magnifying_glass',
        I className: 'fa fa-search'

      # Comment body
      DIV className: 'comment_entry_body',
        DIV style: {margin: '10px 0 20px 0'},
          "A citizen requested research into the claims made by this point. "
          SPAN style: {fontSize: 12},
            A style: {fontWeight: 700}, href: '/about#fact_check', onClick: clickInternalLink,
              'Learn more'
            ' about the service.'

        for claim in assessment.claims
          claim = fetch(claim.key)
          verdict = fetch(claim.verdict)

          [DIV style: {margin: '10px 0'}, 
            IMG style: {position: 'absolute', width: 25, left: -40}, src: verdict.icon
            'Claim: '
            SPAN style: {fontWeight: 600}, claim.claim_restatement
          DIV null, 
            SPAN null,
              'Rating: '
              SPAN style: {fontStyle: 'italic'}, verdict.name
              SPAN style: {marginLeft: 20, fontSize: 12, textDecoration: 'underline', cursor: 'help'}, title: verdict.desc,  'help'
          DIV style: {margin: '10px 0'}, dangerouslySetInnerHTML:{__html: claim.result}]

styles += """
.magnifying_glass {
  position: absolute;
  width: 50px;
  height: 50px;
  font-size: 50px;
  margin-top: -2px;
  color: #5e6b9e; }
"""

EditComment = ReactiveComponent
  displayName: 'EditComment'

  render : -> 
    permitted = permit 'create comment', @proposal

    DIV className: 'comment_entry',

      # Comment author name
      DIV
        style:
          fontWeight: 'bold'
          color: '#666'
        (fetch('/current_user').name or 'You') + ':'

      # Icon
      Avatar
        style:
          position: 'absolute'
          width: 50
          height: 50
          backgroundColor: if permitted < 0 then 'transparent'
          border:          if permitted < 0 then '1px dashed grey'

        key: fetch('/current_user').user
        hide_tooltip: true

      if permitted == Permission.DISABLED
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Comments closed'

      else if permitted == Permission.INSUFFICIENT_PRIVILEGES
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Sorry, you do not have permission to comment'

      else if permitted < 0
        SPAN
          style:
            position: 'absolute'
            margin: '14px 0 0 70px'
            cursor: 'pointer'

          onClick: =>
            if permitted == Permission.NOT_LOGGED_IN
              @root.auth = {form: 'login', goal: 'Write a Comment'}
            else if permitted == Permission.UNVERIFIED_EMAIL
              @root.auth = {form: 'verify email', goal: 'Write a Comment'}
              current_user.trying_to = 'send_verification_token'
              save current_user

            save(@root)

          if permitted == Permission.NOT_LOGGED_IN
            DIV null,
              SPAN 
                style: { textDecoration: 'underline', color: focus_blue }
                'Log in to write a comment'
              if '*' not in @proposal.roles.commenter
                DIV style: {fontSize: 11},
                  'Only some email addresses are authorized to comment.'

          else if permitted == Permission.UNVERIFIED_EMAIL
            DIV null,
              SPAN
                style: { textDecoration: 'underline', color: focus_blue }
               'Verify your account'
              SPAN null, 'to write a comment'

      AutoGrowTextArea
        className: 'new_comment'
        placeholder: if permitted > 0 then 'Write a new comment' else ''
        disabled: permitted < 0
        onChange: (e) => @local.new_comment = e.target.value; save(@local)
        defaultValue: if @props.fresh then null else @data().body
        min_height: 60
        style:
          marginLeft: 60
          width: 390
          lineHeight: 1.4
          fontSize: 16
          border: if permitted < 0 then 'dashed 1px'

      if permitted > 0
        DIV style: {textAlign: 'right'},
          Button({style: {marginLeft: 314}}, 'Save comment', (e) =>
            e.stopPropagation()
            if @props.fresh
              comment =
                key: '/new/comment'
                body: @local.new_comment
                user: fetch('/current_user').user
                point: "/point/#{@props.point}"
            else
              comment = @data()
              comment.body = @local.new_comment
              comment.editing = false

            save(comment)
            $(@getDOMNode()).find('.new_comment').val(''))


Discussion = ReactiveComponent
  displayName: 'Discussion'

  render : -> 
    
    discussion_style =
      width: DECISION_BOARD_WIDTH
      border: "3px solid #{focus_blue}"
      position: 'absolute'
      zIndex: 100
      padding: '20px 40px'
      borderRadius: 16
      backgroundColor: 'white'

    bubble_mouth_style =
      position: 'absolute'
      top: 14
      width: 27
      height: 63

    # Reconfigure discussion board position
    side = if @props.is_pro then 'right' else 'left'
    if @props.in_wings
      discussion_style[side] = 215
      discussion_style['top'] = 44
    else
      discussion_style[side] = if @props.is_pro then -23 else -30
      discussion_style['marginTop'] = 13

    # Reconfigure bubble mouth position
    if @props.in_wings
      bubble_mouth_style.right = if @props.is_pro then -27       else undefined
      bubble_mouth_style.left  = if @props.is_pro then undefined else -27
    else
      trans_func = 'rotate(270deg)'
      if @props.is_pro
        trans_func += ' scaleY(-1)'

      _.extend bubble_mouth_style,
        left: if @props.is_pro then 335 else 100
        top: -45
        transform:            trans_func
        '-ms-transform':      trans_func
        '-moz-transform':     trans_func
        '-webkit-transform':  trans_func
        '-o-transform':       trans_func
      

    comments = @discussion.comments
    if @discussion.assessment
      comments = comments.slice()
      comments.push @discussion.assessment
      comments.sort (a,b) -> a.created_at < b.created_at

    DIV style: discussion_style, onClick: ((e) -> e.stopPropagation()),
      IMG
        src: "<%= asset_path 'bubblemouth-discussions.png' %>"
        className: if @props.is_pro then '' else 'flipped'
        style: bubble_mouth_style

      H1
        style:
          textAlign: 'left'
          fontSize: 38
          color: focus_blue
          marginLeft: 60
          marginBottom: 25
          marginTop: 24
          fontWeight: 600
        'Discuss this Point'
      
      SubmitFactCheck()

      DIV className: 'comments',
        for comment in comments
          if comment.key.match /(comment)/
            Comment key: comment.key
          else 
            FactCheck key: comment.key

      # Write a new comment
      EditComment fresh: true, point: arest.key_id(@props.key)

  # HACK! Insert a placeholder to add enough height to accommodate the 
  # overlaid point. And if it is a point on the decision board,
  # also add the space to the decision board (so that scrolling
  # to bottom of discussion can occur)
  componentDidUpdate : -> @fixBodyHeight()
  componentDidMount : -> @fixBodyHeight()
  componentWillUnmount : -> @clear_placeholder()
  clear_placeholder : -> 
    $body = $('.reasons_region')
    $body.find('.discussion_placeholder').remove()

  fixBodyHeight : -> 
    @clear_placeholder()

    $body = $('.reasons_region')
    height_of_discussion = $(@getDOMNode()).height()
    placeholder = "<div class='discussion_placeholder' style='height: #{height_of_discussion}px'></div>"
    $body.append(placeholder)
    if $(@getDOMNode()).parents('.opinion_region').length > 0
      $('.decision_board_body').append placeholder

Button = (props, text, callback) ->
  style =
    backgroundColor: focus_blue
    borderRadius: 8
    color: 'white'
    padding: '3px 10px'
    display: 'inline-block'
    fontWeight: 600
    textAlign: 'center'
    cursor: 'pointer'
  props.style = _.extend(style, (props.style or {}))
  props.onClick = callback

  DIV props, text


SubmitFactCheck = ReactiveComponent
  displayName: 'SubmitFactCheck'

  # States
  # - Blank
  # - Clicked request
  # - Contains request from you already
  # - Contains a verdict

  render: ->
    return SPAN(null) if !@proposal.assessment_enabled

    logged_in = fetch('/current_user').logged_in

    request_a_fact_check = =>
      [
        DIV null,
          'You can'
        DIV
          style:
            fontSize: 22
            fontWeight: 600
            textDecoration: 'underline'
            color: '#474747'
            marginTop: -4
            marginBottom: -1
            cursor: 'pointer'
          onClick: (=>
            if @local.state == 'blank slate'
              @local.state = 'clicked'
            else if @local.state == 'clicked'
              @local.state = 'blank slate'
            save(@local))
          'Request a Fact Check'
        DIV null,
          'from The Seattle Public Library'
      ]

    a_librarian_will_respond = (width) =>
      DIV style: {maxWidth: width},
        'A '
        A
          style: {textDecoration: 'underline'}
          href: '/about/#fact_check'
          'librarian will respond'
        ' to your request within 48 hours'

    request_a_factcheck = =>
      if permit('request factcheck', @proposal) > 0
        [
          DIV style: {marginTop: 12},
            'What factual claim do you want researched?'
          AutoGrowTextArea
            className: 'new_request'
            style:
              width: 390
              height: 60
              lineHeight: 1.4
              fontSize: 16
            placeholder: (logged_in and 'Your research question') or ''
            disabled: not logged_in
            onChange: (e) =>
              @local.research_question = e.target.value
              save(@local)
          Button
            style: {float: 'right'}
            onClick => (e) =>
              e.stopPropagation()
              request =
                key: '/new/request'
                suggestion: @local.research_question
                point: "/point/#{arest.key_id(@discussion.key)}"
              save(request)
              $(@getDOMNode()).find('.new_request').val('')
            'submit'

          a_librarian_will_respond(255)
        ]
      else
        DIV
          onClick: =>
            @root.auth = {form: 'login', goal: 'Request a Fact Check'}
            save(@root)
          style:
            marginTop: 14
            textDecoration: 'underline'
            color: focus_blue
            cursor: 'pointer'
          'Log in to request a fact check'


    top_message_style = {maxWidth: 274, marginBottom: 10}
    request_in_progress = =>
      DIV null,
        DIV style: top_message_style,
          'You have requested a Fact Check from The Seattle Public Library'
        a_librarian_will_respond()
          
    request_completed = =>
      overall_verdict = fetch(@discussion.assessment.verdict)

      [
        DIV style: top_message_style,
          'This point has been Fact-Checked by The Seattle Public Library'
        DIV style: {marginBottom: 10},
          switch overall_verdict.id
            when 1
              "They found some claims inconsistent with reliable sources."
            when 2
              "They found some sources that agreed with claims and some that didn't."
            when 3
              "They found the claims to be consistent with reliable sources."
            when 4
              "Unfortunately, the claims made are outside the research scope of the fact-checking service."

        DIV style: {marginBottom: 10},
          A style: {textDecoration: 'underline'},
            ''
          "See the details"
          " of the librarians' research below."
      ]


    # Determine our current state
    @local.state = @local.state or 'blank slate'
    your_requests = (r for r in @discussion.requests or [] \
                     when r.user == fetch('/current_user').user)
    fact_check_completed = @discussion.claims?.length > 0
    if fact_check_completed
      @local.state = 'verdict'
    else if your_requests.length > 0
      @local.state = 'requested'


    show_request = @local.state != 'blank slate'
    
    request_style = if show_request then { marginBottom: 45, minHeight: 60 } else {}

    # Now let's draw
    DIV style: request_style,

      # Magnifying glass
      if show_request

        DIV className: 'magnifying_glass',
          I
            className: 'fa fa-search'

      # Text to the right
      DIV
        style:
          marginLeft: 60
        switch @local.state
          when 'blank slate'
            request_a_fact_check()
          when 'clicked'
            [request_a_fact_check()
            request_a_factcheck()]
          when 'requested'
            request_in_progress()
          when 'verdict'
            request_completed()

##
# EditPoint
# Form for editing or creating a point. Used by NewPoint component & when someone
# edits their point. 
EditPoint = ReactiveComponent
  displayName: 'EditPoint'

  render : ->
    @local = @data @local_key,
      sign_name : if @props.fresh then true else !@data().hide_name
      add_details : false

    textarea_style = 
      width: '100%'
      minHeight: 100
      overflow: 'hidden'
      fontSize: 14

    DIV
      className: 'edit_point'
      style: 
        margin: '0 18px'
        position: 'relative'
        fontSize: 14

      INPUT id:'is_pro', name: 'is_pro', type: 'hidden', value: "#{@props.valence == 'pros'}"
      LABEL 
        htmlFor:'nutshell'
        'Your point'
      CharacterCountTextInput 
        id:'nutshell'
        maxLength:140
        name:'nutshell'
        pattern:'^.{3,}'
        placeholder:'Make this summary succinct.'
        required:'required'
        defaultValue: if @props.fresh then null else @data().nutshell
        style: textarea_style

      
      DIV null,
        A 
          className: 'add_details'
          onClick: =>
            @local.add_details = !@local.add_details
            save(@local)            
          title: 'Provide background and/or back your point up with evidence.'
          style: { fontSize: 14 }

          I className: if @local.add_details then 'fa-caret-down fa' else 'fa-caret-right fa'
          SPAN
            style: {paddingLeft: 6}
            'Expand on your point'

        if @local.add_details
          DIV null, 
            AutoGrowTextArea 
              id:'text'
              name:'text'
              placeholder:'Provide background and/or back your point up with evidence.'
              required:'required'
              min_height: 170
              defaultValue: if @props.fresh then null else @data().text
              style: textarea_style


      if @proposal.active
        DIV 
          style: 
            position: 'absolute'
            bottom: 0
            fontSize: 13
          INPUT
            className: 'newpoint-anonymous'
            type:      'checkbox'
            id:        "sign_name-#{@props.valence}"
            name:      "sign_name-#{@props.valence}"
            checked:   @local.sign_name
            onChange: =>
              @local.sign_name = !@local.sign_name
              save(@local)
          LABEL 
            htmlFor: "sign_name-#{@props.valence}"
            title:'Signing your name lends your point more weight with other participants.', 'Sign your name'
        
      DIV 
        style: 
          textAlign: 'right'
          marginTop: 3
          marginBottom: '.5em'

        if !@proposal.active
          DIV 
            style: {color: '#777', fontSize: 12}
            'New points disabled for this proposal'
        else
          INPUT 
            className:'button primary_button'
            action:'submit-point',
            type:'submit', 
            onClick: @savePoint
            value:'Done'
            style: 
              marginTop: '.5em'
              width: '100%'
              fontSize: 18

        A 
          className:'newpoint-cancel primary_cancel_button'
          onClick: @done
          'cancel'  

  componentDidMount : ->
    $el = $(@getDOMNode())
    $el.find('#nutshell').focus()
    $el.find('.newpoint-cancel').ensureInView {scroll: false, position: 'bottom'}

  done : ->
    your_points = fetch @props.your_points_key
    if @props.fresh
      your_points.adding_new_point = false
    else
      your_points.editing_points = _.without your_points.editing_points, @props.key
    save your_points

  savePoint : (ev) ->
    $form = $(@getDOMNode())
    root = fetch('root')

    nutshell = $form.find('#nutshell').val()
    text = $form.find('#text').val()
    hide_name = !$form.find("#sign_name-#{@props.valence}").is(':checked')

    if !@props.fresh
      # If we're updating an existing point, we just have to update
      # some of the fields from the form
      point = @data()
      point.nutshell = nutshell
      point.text = text
      point.hide_name = hide_name
    else
      current_user = fetch('/current_user').user
      point =
        key : '/new/point'
        is_pro : @props.valence == 'pros'
        user : current_user
        comment_count : 0
        includers : [current_user]
        proposal : @proposal.key
        nutshell : nutshell
        text : text
        hide_name : hide_name

    save point

    @done()

    # This is a kludge cause activerest sucks for pre-rendering
    # changes before the server returns them
    fetch(@proposal.your_opinion).point_inclusions.push(point.key)
    re_render([@proposal.your_opinion])

styles += """
.edit_point .count{
  position: absolute;
  right: 20px;
  top: -19px;
}
"""


##
# Bubblemouth
#
# Creates a bubble mouth that tracks either the position of the histogram selection
# or the user's current opinion.
#
# TODO: refactor, the abstraction is broken & the code is poor
Bubblemouth = ReactiveComponent
  displayName: 'Bubblemouth'

  render : -> 
    if @props.target == 'histogram'

      hist = fetch('histogram')

      border_width = 3

      if hist.selected_opinion
        place_avatar_opinion_value = if hist.selected_opinion_value > 0 then .8 else -.8
        left = ((place_avatar_opinion_value + 1)/2) * BODY_WIDTH + 20

        avatar_size = 80
        user = fetch(fetch(hist.selected_opinion).user)
        name = user.name or 'Anonymous'
        title = "#{name}'#{if name[name.length - 1] != 's' then 's' else ''} Opinion"

        name_width = widthWhenRendered(title, {fontSize: '30px', fontWeight: '600'}) #+  
                              #widthWhenRendered('Opinion of', {fontSize: '18px', fontWeight: '300'})

        if hist.selected_opinion_value > 0
          name_style = 
            left: -28 - avatar_size * .5 - name_width 
            borderTopLeftRadius: 16
            paddingRight: avatar_size * .75
            paddingLeft: 18

        else
          name_style = 
            left: avatar_size/4
            borderTopRightRadius: 16
            paddingLeft: avatar_size * .75
            paddingRight: 18
              
        DIV style: {left: left, position: 'absolute'},

          DIV null,
            Avatar 
              key: user
              user: user
              hide_tooltip: true
              style: 
                position: 'absolute'
                width: avatar_size
                height: avatar_size
                top: -avatar_size * .75
                left: -avatar_size/4
                zIndex: 99 
                border: "3px solid #{focus_blue}"

            DIV 
              style: _.extend name_style,
                position: 'absolute'
                backgroundColor: focus_blue
                paddingTop: 8
                paddingBottom: 8
                color: 'white'
                top: -58
                width: name_width + 10 + 18 + avatar_size * .75 + 10


              SPAN 
                style: 
                  fontWeight: 600
                  fontSize: 30
                title



              # SPAN
              #   style: 
              #     fontWeight: 300
              #     fontSize: 18
              #     paddingRight: 10
              #   'Opinion of'


      else 
        size = 20
        left = ((hist.selected_opinion_value + 1)/2) * BODY_WIDTH + 20

        css_triangle = 
          width: 0
          height: 0
          borderRight: "#{size}px solid transparent"
          borderLeft: "#{size}px solid transparent"
          borderBottom: "#{size * 1.5}px solid #{if @root.selected_point then '#ccc' else focus_blue}"
          position: 'relative'
          top: -32

        DIV style: {left: left, position: 'absolute'},
          DIV 
            style: css.crossbrowserify(css_triangle)
            DIV
              style:
                width: 0
                position: 'relative'
                left: -(size - 1)
                top: border_width + 3
                borderLeft: "#{size - 1}px solid transparent"
                borderRight: "#{size - 1}px solid transparent"
                borderBottom: "#{size * 1.5 - 1}px solid white"


    else if @props.target == 'slider'
      # TODO...
      noop = 1
      bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
      IMG 
        className:'bubblemouth'
        src: bubblemouth_src
        style:
          left: left 
    else
      throw 'Unrecognized bubblemouth target'



##
# Avatar
# Displays a user's avatar
#
# We primarily download all avatar images as part of a CSS file specifying a 
# b64 encoded background-image small 50x50 thumbnails for each user (under #avatar-{id}). 
#
# Higher resolution images are available ('large' and 'original'). These can be specified
# by setting the img_size property of Avatar.
#
# Additionally, Avatar will automatically upgrade the image resolution if the style
# specifies a width greater than the size of the thumbnails. 
#
# Avatar will output either a SPAN or IMG. The choice of which tag is used is fraught 
# based upon the browser and how React replaces elements. In the future
# we can refactor this for a cleaner implementation.
#
# Properties set on Avatar will be transferred to the outputted SPAN or IMG.
#
# Options
#   img_size: the size of the embedded image. 'thumb' (default) or 'large' or 'original'
#   hide_tooltip: Suppress the tooltip on hover. False by default. 
#   anonymous: Don't show a real picture and show "anonymous" in the tooltip. False by default. 

Avatar = ReactiveComponent
  displayName: 'Avatar'
  
  render : ->
    user = @data()

    id = if @props.anonymous then "avatar-hidden" else "avatar-#{user.key.split('/')[2]}"
    style = _.extend {}, @props.style
    img_size = img_size or 'thumb'

    show_avatar = !@props.anonymous && user.avatar_file_name
    # Automatically upgrade the avatar size to 'large' if the width of the image is 
    # greater than the size of the b64 encoded image
    img_size = 'large' if img_size == 'thumb' && style?.width > 50 && !browser.is_ie9
    # ...but we only use a larger image if this user actually has one and isn't anonymous
    use_large_image = img_size != 'thumb' && show_avatar

    if use_large_image
      @props.src = "#{fetch('/subdomain').asset_host}/system/avatars/#{user.key.split('/')[2]}/#{img_size}/#{user.avatar_file_name}"  
    else
      style.content = "''" # prevents a weird webkit outlining issue
                           # http://stackoverflow.com/questions/4743127/chrome-safari-display-border-around-image

    # Override the gray default avatar color if we're showing an image. 
    # In most cases the white will allow for a transparent look. It 
    # isn't set to transparent because a transparent icon in many cases
    # will reveal content behind it that is undesirable to show.  
    style.backgroundColor = 'white' if show_avatar
      
    attrs =
      className: "avatar #{@props.className or ''}"
      id: id
      style: style
      onMouseEnter: => 
        if !@props.hide_tooltip
          name = if @props.anonymous || user.name?.length == 0 then 'Anonymous' else user.name
          tooltip = fetch 'tooltip'
          tooltip.coords = $(@getDOMNode()).offset()
          tooltip.tip = name
          save tooltip
      onMouseLeave: => 
        if !@props.hide_tooltip      
          tooltip = fetch 'tooltip'
          tooltip.coords = null
          save tooltip

    # IE9 gets confused if there is an image without a src
    tag = if browser.is_ie9 && img_size == 'thumb' then SPAN else IMG

    @transferPropsTo tag attrs

Tooltip = ReactiveComponent
  displayName: 'Tooltip'

  render : -> 
    tooltip = fetch('tooltip')
    return SPAN(null) if !tooltip.coords

    coords = tooltip.coords
    tip = tooltip.tip

    # place the tooltip above the element
    DIV
      style: 
        position: 'absolute'
        top: coords.top - 20
        left: coords.left
        fontSize: 14
        color: 'black'
        backgroundColor: 'white'
        padding: '0 4px'
        borderRadius: 8
        zIndex: 9999
        whiteSpace: 'nowrap'
        pointerEvents: 'none'
      tip



styles += """
.avatar {
  vertical-align: top;
  background-color: transparent;
  border: none;
  display: inline-block;
  margin: 0;
  padding: 0;
  border-radius: 50%;
  background-size: cover;
  background-color: #{default_avatar_in_histogram_color}; 
  user-select: none; -moz-user-select: none; -webkit-user-select: none;-ms-user-select: none;}
  .avatar.avatar_anonymous {
    cursor: default; 
}


"""


Homepage = ReactiveComponent
  displayName: 'Homepage'
  render: ->
    (customizations[fetch('/subdomain').name]?.Homepage or customizations.default.Homepage)()


window.proposal_editor = (proposal) ->
  editor = proposal.roles.editor.length > 0 and proposal.roles.editor[0]
  return editor != '-' and editor


ProfileMenu = ReactiveComponent
  displayName: 'ProfileMenu'

  render : -> 
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')

    menu_options = [
      {href: '/edit_profile', label: 'Edit Profile'},
      {href: '/dashboard/email_notifications', label: 'Notifications'},
      if current_user.is_admin then {href: '/dashboard/import_data', label: 'Import Data'} else null,
      if current_user.is_admin then {href: '/dashboard/application', label: 'App Settings'} else null,
      if current_user.is_admin then {href: '/dashboard/roles', label: 'User Roles'} else null,
      if current_user.is_moderator then {href: '/dashboard/moderate', label: 'Moderate'} else null,
      if subdomain.assessment_enabled && current_user.is_evaluator then {href: '/dashboard/assessment', label: 'Fact-check'} else null 
    ]

    menu_options = _.compact menu_options

    DIV
      style:
        _.extend(
          position: 'absolute'
          right: 50
          top: 17,
          _.clone(@props.style))

      if current_user.logged_in
        SPAN
          className: 'profile_menu_wrap'
          style:
            position: 'relative'
          onMouseEnter: => @local.menu = true; save(@local)
          onMouseLeave: => @local.menu = false; save(@local)
          DIV 
            style: 
              display: if not @local.menu then 'none'
              position: 'absolute'
              marginTop: -8
              marginLeft: -8
              padding: 8
              paddingTop: 50
              paddingRight: 14
              backgroundColor: '#eee'
              left: -82
              textAlign: 'left'
              zIndex: 999999

            for option in menu_options
              A
                className: 'menu_link'
                href: option.href
                key: option.href
                onClick: clickInternalLink
                option.label

            A 
              className: 'menu_link'
              onClick: @logout
              'Log out'

          SPAN 
            style: 
              color: subdomain.branding.header_text_color
              position: 'relative'
              zIndex: 9999999999
              backgroundColor: if !@local.menu then 'rgba(255,255,255, .1)' else 'inherit'
              boxShadow: if !@local.menu then '0px 1px 1px rgba(0,0,0,.1)' else 'none'
              borderRadius: 8
              padding: '3px 4px'

            Avatar 
              key: current_user.user
              hide_tooltip: true
              className: 'userbar_avatar'
              style: {height: 20, width: 20, marginRight: 7, marginTop: 1}
            I className: 'fa fa-caret-down', style: {visibility: if @local.menu then 'hidden' else 'visible'}
      else
        A
          'className': 'profile_anchor login'
          'data-action': 'login'
          onClick: (e) =>
            @root.auth = {form: 'login', goal: null}
            save @root
          style: {color: 'white'}
          'Log in'

      #Avatar key: current_user.user, className: 'userbar_avatar', style: {height: 26, width: 26, marginTop: -2}


  logout : -> 
    current_user = fetch('/current_user')
    current_user.logged_in = false
    current_user.trying_to = 'logout'

    if @root.auth && @root.auth.form == 'edit profile'
      @root.page_name = 'homepage'

    @root.auth = null

    save current_user, =>
      # We need to get a fresh your_opinion object
      # after logging out. 

      # TODO: the server should dirty keys on the client when the
      # current_user logs out
      arest.clear_matching_objects((key) -> key.match( /\/page\// ))

    save @root

styles += """
.profile_navigation {
  text-align: right;
  width: 100%;
  padding: 20px 120px 0 0;
  font-size: 21px; }

.menu_link {
  position: relative;
  bottom: 8px;
  padding-left: 27px;
  display: block;
  color: #{focus_blue};
  white-space: nowrap; }

.menu_link:hover{ color: black; }

.profile_menu_wrap:hover .profile_anchor{ color: inherit; }
"""

Header = ReactiveComponent
  displayName: 'Header'

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')

    DIV 
      style: 
        position: 'relative'
        margin: '0 auto'
        backgroundColor: 'white'
        minWidth: PAGE_WIDTH


      customizations["#{subdomain.name}"]?.Header?() or customizations.default.Header()

      DIV null, 
        if @root.page_name == 'about'
          A 
            onClick: (=> window.app_router.navigate("/", {trigger: true}))
            style: {position: 'absolute', display: 'inline-block', zIndex: 999, marginTop: 8, marginLeft: 16, fontWeight: 600}
            I className: 'fa fa-home', style: {fontSize: 28, color: '#bbb'}
            SPAN style: {fontSize: 15, paddingLeft: 6, color: '#777', verticalAlign: 'text-bottom'}, 'Home'


      DIV style: { backgroundColor: '#eee', color: '#f00', padding: '5px 20px', display: if @root.server_error then 'block' else 'none'},
        'Warning: there was a server error!'

    


# top secret proposal creation component
EditProposal = ReactiveComponent
  displayName: 'EditProposal'

  saveProposal : -> 
    $el = $(@getDOMNode())

    name = $el.find('#name').val()
    description = fetch("description-#{@data().key}").html
    slug = $el.find('#slug').val()
    cluster = $el.find('#cluster').val()
    cluster = null if cluster == ""
    active = $el.find('#open_for_discussion:checked').length > 0
    hide_on_homepage = $el.find('#listed_on_homepage:checked').length == 0

    if @props.fresh
      proposal =
        key : '/new/proposal'
        name : name
        description : description
        cluster : cluster
        slug : slug
        active: active
        hide_on_homepage: hide_on_homepage

    else 
      proposal = @data()
      _.extend proposal, 
        cluster: cluster
        name: name
        slug: slug
        description: description
        active: active
        hide_on_homepage: hide_on_homepage

    if @local.roles
      proposal.roles = @local.roles
      proposal.invitations = @local.invitations

    if @local.description_fields
      for field in @local.description_fields
        edited_html = fetch("field-#{field.id}-html-#{proposal.key}")
        field.html = edited_html.html if edited_html.html
      proposal.description_fields = JSON.stringify(@local.description_fields)

    save proposal, -> window.app_router.navigate "/#{slug}", {trigger : true}

  render : ->
    user = fetch('/current_user')
    proposal = @data()
    subdomain = fetch '/subdomain'
    
    return DIV null, 'Nothing to see here, move on' if (permit('update proposal', proposal) < 0) || (!@props.fresh && !proposal.slug )

    block_style = 
      width: CONTENT_WIDTH
      padding: '2px 0px'
      marginBottom: 12
      position: 'relative'

    description_field_style =
      fontSize: 18
      width: CONTENT_WIDTH - 200
      padding: 12
      marginBottom: 8
      border: '1px solid #ccc'

    input_style = _.extend {}, description_field_style, 
      display: 'block'

    label_style =
      fontSize: 24
      fontWeight: 600
      width: 240
      display: 'inline-block'
      color: focus_blue
      marginBottom: 3


    if !@local.description_fields
      @local.description_fields = if @data().description_fields then $.parseJSON(@data().description_fields) || [] else []
      @local.open_fields = []

      if @local.description_fields.length > 0
        if @local.description_fields[0].group
          # Right now, we just downgrade group syntax to flat description list syntax
          # TODO: when editing a proposal, support the proposal description groups syntax (or get rid of it)
          @local.description_fields = _.flatten(@local.description_fields.map (group) -> group.items)

        # Add unique identifiers to each field so we can hide/edit them
        for field,idx in @local.description_fields
          field.id = idx

      save @local

    toggleDescriptionFieldOpen = (field, field_open) =>
      if field_open
        @local.open_fields = _.without @local.open_fields, field.id
      else
        @local.open_fields.push field.id
      save @local

    DIV null, 
      DashHeader name: if @props.fresh then "New Proposal" else "Edit #{proposal.name}"
      DIV 
        style: 
          width: CONTENT_WIDTH
          margin: 'auto'
          padding: '3em 0'
          position: 'relative'
        A 
          style: 
            color: '#777'
            position: 'absolute'
            left: -100
            top: 54
          href: "/#{proposal.slug}"
          onClick: clickInternalLink

          I
            className: 'fa fa-arrow-left'
            style: 
              paddingRight: 10
          'back'


        DIV style: block_style,
          LABEL htmlFor:'slug', style: label_style, 'URL:'
          INPUT 
            id:'slug'
            name:'slug'
            pattern:'^.{3,}'
            placeholder:"The URL in #{window.location.origin}/URL. Just letters, numbers, underscores, dashes."
            required:'required'
            defaultValue: if @props.fresh then null else proposal.slug
            style: input_style

        DIV style: block_style,
          LABEL htmlFor:'name', style: label_style, 'Summary:'
          INPUT 
            id:'name'
            name:'name'
            pattern:'^.{3,}'
            placeholder:'Aim for 3-8 words with a verb and noun.'
            required:'required'
            defaultValue: if @props.fresh then null else proposal.name
            style: input_style

        DIV style: block_style,
          LABEL htmlFor:'description', style: label_style, 'Description:'
          
          WysiwygEditor
            key:"description-#{proposal.key}"
            placeholder:'Clearly describe the details.'
            style: input_style
            html: if @props.fresh then null else proposal.description

          # Expandable description fields

          DIV 
            style: 
              marginBottom: 20
              marginLeft: 45
              display: if not fetch('/current_user').is_super_admin then 'none' else 'block'

            for field in @local.description_fields
              field_open = field.id in @local.open_fields
              DIV key: "field-#{field.id}", style: _.extend({}, block_style, {width: ''}),

                I 
                  className: "fa fa-#{if field_open then 'minus' else 'plus'}-circle"
                  style: {position: 'absolute', left: -20, top: 18, color: '#414141', cursor: 'pointer'}
                  onClick: do (field, field_open) => => toggleDescriptionFieldOpen(field, field_open)

                if field_open
                  [INPUT
                    style: _.extend {}, description_field_style, {width: description_field_style.width - 45}
                    type: 'text'
                    id:"field-#{field.id}-label"
                    name:"field-#{field.id}-label"
                    pattern:'^.{3,}'
                    placeholder:'Label'
                    required:'required'
                    onChange: do(field) => (e) => field.label = e.target.value; save(@local)
                    value: field.label

                  WysiwygEditor
                    key:"field-#{field.id}-html-#{proposal.key}"
                    name:"field-#{field.id}-html"
                    placeholder:'Text that is shown when expanded'
                    style: _.extend {}, description_field_style, {width: description_field_style.width - 45}
                    html: field.html]

                else
                  DIV 
                    style: 
                      fontSize: 18
                      fontWeight: 600
                      cursor: 'pointer'
                      marginTop: 12
                      marginLeft: 5
                      width: description_field_style.width - 45
                    onClick: do (field, field_open) => => toggleDescriptionFieldOpen(field, field_open)
                    field.label

                DIV 
                  style: 
                    position: 'absolute'
                    right: 150
                    top: 12

                  A
                    style: {color: '#aaa', textDecoration: 'underline', fontSize: 14, cursor: 'pointer', display: 'block'}
                    onClick: do (field, field_open) => => toggleDescriptionFieldOpen(field, field_open)
                    if field_open then 'close' else 'edit'

                  A
                    style: {color: '#aaa', textDecoration: 'underline', fontSize: 14, cursor: 'pointer', display: 'block'}
                    onClick: do (field) => =>
                      @local.description_fields = _.filter @local.description_fields, (fld) -> fld.id != field.id
                      save @local
                    'delete'

            SPAN
              style: 
                color: '#aaa'
                cursor: 'pointer'
                fontSize: 18
                marginLeft: -18

              onClick: => 
                new_id = 0
                for field in @local.description_fields
                  new_id += field.id  
                new_id += 1
                @local.description_fields.push {label: null, html: null, id: new_id}
                @local.open_fields.push new_id
                save @local

              "+ "
              SPAN style: {textDecoration: 'underline', marginLeft: 7}, "Add expandable description section"


        DIV style: block_style,
          LABEL htmlFor:'cluster', style: label_style, 'Group (optional):'
          INPUT 
            id:'cluster'
            name:'cluster'
            pattern:'^.{3,}'
            placeholder:'The group to which this proposal belongs, if any.'
            defaultValue: if @props.fresh then null else proposal.cluster
            style: input_style

        DIV style: block_style,
          LABEL htmlFor: 'listed_on_homepage', style: label_style, 'List on homepage?'

          INPUT 
            id: 'listed_on_homepage'
            name: 'listed_on_homepage'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else !proposal.hide_on_homepage
            style: {fontSize: 24}

        DIV style: block_style,
          LABEL htmlFor: 'open_for_discussion', style: label_style, 'Open for discussion?'

          INPUT 
            id: 'open_for_discussion'
            name: 'open_for_discussion'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else proposal.active
            style: {fontSize: 24}


        DIV null, 
          SPAN 
            style: _.extend {}, label_style,
              textDecoration: 'underline'
              cursor: 'pointer'
              width: 400
              position: 'relative'
            onClick: => 
              @local.edit_roles = !@local.edit_roles
              save @local
            I 
              className: 'fa-child fa'
              style: 
                position: 'absolute'
                left: -25
                top: 5


            'Permissions and invitations'

          DIV 
            style: 
              width: CONTENT_WIDTH
              backgroundColor: '#fafafa'
              padding: '10px 60px'
              display: if @local.edit_roles then 'block' else 'none' #roles has to be rendered
                                                                            #so that default roles are 
                                                                            #set on the proposal

            ProposalRoles key: @local

        DIV null,
          INPUT 
            className:'button primary_button'
            type:'submit'
            style: 
              width: 300
              marginTop: 35
            value:"#{if @props.fresh then 'Publish' else 'Update'}"
            onClick: @saveProposal


About = ReactiveComponent
  displayName: 'About'

  componentWillMount : ->
    @local.embed_html_directly = true
    @local.html = null
    @local.save

  componentDidMount : -> @handleContent()
  componentDidUpdate : -> @handleContent()

  handleContent : -> 
    $el = $(@getDOMNode())

    if @local.embed_html_directly
      # have to use appendChild rather than dangerouslysetinnerhtml
      # because scripts in the about page html won't get executed
      # when using dangerouslysetinnerhtml
      if @local.html
        $el.find('.embedded_about_html').append @local.html

    else
      # REACT iframes don't support onLoad, so we need to figure out when 
      #               to check the height of the loaded content ourselves      
      $el.prop('tagName').toLowerCase() == 'iframe'
      iframe = $el[0]
      _.delay ->
        try 
          iframe.height = iframe.contentWindow.document.body.scrollHeight + "px"
        catch e
          iframe.height = "2000px"
          console.error 'Couldn\'t set about page iframe height because of http/https mismatch. Should work in production.'
          console.error e
      , 1000


  render : -> 
    subdomain = fetch('/subdomain') 

    if @local.embed_html_directly && !@local.html && subdomain.about_page_url
      # fetch the about page HTML directly
      $.get subdomain.about_page_url, (response) => @local.html = response; save @local

    DIV style: {marginTop: 20},
      if !subdomain.about_page_url
        DIV null, 'No about page defined'
      else if !@local.embed_html_directly
        IFRAME src: subdomain.about_page_url, width: PAGE_WIDTH, style: {display: 'block', margin: 'auto'}
      else
        DIV className: 'embedded_about_html'


EmailNotificationSettings = ReactiveComponent
  displayName: 'EmailNotificationSettings'

  render : -> 
    data = @data()
    current_user = fetch('/current_user')

    # TODO: listing each followable and making it unfollowable
    DIV null,
      DashHeader name: 'Email Notification Settings'
      DIV style: {width: CONTENT_WIDTH, margin: '15px auto'}, 

        DIV null,
          INPUT 
            id: 'no_email_notifications'
            name: 'no_email_notifications'
            type: 'checkbox'
            defaultChecked: !current_user.no_email_notifications
            onChange: (e) => 
              current_user.no_email_notifications = !$('#no_email_notifications').is(':checked')
              save current_user
          LABEL htmlFor: 'no_email_notifications', 'Receive email notifications'

        if !current_user.no_email_notifications
          if _.flatten(_.values(data.follows)).length == 0
            DIV null, 'You\'re not currently receiving any email notifications'
          else
            DIV null,
              H1 style: {fontSize: 24, margin: '10px 0'}, "This is what you receive email notifications about:"

              for followable_type in ['Point', 'Proposal']
                if data.follows[followable_type].length > 0
                  DIV null,
                    H1 style: {fontSize: 18, margin: '10px 0'}, "#{followable_type}s"
                    for follow in data.follows[followable_type]
                      followable = fetch(follow)
                      DIV style: {margin: '20px 0'}, 
                        if followable_type == 'Point'
                          Point key: followable, rendered_as: 'under_review'
                        else 
                          BLOCKQUOTE null,
                            followable.name
                        BUTTON 
                          style: {fontSize: 18}
                          onClick: do(followable) => => 
                            followable.is_following = false
                            save followable
                            arest.serverFetch '/dashboard/email_notifications' # don't want to have to dirty this key whenever a point or proposal is updated
                          'unsubscribe'


Computer = ReactiveComponent
  # This doesn't actually render anything.  It just processes state
  # changes to current_user for CSRF and logging in and out.
  displayName: 'Computer'
  render : ->
    current_user = fetch('/current_user')
    if current_user.csrf
      arest.csrf(current_user.csrf)

    #console.log("Maybe we will publish: '#{@root.opinions_to_publish}' #{current_user.logged_in}")

    # Publish pending opinions if we can
    if @root.opinions_to_publish.length > 0

      remaining_opinions = []

      for opinion_key in @root.opinions_to_publish
        opinion = fetch(opinion_key)
        can_opine = permit('publish opinion', opinion.proposal)

        if can_opine > 0 && !opinion.published
          opinion.published = true
          save opinion
        else 
          remaining_opinions.push opinion_key

          # TODO: show some kind of prompt to user indicating that despite 
          #       creating an account, they still aren't permitted to publish 
          #       their opinion.
          # if can_opine == Permission.INSUFFICIENT_PRIVILEGES
          #   ...

      if remaining_opinions.length != @root.opinions_to_publish.length
        @root.opinions_to_publish = remaining_opinions
        save @root

    # users following an email invitation need to complete registration (name + password)
    if current_user.needs_to_set_password
      @root.auth = {form: 'create account via invitation', goal: 'complete registration'}
      save @root

    SPAN null


Page = ReactiveComponent
  displayName: 'Page'
  mixins: [AccessControlled]

  render: ->

    avatars = fetch('/avatars')
    subdomain = fetch('/subdomain')

    if @root.auth && @root.auth.form != 'edit profile'
      return Auth()

    if subdomain.name == 'homepage' && @root.page_name == 'homepage'
      SPAN null, ''
    else if !subdomain.name
      L
    else
      DIV style: {minWidth: PAGE_WIDTH, backgroundColor: 'white'},
        if avatars.avatars
          STYLE type: 'text/css', id: 'b64-avatars', dangerouslySetInnerHTML: {__html: avatars.avatars}
        
        BrowserHacks()
        Header()
        DIV style : { minWidth: PAGE_WIDTH, minHeight: 200, zIndex: 2, margin: 'auto', \
                      marginLeft: if lefty then 0 },

          if @root.page_name == 'edit_profile'
            Auth()

          else

            if !@accessGranted()
              SPAN null 
            else if @root.page_name.match(/(.+)\/edit/)
              EditProposal key: "/#{@root.page_name.match(/(.+)\/edit/)[1]}", fresh: false
            else
              switch @root.page_name
                when 'homepage'
                  Homepage key: @page.key
                when 'about'
                  About()
                when 'proposal/new'
                  EditProposal key: "new_proposal", fresh: true              
                when 'dashboard/email_notifications'
                  EmailNotificationSettings key: '/page/dashboard/email_notifications'
                when 'dashboard/assessment'
                  FactcheckDash key: "/page/dashboard/assessment"
                when 'dashboard/create_subdomain'
                  CreateSubdomain key: "/page/dashboard/create_subdomain"
                when 'dashboard/import_data'
                  ImportDataDash key: "/page/dashboard/import_data"
                when 'dashboard/moderate'
                  ModerationDash key: "/page/dashboard/moderate"
                when 'dashboard/application'
                  AppSettingsDash key: "/page/dashboard/application"
                when 'dashboard/roles'
                  SubdomainRoles key: "/page/dashboard/roles"
                else
                  Proposal key: @page.proposal.key

        (customizations[subdomain.name]?.Footer or customizations.default.Footer)()

Root = ReactiveComponent
  displayName: 'Root'
  resetSelection: (e) ->

    if !root.auth
      hist = fetch 'histogram'

      if @root.selected_point
        window.writeToLog
          what: 'deselected a point'
          details:
            point: @root.selected_point

        @root.selected_point = null
        save @root

      else if hist.selected_opinions || hist.selected_opinion
        if hist.dragging
          hist.dragging = false
        else
          hist.selected_opinion = null
          hist.selected_opinions = null
          hist.selected_opinion_value = null
        save hist

    if @root.show_wyswyg_toolbar
      @root.show_wyswyg_toolbar = false
      save @root



  render : -> 
    root = @data()

    ######
    # Handle application routing, derived from client state.
    query_parameters = Backbone.history.getQueryParameters()
    query_parameters = {}

    if @root.proposal_mode == 'results'
      query_parameters['results'] = true #the only query parameter we support now is ?results=true for proposal pages
    if @root.selected_point
      query_parameters['selected'] = @root.selected_point

    # Second, construct the proper url
    if root.page_name == 'homepage' 
      url = ''
    else if root.page_name == 'about'
      url = 'about'
    else #if we're rendering a proposal...
      url = window.app_router.toFragment root.page_name, query_parameters

    # Third, update the location bar if it's different
    if "#{window.location.pathname}#{window.location.search}" != "/#{url}"
      window.app_router.navigate url, {trigger : true}
    ####

    # Now let's render
    DIV onClick: @resetSelection,
      StateDash(),
      Page(key: "/page/#{root.page_name}"),
      Computer() # Doesn't actually render anything
      Tooltip()


# Displays warnings for some browsers
# Stores state about the current device. 
# Note that IE<9 users are redirected at
# an earlier point to an MS upgrade site. 
BrowserHacks = ReactiveComponent
  displayName: 'BrowserHacks'

  render : ->
    browser = fetch 'browser'
    if  browser.is_opera_mini #|| browser.is_android_browser
      DIV style: {backgroundColor: 'red', padding: '10px', textAlign: 'center', color: 'white', fontSize: 24}, 
        "This website does not work well with #{if browser.is_android_browser then 'the Android Browser' else 'Opera Mini'}. Please use "
        A href: "https://play.google.com/store/apps/details?id=com.android.chrome&hl=en", style: {color: 'white', textDecoration: 'underline'},
          'Chrome for Android' 
        ' if you experience difficulty. Thanks, and sorry for the inconvenience!'
    else 
      # Use third party script for detecting and warning users
      # of other outdated browsers. Sticking with
      # third party for now because of some complexities
      # in detecting some of these browser versions. In 
      # the future, probably want to extract the logic. 
      # "https://browser-update.org/update.html"
      SCRIPT type: 'text/javascript', src: '//browser-update.org/update.js'




# Fetch current user every 2 minutes so that if the user gets
# logged out (e.g. by server deploy after letting a browser window stay open), 
# their browser will accurately reflect reality. 
# Only do this if user is already logged in, so that we don't 
# accidently interfere with a login process.
# TODO: Remove this after we have true realtime updates
setInterval -> 
  current_user = fetch '/current_user'
  if current_user.logged_in
    arest.serverFetch('/current_user')
, 2 * 60 * 1000


##
# Backbone routing
# Note: not committed to backbone. Want to experiment with other routing techniques too.
window.root = null
Router = Backbone.Router.extend
  
  routes :
    "(/)" : "homepage"
    "about(/)" : "about"
    "edit_profile(/)" : "edit_profile"
    "proposal/new(/)" : "new_proposal"
    "proposal/:proposal/edit(/)": "edit_proposal"
    ":proposal(/)": "proposal"    
    "dashboard/:dash(/)": "dashboard"

  proposal : (slug, params) ->
    root = fetch('root')
    resetState(root)

    root.page_name = slug

    #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
    #      Right now activeREST doesn't allow wide consumption of a component's client state
    #      if its data is synced with the server. 


    root.proposal_mode = 'crafting'
    root.selected_point = null
    if params 
      root.proposal_mode = 'results' if params['results']
      root.selected_point = params['selected'] if params['selected']

    save root

    writeToLog
      what: 'loaded page',
      where: slug

  homepage : (params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = 'homepage'
    save root

    writeToLog
      what: 'loaded page',
      where: 'homepage'

  about : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'about'
    save root

    writeToLog
      what: 'loaded page',
      where: 'about'

  new_proposal : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'proposal/new'
    save root

  edit_proposal : (id, params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = "proposal/#{id}/edit"
    save root

  dashboard : (dash, params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = "dashboard/#{dash}"    
    save root

  edit_profile : (params) -> 
    root = fetch('root')
    resetState(root)

    root.page_name = 'edit_profile'
    root.auth = {form: 'edit profile'}

    save root


# Temporary method for handling resetting root state when switching between
# routes. Remove once we have a better activeREST answer. 
resetState = (root) ->
  root.auth = null

  #TODO: Manage proposal_mode {crafting/results} with client state on the proposal.
  #      Right now activeREST doesn't allow wide consumption of a component's client state
  #      if its data is synced with the server. 
  root.proposal_mode = null    
  root.selected_point = null

  hist = fetch('histogram')
  hist.selected_opinion = hist.selected_opinions = hist.selected_opinion_value = null
  save hist

window.app_router = new Router()
window.on_ajax_error = () ->
  (root = fetch('root')).server_error = true
  save(root)
window.on_client_error = (e) ->
  if navigator.userAgent.indexOf('PhantomJS') >= 0
    # don't care about errors on phtanomjs web crawlers
    return

  save(
    key: '/new/client_error'
    stack: e.stack
    message: e.message or e.description
    name: e.name
    line_number: e.lineNumber
    column_number: e.columnNumber
    )

window.writeToLog = (entry) ->
  _.extend entry, 
    key: '/new/log'
    where: fetch('root').page_name

  save entry

# exports...
window.Point = Point
window.Comment = Comment
window.Avatar = Avatar
window.Button = Button
window.ProfileMenu = ProfileMenu
window.MiniHisto = MiniHisto

#######
# Start the app!


$( ->
  #static consider.it homepage doesn't want this stuff by default
  if document.getElementById('content') 
    # add styles
    $('body').append("<style type='text/css'>#{styles}</style>")

    if 'ontouchend' in document #detect touch support
      React.initializeTouchEvents(true)

    Backbone.history.start {pushState: true}
    window.root = React.renderComponent(Root(), document.getElementById('content'))
)
