#////////////////////////////////////////////////////////////
# Core considerit client code
#////////////////////////////////////////////////////////////

DO_NOT_COMPRESS_THIS_FILE = true

## ########################
## Initialize defaults for client data

fetch 'histogram',
  highlighted_users : null
  # region_selection_width controls the size of the selection region when 
  # hovering over the histogram. It defines the opinion bounds within which 
  # opinions are selected. Opinions = [-1, 1]. region_selection_width is 
  # on this scale. 
  region_selection_width : .25
  selected_opinion : null
  selected_opinions : null 
      # use null instead of [] because an empty selection 
      # can happen that we treat differently than no selection

fetch 'slider',
  has_moved : false
  is_moving : false
  stance : null

fetch 'decisionboard',
  docked : false
  
fetch 'root',
  auth_mode : null
  opinions_to_publish : []

fetch '/current_user'


window.lefty = false

window.proposal_url = (proposal) =>
  # The special thing about this function is that it only links to
  # "?results=true" if the proposal has an opinion.
  result = '/' + proposal.slug
  subdomain = fetch('/subdomain')  

  if !customization('show_crafting_page_first') && proposal.top_point
    result += '?results=true'
  return result

window.isNeutralOpinion = (stance) -> 
  return Math.abs(stance) < 0.05

userOpinion = (user_key) ->
  window.user_opinions[user_key]

_route_changed = false

window.togglePage = (proposal_mode, triggered_by) ->
  toggle = -> 
    root = fetch('root')

    window.writeToLog
      what: 'toggle proposal mode'
      details: 
        from: root.proposal_mode
        to: proposal_mode
        triggered_by: triggered_by 

    root.proposal_mode = proposal_mode
    root.selected_point = null
    save root

    # Kludge for tracking when the page changes
    _route_changed = true
    _.defer -> _route_changed = false

  if proposal_mode == 'results'
    $('.histogram').ensureInView
      offset_buffer: -50
      callback : toggle
  else
    toggle()



##
# PageTransition mixin
# Helper for components that implement a page transition animation.
# Applies styles defined in the component that change
# depending on the route. 
#
# The styles will be added on every update and on component mount. 
# However, it will *animate* the styles only if the page has changed 
# (_route_changed). Otherwise it just directly applies the styles
PageTransition = 

  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) ->
    @applyStyles _route_changed

  applyStyles : (animate) ->
    duration = if animate then TRANSITION_SPEED else 0
    root = @root
    $el = $(@getDOMNode())

    # Each Component that implements this mixin can get triggered multiple times 
    # after a route change. So we're going to ensure that we apply styles only 
    # once for a given route change. 
    return if @transitioning == root.proposal_mode

    @transitioning = root.proposal_mode

    switch @name

      # The histogram will get transparent when moving to crafting page
      when 'histogram'
        opacity = if root.proposal_mode == 'crafting' then '0.2' else '1.0'
        $el.find('.histogram_bar').velocity {opacity: opacity}, {duration}

      # The position of the CommunityPoints will move to the wings on crafting,
      # and be close together in results
      when 'communitypoints'

        if root.proposal_mode == 'crafting'
          offset_x = if @props.key == 'cons' then 0 else DECISION_BOARD_WIDTH
        else if root.proposal_mode == 'results'
          offset_x = DECISION_BOARD_WIDTH / 2

        $el.velocity { translateX: offset_x }, {duration}

      # The slider handle and mouth will change size and location when moving 
      # between crafting and results
      when 'slider'
        slider = fetch('slider')
        handle_style = 
          scale: if root.proposal_mode == 'results' || slider.docked then 1 else 2.5
        $el.find('.the_handle').velocity handle_style, {duration}

      when 'bubblemouth'
        slider = fetch 'slider'
        stance = slider.stance
        direction = if stance > 0 && !isNeutralOpinion(stance) then 1 else -1
        mouth_x   = if isNeutralOpinion(stance) then 0 else -18

        if root.proposal_mode == 'crafting'
          bubblemouth_style = 
            translateX: direction * mouth_x
            translateY: 20
            scaleX: direction * 1.5
            scaleY: 1.5
        else 
          bubblemouth_style = 
            translateX: direction * mouth_x
            translateY: -4
            scaleX: direction
            scaleY: 1

        $el.velocity bubblemouth_style, {duration}

      # The decision board will have to expand for crafting and collapse into 
      # to the Give Opinion button in results
      when 'decisionboard'
        if root.proposal_mode == 'crafting'
          decision_board_style =
            translateX: 0
            translateY: 10
            width: DECISION_BOARD_WIDTH
            minHeight: 275

          $el.find('.decision_board_body')
            .velocity(decision_board_style, {duration})

          $el.find('.give_opinion_button').css 'visibility', 'hidden'
          _.delay => 
            #delay & check in case of quick switch between pages
            if root.proposal_mode == 'crafting'
              $el.find('.your_points, .save_opinion_button, .cancel_opinion_button')
                .css('display', '')
          , duration

        else 
          slider = fetch 'slider'
          slider_position = slider.clientX

          give_opinion_button_width = 200

          gutter = .1 * give_opinion_button_width
          opinion_region_x = -gutter + slider_position/BODY_WIDTH * \
                             (DECISION_BOARD_WIDTH - \
                              give_opinion_button_width + \
                              2 * gutter)
                             

          decision_board_style =
            translateX: opinion_region_x
            translateY: -18
            width: give_opinion_button_width
            minHeight: 32
            marginTop: 0

          $el.find('.decision_board_body')
            .velocity(decision_board_style, {duration})

          $el.find('.your_points, .save_opinion_button, .cancel_opinion_button')
            .css('display', 'none')

          _.delay => 
            #check in case of quick switch between pages
            if root.proposal_mode == 'results'
              $el.find('.give_opinion_button').css 'visibility', ''
          , duration  
      else
        throw "The #{@name} component does not define any styles to animate"

    _.delay => 
      @transitioning = null
    , duration


#####################
# React Components (needs to be updated)
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  displayName: 'Proposal'

  render : ->
    options = customization("cluster_options.#{@proposal.cluster}") || {}

    your_opinion = fetch @proposal.your_opinion
    current_user = fetch('/current_user')
    subdomain = fetch '/subdomain'
    @max_description_height = options.collapse_descriptions_at

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    # change to results page if user entered crafting page when it is not permitted
    if @root.proposal_mode == 'crafting' && 
        !(can_opine in [Permission.PERMITTED, Permission.UNVERIFIED_EMAIL, \
                        Permission.NOT_LOGGED_IN, Permission.INSUFFICIENT_INFORMATION] || 
         (can_opine == Permission.DISABLED && your_opinion.published))
      @root.proposal_mode = 'results'
      save @root

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in @page.opinions
      window.user_opinions[opinion.user] = opinion

    proposer = fetch(@proposal.user)

    # Description fields are the expandable details that help people drill
    # into the proposal. They are very specific to the type of proposal (e.g. for
    # an LVG ballot measure, one of the fields might be "fiscal impact statement").  
    # We're now storing all these fields in proposal.description_fields
    # as a serialized JSON object of one of the following structures:
    #   [ {"label": "field one", "html": "<p>some details</p>"}, ... ] 
    #   [ {"group": "group name", 
    #      "items": [ {"label": "field one", "html": "<p>some details</p>"}, ... ]}, 
    #   ...]
    if !@local.description_fields
      # Deserialize the description fields. 
      # TODO: Do this on the server.
      # This will fail for proposals that are not using the serialized JSON format; 
      # For now, we'll just catch the error and carry on 
      try 
        @local.description_fields = $.parseJSON(@data().description_fields)
        @local.expanded_field = null
      catch
        @local.description_fields = null
    
    proposal_header = (customization('ProposalHeader'))()


    DIV key:@props.slug, 'data-page':@root.proposal_mode,

      if customization('docking_proposal_header')
        Dock
          dock_on_zoomed_screens: false
          skip_jut: true
          proposal_header

      else
        proposal_header

      DIV null,
        #description
        DIV 
          style: 
            width: DESCRIPTION_WIDTH
            position: 'relative'
            margin: 'auto'
            marginLeft: if lefty then 300
            #marginRight: if lefty then 0
            fontSize: 16
            marginBottom: 18

          if !@proposal.active
            SPAN 
              style: 
                display: 'inline-block'
                color: 'rgb(250, 146, 45)'
                padding: '4px 0px'
                marginTop: 10
              I className: 'fa fa-info-circle', style: {paddingRight: 7}
              'Closed to new contributions at this time.'

          # TODO: now that we're accepting user contributed proposals, we need 
          # to SANITIZE the description
          DIV
            className: 'proposal_details'
            style:
              paddingTop: '1em'
              fontSize: 18
              position: 'relative'
              maxHeight: if @local.description_collapsed then @max_description_height
              overflowY: 'hidden'
            if @local.description_collapsed
              DIV
                style:
                  backgroundColor: 'white'
                  backgroundColor: '#f9f9f9'
                  width: '100%'
                  position: 'absolute'
                  bottom: 0
                  textDecoration: 'underline'
                  cursor: 'pointer'
                  paddingTop: 10
                  paddingBottom: 10
                  fontWeight: 600
                  textAlign: 'center'
                onMouseDown: => @local.description_collapsed = false; save(@local)
                'Expand full text'
            SPAN dangerouslySetInnerHTML:{__html: @proposal.description}


          if @local.description_fields
            DIV style: {marginTop: '1em'},
              for item in @local.description_fields
                if item.group
                  @renderDescriptionFieldGroup item
                else
                  @renderDescriptionField item

          if permit('update proposal', @proposal) > 0
            DIV null,
              A 
                style: {color: '#888'}
                href: "#{@proposal.key}/edit"
                'Edit'
              A 
                style: 
                  color: '#888'
                  padding: 10
                  backgroundColor: if @local.edit_roles then '#fafafa' else 'transparent'
                onClick: => 
                  @local.edit_roles = !@local.edit_roles
                  save @local
                'Share'

              if permit('delete proposal', @proposal) > 0
                A
                  style: {color: '#888'}
                  onClick: => 
                    if confirm('Delete this proposal forever?')
                      destroy(@proposal.key)
                      window.app_router.navigate("/", {trigger: true})
                  'Delete'

          if @local.edit_roles
            DIV 
              style:
                width: BODY_WIDTH
                margin: 'auto'
                backgroundColor: '#fafafa'
                padding: '10px 60px'
                marginLeft: (if lefty then 0)
              ProposalRoles key: @proposal
            
        #feelings
        DIV
          style:
            width: BODY_WIDTH
            margin: '0 auto'
            marginLeft: if lefty then 300
            position: 'relative'

          Dock
            key: 'histogram-dock'
            docked_key: 'histogram'
            dock_on_zoomed_screens: true
            constraints : ['slider-dock']
            dockable : => 
              #@root.proposal_mode == 'results'
              false
            start : 170 - 50

            stop : -> 
              $('.reasons_region').offset().top + $('.reasons_region').outerHeight() - 20

            dummy: if fetch('histogram-dock').docked then 1 else -1
                    # TODO: Dummy is a shallow patch for an odd problem. 
                    # If you have a nested component (in this case Histogram) 
                    # which passes a prop based on a Statebus value, then 
                    # that nested component will not be rerendered with 
                    # the new prop unless the parent component (Dock)
                    # is rendered first. By setting a dummy prop on Dock
                    # that corresponds to the prop for the child, we assure
                    # that the parent will properly pass the prop onto the 
                    # child. 
            
            Histogram
              key: 'histogram'
              proposal: @proposal
              width: BODY_WIDTH
              height: if fetch('histogram-dock').docked then 50 else 170
              enable_selection: true
              draw_base: if fetch('histogram-dock').docked then true else false

          Dock
            key: 'slider-dock'
            docked_key: 'slider'          
            dock_on_zoomed_screens: true
            constraints : ['decisionboard-dock', 'histogram-dock']
            skip_jut: @root.proposal_mode == 'results'
            dockable : => 
              @root.proposal_mode == 'crafting'

            Slider
              key: 'slider'
              width: BODY_WIDTH - 10


        #reasons
        DIV 
          className:'reasons_region'
          style : 
            width: REASONS_REGION_WIDTH            
            position: 'relative'
            paddingBottom: '4em' #padding instead of margin for docking
            margin: '24px auto 0 auto'
            marginLeft: if lefty then 65


          # Border + bubblemouth that is shown when there is a histogram selection
          GroupSelectionRegion()

          #community cons
          CommunityPoints { key: 'cons' }

          Dock
            key: 'decisionboard-dock'
            docked_key: 'decisionboard'            
            constraints : ['slider-dock']
            dock_on_zoomed_screens: true
            dockable : => 
              @root.proposal_mode == 'crafting'

            start: -24

            stop : -> 
              $('.reasons_region').offset().top + $('.reasons_region').outerHeight() - 20

            style: 
              position: 'absolute'
              width: DECISION_BOARD_WIDTH
              zIndex: 0 #so that points being dragged are above opinion region
              display: 'inline-block'
              verticalAlign: 'top'

            DecisionBoard { key: 'decisionboard' }

          #community pros
          CommunityPoints { key: 'pros' }


      if @root.proposal_mode == 'results' && 
          your_opinion.published && 
          customization('ThanksForYourOpinion')
        customization('ThanksForYourOpinion')()

  componentDidUpdate : ->
    $el = $(@getDOMNode())

    # Resizing the reasons region to solve a layout error when 
    # the height of the decision board (which is absolutely positioned) 
    # is taller than either of the wing point columns
    $el.find('.reasons_region').css {minHeight: $el.find('.opinion_region').height()} 


  componentDidMount : ->
    if (@max_description_height and @local.description_collapsed == undefined \
        and $('.proposal_details').height() > @max_description_height)
      @local.description_collapsed = true; save(@local)

  renderDescriptionField : (field) ->
    symbol = if field.expanded then 'fa-minus-circle' else 'fa-plus-circle'
    DIV 
      className: 'description_field'
      key: field.label
      style: {padding: '.25em 0'}

      DIV 
        style: {cursor: 'pointer'}
        onClick: => 
          field.expanded = !field.expanded
          save(@local)
          if field.expanded 
            window.writeToLog
              what: 'expand proposal description'
              details: 
                description_type: field.label        
        SPAN 
          className: "fa #{symbol}"
          style: 
            opacity: .7
            position: 'relative'
            left: -4
            paddingRight: 6

        SPAN 
          style: {lineHeight: 1.6, fontSize: 18}
          field.label

      if field.expanded
        DIV 
          style: 
            padding: '10px 0'
            width: 700
            overflow: 'hidden'
          dangerouslySetInnerHTML:{__html: field.html}

  renderDescriptionFieldGroup : (group) -> 
    DIV 
      className: 'description_group'
      key: group.group,
      style: 
        position: 'relative'
        marginBottom: 10
        borderLeft: '1px solid #e1e1e1'
        paddingLeft: 20
        left: -20

      DIV 
        style: 
          position: 'absolute'
          width: 200
          left: -217
          textAlign: 'right'
          top: 4
          fontWeight: if browser.high_density_display then 300 else 400

        LABEL null, group.group
      for field in group.items
        @renderDescriptionField field

# TODO: Refactor the below and make sure that the styles applied to the 
#       user generated fields are in sync with the styling in the 
#       wysiwyg editor. 
styles += """
.proposal_details br, .description_field br {
  padding-bottom: 0.5em; }
.proposal_details p, 
.proposal_details ul, 
.description_field ul, 
.proposal_details ol, 
.description_field ol, 
.proposal_details table, 
.description_field p, 
.description_field table {
  margin-bottom: 0.5em; }
.proposal_details td, .description_field td {
  padding: 0 3px; }
.proposal_details li, .description_field li {
  list-style: outside; }
.proposal_details ol li, .proposal_details ol li {
  list-style-type: decimal; }  
.proposal_details ul, .description_field ul,
.proposal_details ol, .description_field ol {
  padding-left: 20px;
  margin-left: 20px; }
.proposal_details a, .description_field a {
  text-decoration: underline; }
.proposal_details blockquote, .description_field blockquote {
  opacity: 0.7;
  padding: 10px 20px; }
.proposal_details table, .description_field table {
  padding: 20px 0px; }
"""

##
# Histogram
#
# Controls the display of the users arranged on a histogram. 
# 
# The user avatars are arranged imprecisely on the histogram
# based on the user's opinion, using a physics simulation. 
#
# The pros and cons can be filtered to specific opinion regions
# (individual and collective). 
#
##
# Props
# 
#   width, height
#   enable_selection
#     Whether users can select opinions segments on the histogram
#   draw_base
#     Whether to draw a base with +/- labels. If a slider is attached,
#     don't need the labels.
#
##
# The interaction rules: 
#
# Selection
#   * Click on a user in the histogram, show that user's opinion:
#      - Filter decision board points to those included by this user
#      - Show a second, larger image of the user and their name in
#         the region between the histogram and decision board
#   * Click an area of the histogram unoccupied by a user, when 
#     not already in selection mode, to enter selection mode:
#      - Show the collective opinions of the users in that region. 
#         Rerank the points in the decision board accordingly.
#   * Move the mouse in histogram when in group selection mode:
#      - selected opinions dynamically updated based on mouse position 
#      - selection region stays entirely within the histogram 
#   * Drag the edges of the region selection top edge to resize the selection
#
# Deselection
#   * If a single user is selected, clicking anywhere outside of that 
#     user's picture in the histogram or opinion area will deselect
#   * If a region is selected, clicking anywhere except within the 
#     decision board will deselect the region.
#
# Note that for mobile, region resizing is disabled, and the selection 
# changes on touch move rather than mousemove.
# 
##
# Selected region background
#   * A selection region background follows the mouse in the histogram if:
#      - we're in group selection mode
#      - we're hovering over the histogram in 
#   * Show a border at the top if in group selection mode
#
# The selection region is imprecise. It defines
# a selection region based on the real values of the users' opinions,
# _not_ the imprecise location of the avatar's position on the 
# histogram. This can cause some confusion as to who will be 
# highlighted. 
#
# Other components can also request that certain users be 
# highlighted in the histogram, though the pros/cons will 
# NOT be filtered as a consequence of the highlighting. 
# This occurs when someone mouses over the inclusion pogs
# for a point. 
#
# State design for histogram:
#
# Global state stored at 'histogram':
#   selection_opinion
#      If set, an opinion key for an avatar that was clicked
#   selected_opinions
#      Array of opinion keys defining the current set of selected opinions. 
#   selected_opinion_value
#      The opinion value around which the current selection is defined  
#   region_selection_width
#      The width of the opinion selection region. 
#   highlighted_users
#      Users that other components want to have highlighted in the 
#      histogram. In the render, this is intersected with the users whose 
#      opinions are selected to determine which avatars are highlighted. 
#   dragging
#      Whether the user is currently dragging the mouse through the
#      histogram. 
#
# Local state: 
#   simulation_opinion_hash
#      Hash of all opinion stances. Used to determine if the physics
#      simulation needs to be rerun on a rerender.
#   mouse_opinion_value
#      Stores the mapped opinion value of the current mouse position
#      within the histogram. 
#   last_selection_via_drag
#      Whether the last time the selection region moved was done by dragging
#      in the histogram. This is used to resolve a technicality with 
#      the order in which mouseUp and mouseClick events are fired. 
#   avatar_size
#      The base size of the avatars, as determined by the physics 
#      simulation. This piece of state would be local, but it needs
#      to be settable from the physics simulation.
#   mouse_x_of_last_resize
#      Stores last mouse position when in selection area resize mode.

Histogram = ReactiveComponent
  displayName : 'Histogram'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render: -> 
    hist = fetch('histogram')

    options = customization("cluster_options.#{@props.proposal.cluster}") || {}
    filter_func = options.homie_histo_filter

    # We'll only pass SOME opinions to the histogram
    @opinions = fetch('/page/' + @props.proposal.slug).opinions
    @opinions = (opinion for opinion in @opinions when \
                 not filter_func or filter_func(fetch(opinion.user)))

    avatar_radius = calculateAvatarRadius(@props.width, @props.height, @opinions)
    if @local.avatar_size != avatar_radius * 2
      @local.avatar_size = avatar_radius * 2
      save @local

    # There are a few avatar styles that might be applied depending on state:
    # 1) Regular, for when no user is selected
    regular_avatar_style =
      width: @local.avatar_size
      height: @local.avatar_size
      position: 'absolute'
      cursor: if @props.enable_selection then 'pointer' else 'auto'

    # 2) The style of a selected avatar
    selected_avatar_style = _.extend {}, regular_avatar_style, 
      zIndex: 9
      backgroundColor: focus_blue
    css.crossbrowserify selected_avatar_style
    # 3) The style of an unselected avatar when some other avatar(s) is selected
    unselected_avatar_style = css.grayscale _.extend {}, regular_avatar_style, 
      opacity: .2

    # 4) The style of the avatar on the crafting page
    crafting_page_avatar_style = _.extend {}, unselected_avatar_style, 
      opacity: .1

    # Highlighted users are the users whose avatars are colorized and fully 
    # opaque in the histogram. It is based on the current opinion selection and 
    # the highlighted_users state, which can be manipulated by other components. 
    highlighted_users = hist.highlighted_users
    selected_users = if hist.selected_opinion 
                       [hist.selected_opinion] 
                     else 
                       hist.selected_opinions
    if selected_users
      if highlighted_users
        highlighted_users = _.intersection highlighted_users, \
                                          (fetch(o).user for o in selected_users)
      else 
        highlighted_users = (fetch(o).user for o in selected_users)

    # whether to show the shaded opinion selection region in the histogram
    draw_selection_area = @props.enable_selection &&
                            !hist.selected_opinion && 
                            @root.proposal_mode == 'results' &&
                            (hist.selected_opinions || 
                              (!@local.touched && 
                                @local.mouse_opinion_value && 
                                !@local.hoving_over_avatar))

    # Controls the size of the vertical space at the top of 
    # the histogram that gives some space for users to hover over 
    # the most populous areas
    region_selection_vertical_padding = if @props.enable_selection then 30 else 0


    histogram_props = 
      className: 'histogram'
      style: css.crossbrowserify
        width: @props.width
        height: @props.height + region_selection_vertical_padding
        position: 'relative'
        borderBottom: if @props.draw_base then '1px solid #999'
        visibility: if @opinions.length == 0 then 'hidden'
        userSelect: 'none'



    if @props.enable_selection
      _.extend histogram_props,
        onClick: @onClick
        onMouseMove: @onMouseMove
        onMouseLeave: @onMouseLeave
        onMouseUp: @onMouseUp
        onMouseDown: @onMouseDown

        onTouchStart: (ev) => 
          ev.preventDefault()
          @local.touched = true
          save hist
          save @local
          @onClick(ev)

        onTouchMove: (ev) => ev.preventDefault(); @onMouseMove(ev)
        onTouchEnd: (ev) => ev.preventDefault(); @onMouseUp(ev)
        onTouchCancel: (ev) => ev.preventDefault(); @onMouseUp(ev)

    DIV histogram_props, 

      if @props.draw_base
        [SPAN
          style:
            position: 'absolute'
            left: -21
            bottom: -12
            fontSize: 19
            fontWeight: 500
            color: '#999'
          '–'
        SPAN
          style:
            position: 'absolute'
            right: -21
            bottom: -13
            fontSize: 19
            fontWeight: 500
            color: '#999'
          '+']

      if @props.enable_selection
        # A little padding at the top to give some space for selecting
        # opinion regions with lots of people stacked high      
        DIV style: {height: region_selection_vertical_padding}

      # Draw the opinion selection area + region resizing border
      if draw_selection_area
        anchor = hist.selected_opinion_value or @local.mouse_opinion_value
        left = ((anchor + 1)/2 - hist.region_selection_width/2) * @props.width
        base_width = hist.region_selection_width * @props.width
        selection_width = Math.min( \
                            Math.min(base_width, base_width + left), \
                            @props.width - left)
        selection_left = Math.max 0, left

        DIV null,
          if hist.selected_opinions
            DIV 
              className: 'selection_region_resizer'
              style: 
                borderBottom: "3px solid #{focus_blue}"
                height: 15
                width: selection_width
                position: 'absolute'
                left: selection_left
                top: -15
                cursor: 'col-resize'

          DIV 
            style:
              height: @props.height + region_selection_vertical_padding
              position: 'absolute'
              width: selection_width
              backgroundColor: "rgb(246, 247, 249)"
              cursor: 'pointer'
              left: selection_left
              top: 0

            if !hist.selected_opinions
              DIV
                style: css.crossbrowserify
                  fontSize: 12
                  textAlign: 'center'
                  whiteSpace: 'nowrap'
                  marginTop: -18
                  userSelect: 'none'
                  pointerEvents: 'none'

                'Select these opinions'

      # Draw the avatars in the histogram. Placement will be determined later
      # by the physics sim
      DIV 
        ref: 'histo'
        style: 
          height: @props.height
          position: 'relative'
          top: -1
          cursor: if @root.proposal_mode == 'results' && 
                      @props.enable_selection then 'pointer'

        for opinion in @opinions
          user = opinion.user
          fetch(opinion) # subscribe to changes so physics sim will get rerun...

          if highlighted_users
            if _.contains(highlighted_users, opinion.user)   
              avatar_style = selected_avatar_style
            else
              avatar_style = unselected_avatar_style
          else if @root.proposal_mode == 'crafting'
            avatar_style = if fetch('/current_user').user == user 
                             _.extend({}, regular_avatar_style, {opacity: .25}) 
                           else 
                             crafting_page_avatar_style
          else
            avatar_style = regular_avatar_style

          Avatar 
            key: user
            user: user
            hide_tooltip: @root.proposal_mode == 'crafting'
            style: avatar_style


  onClick: (ev) -> 

    ev.stopPropagation()
    hist = fetch('histogram')

    if @root.proposal_mode == 'crafting'
      togglePage('results', 'click_histogram')

    else
      if ev.type == 'touchstart'
        @local.mouse_opinion_value = @getOpinionValueAtFocus(ev)

      is_clicking_user = ev.target.className.indexOf('avatar') != -1

      if is_clicking_user
        user_key = "/user/" + ev.target.getAttribute('id')
                               .substring(7, ev.target.getAttribute('id').length)
        user_opinion = _.findWhere @opinions, {user: user_key}
        is_deselection = hist.selected_opinion == user_opinion.key && 
                          !@local.last_selection_via_drag
        if is_deselection
          hist.selected_opinion = null
        else 
          hist.selected_opinion = user_opinion.key
          hist.selected_opinions = null
      else
        max = hist.selected_opinion_value + hist.region_selection_width
        min = hist.selected_opinion_value - hist.region_selection_width
        is_deselection = \
          hist.selected_opinions && 
           !@local.last_selection_via_drag &&
           (!@local.touched || inRange(@local.mouse_opinion_value, min, max))

        if is_deselection
          hist.selected_opinions = null
          if ev.type == 'touchstart'
            @local.mouse_opinion_value = null
        else
          hist.selected_opinion = null
          hist.selected_opinions = @getOpinionsInCurrentRegion()

      has_selection = hist.selected_opinion || hist.selected_opinions
      hist.selected_opinion_value = if !has_selection 
                                      null 
                                    else if !is_clicking_user 
                                      @local.mouse_opinion_value 
                                    else 
                                      user_opinion.stance
      @local.last_selection_via_drag = false

      save hist
      save @local


  getOpinionValueAtFocus: (ev) -> 
    # Calculate the mouse_opinion_value (the slider value about which we determine
    # the selection region) based on the mouse offset within the histogram element.
    h_x = @getDOMNode().getBoundingClientRect().left + window.pageXOffset
    h_w = @getDOMNode().offsetWidth
    m_x = ev.pageX or ev.touches[0].pageX

    translatePixelXToStance m_x - h_x, h_w

  onMouseMove: (ev) -> 
    return if fetch('slider').is_moving

    if @root.proposal_mode == 'results'
      hist = fetch('histogram')
      ev.stopPropagation()

      # handle drag resizing selection area
      if hist.dragging
        h_w = @getDOMNode().offsetWidth
        mouse_x = ev.pageX
        change_in_selection_region = 2 * (mouse_x - @local.mouse_x_of_last_resize) / h_w
        hist.region_selection_width += change_in_selection_region
        hist.region_selection_width = Math.min( 1, Math.max(.03, \
                                                     hist.region_selection_width))
        @local.mouse_x_of_last_resize = mouse_x
        @local.last_selection_via_drag = true
        save @local
        save hist
      else if $(ev.target).closest('.selection_region_resizer').length == 0
        @local.hoving_over_avatar = ev.target.className.indexOf('avatar') != -1
        @local.mouse_opinion_value = @getOpinionValueAtFocus(ev)

        if @local.mouse_opinion_value + hist.region_selection_width >= 1
          @local.mouse_opinion_value = 1 - hist.region_selection_width
        else if @local.mouse_opinion_value - hist.region_selection_width <= -1
          @local.mouse_opinion_value = -1 + hist.region_selection_width
        
        # dynamic selection on drag
        if hist.selected_opinions &&
            @local.mouse_opinion_value # this last conditional is only for touch
                                       # interactions where there is no mechanism 
                                       # for "leaving" the histogram
          hist.selected_opinions = @getOpinionsInCurrentRegion()
          hist.selected_opinion_value = @local.mouse_opinion_value 
          save hist

        save @local

  onMouseLeave: (ev) -> 
    return if fetch('slider').is_moving
    @local.mouse_opinion_value = null
    save @local

    hist = fetch('histogram')         
    if hist.dragging
      hist.dragging = false
      save hist


  onMouseUp: (ev) -> 
    return if fetch('slider').is_moving
    hist = fetch('histogram')     
    
    if hist.dragging
      hist.dragging = false
      save hist

  onMouseDown: (ev) -> 
    return if fetch('slider').is_moving
    ev.stopPropagation()

    hist = fetch('histogram')
    if $(ev.target).closest('.selection_region_resizer').length > 0 && 
        hist.selected_opinions && 
        !@local.touched
      hist.dragging = true
      @local.mouse_x_of_last_resize = ev.pageX
      save hist

    return false 
      # The return false prevents text selections
      # of other parts of the page when dragging
      # the selection region around.

  getOpinionsInCurrentRegion : -> 
    # return the opinions whose stance is within +/- region_selection_width 
    # of the moused over area of the histogram
    hist = fetch('histogram')
    all_opinions = fetch('/page/' + @props.proposal.slug).opinions || []  
    min = @local.mouse_opinion_value - hist.region_selection_width
    max = @local.mouse_opinion_value + hist.region_selection_width
    selected_opinions = (o.key for o in all_opinions when inRange(o.stance, min, max))
    selected_opinions

  physicsSimulation: ->

    # We only need to rerun the sim if the distribution of stances has changed, 
    # or the width/height of the histogram has changed. We round the stance to two 
    # decimals to avoid more frequent recalculations than necessary (one way 
    # this happens is with the server rounding opinion data differently than 
    # the javascript does when moving one's slider)
    simulation_opinion_hash = JSON.stringify _.map(@opinions, (o) => 
      Math.round(fetch(o.key).stance * 100) / 100 )

    simulation_opinion_hash += " (#{@props.width}, #{@props.height})"

    if @refs && @refs.histo && simulation_opinion_hash != @local.simulation_opinion_hash
      page = fetch('/page/' + @props.proposal.slug)
      histo = @refs.histo.getDOMNode()

      icons = histo.childNodes
      if icons.length == @opinions.length
        opinions = for opinion, i in @opinions
          {stance: opinion.stance, icon: icons[i], radius: icons[i].style.width/2}

        positionAvatars(@props.width, @props.height, opinions)
        
        @local.simulation_opinion_hash = simulation_opinion_hash
        save @local

  componentDidMount: -> @physicsSimulation()
  componentDidUpdate: -> @physicsSimulation()


##
# Slider
# Manages the slider and the UI elements attached to it. Specifically: 
#   - a slider base
#   - labels for the poles of the slider
#   - a draggable slider handle
#   - feedback description about the current opinion
#
#
#
#
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  render : ->

    slider = fetch('slider')
    hist = fetch('histogram')
    set_in_grayscale = @root.selected_point && @root.proposal_mode == 'crafting'


    # Update the slider position when the server gets back to us
    your_opinion = fetch(@proposal.your_opinion)
    if slider.stance != your_opinion.stance and !slider.is_moving
      slider.stance = your_opinion.stance
      slider.clientX = @props.width * (slider.stance / 2 + .5)
      if your_opinion.stance
        slider.has_moved = true
      save(slider)

    ####
    # Define slider layout
    slider_style = 
      position: 'relative'
      left: - (@props.width - BODY_WIDTH) / 2
      width: @props.width
      height: SLIDER_HANDLE_SIZE

    if set_in_grayscale
      css.grayscale slider_style

    ####
    # Define slider base
    slider_base_style = 
      width: @props.width
      height: 6
      backgroundColor: if @root.proposal_mode == 'crafting' then '#AFD7FF' else '#787878'
      position: 'absolute'


    ####
    # Define slider handle

    # Check whether the user has permission to opine, which affects whether a 
    # slider handle is shown. 
    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    enable_opining = !(hist.selected_opinions || hist.selected_opinion) &&
                      (can_opine not in [Permission.DISABLED, \
                                         Permission.INSUFFICIENT_PRIVILEGES] || 
                      your_opinion.published )

    draw_handle = enable_opining
    if draw_handle

      handle_style =
        boxShadow: "0px 1px 0px black, " + \
                   "inset 0 1px 2px rgba(255,255,255, .4), " + \
                   "0px 0px 0px 1px #{focus_blue}"            
        backgroundColor: focus_blue      
        left: slider.clientX
        zIndex: 10
        borderRadius: '50%'
        width: SLIDER_HANDLE_SIZE
        height: SLIDER_HANDLE_SIZE
        marginLeft: -SLIDER_HANDLE_SIZE / 2
        top: -9
        position: 'relative'
        visibility: if set_in_grayscale then 'hidden'

      face_style = 
        position: 'absolute'
        pointerEvents: 'none'
        borderRadius: '50%'

      eye_size = .8 + .2 * Math.abs(slider.stance)
      eye_style = _.extend {}, face_style,
        backgroundColor: 'white'
        top: 6
        width: 3
        height: 3
        transform: "scale(#{eye_size}, #{eye_size})"

      mouth_scale_y = .4 * slider.stance
      mouth_y = if Math.abs(mouth_scale_y) < .08 
                  (if mouth_scale_y >= 0 then 1 else -1) * .08 
                else 
                  mouth_scale_y
      mouth_style = _.extend {}, face_style,
        bottom: -1
        width: SLIDER_HANDLE_SIZE - 4
        left: 2
        height: SLIDER_HANDLE_SIZE - 4
        boxShadow: '3px 3px 0 0 white'
        transform: 
          "scale(#{.4 + .3 * Math.abs(slider.stance)}, #{mouth_y}) " + \
          "translate(0, #{-2 - 5 * Math.abs(slider.stance)}px) " + \
          "rotate(45deg)"


    ####
    # Define slider feedback
    draw_feedback = @root.proposal_mode == 'crafting' && 
                     draw_handle
    
    if draw_feedback
      slider_feedback = 
        if !slider.has_moved 
          'Slide Your Overall Opinion' 
        else if isNeutralOpinion(slider.stance)
          "You are Undecided"
        else 
          degree = Math.abs(slider.stance)
          strength_of_opinion = if degree > .999
                                  "Fully "
                                else if degree > .5
                                  "Firmly "
                                else
                                  "Slightly " 

          valence = customization "slider_pole_labels.individual." + \
                                  if slider.stance > 0 then 'support' else 'oppose'

          "You #{strength_of_opinion} #{valence}"

      feedback_style = 
        pointerEvents: 'none' 
        fontSize: 30
        fontWeight: 700
        color: focus_blue
        visibility: if set_in_grayscale then 'hidden'

      # Keep feedback centered over handle, but keep within the bounds of 
      # the slider region when the slider is in an extreme position. 
      feedback_left = @props.width * (slider.stance/2 + .5)
      feedback_width = widthWhenRendered(slider_feedback, feedback_style) + 10

      if slider.docked 
        if slider.stance > 0
          feedback_left = Math.min(@props.width - feedback_width/2, feedback_left)
        else
          feedback_left = Math.max(feedback_width/2, feedback_left)

      _.extend feedback_style, 
        position: 'absolute'      
        top: if slider.docked then -57 else -80      
        left: feedback_left
        marginLeft: -feedback_width / 2
        width: feedback_width


    DIV 
      className: 'slider'
      style : slider_style

      # Draw the pole labels of the slider      
      if !slider.docked
        group = if @root.proposal_mode == 'crafting' then 'individual' else 'group'
        for pole in ['oppose', 'support']  
          w = widthWhenRendered \
                customization("slider_pole_labels.#{group}.#{pole}"), \
                {fontSize: 30}
          DIV 
            key: "pole_#{pole}"
            style: 
              position: 'absolute'
              fontSize: 30
              top: -20
              pointerEvents: 'none'
              left: if pole == 'oppose' then -(w + 55)
              right: if pole == 'support' then -(w + 55)

            customization("slider_pole_labels.#{group}.#{pole}")

            DIV 
              key: "pole_#{pole}_sub"
              style: 
                fontSize: 14
                textAlign: 'center'

              customization("slider_pole_labels.#{group}.#{pole}_sub")
      else
        for pole in ['oppose', 'support']  
          DIV 
            key: "pole_#{pole}"
            style: 
              position: 'absolute'
              fontSize: 20
              top: -12
              pointerEvents: 'none'
              left: if pole == 'oppose' then -15
              right: if pole == 'support' then -20

            if pole == 'oppose' then '–' else '+'

      # Draw the base of the slider
      DIV 
        style : slider_base_style

        if !slider.docked

          for support in [true, false]
            DIV 
              style: 
                position: 'absolute'
                left: if support then -5
                right: if !support then -5
                width: 5
                height: slider_base_style.height
                backgroundColor: slider_base_style.backgroundColor

              DIV
                style: cssTriangle \
                         (if support then 'left' else 'right'), \
                         slider_base_style.backgroundColor, 12, 6,               
                            position: 'absolute'
                            left: if support then -12
                            right: if !support then -12

      if draw_feedback
        DIV 
          style: feedback_style
          slider_feedback

      if draw_handle
        DIV 
          className: 'the_handle' 
          onMouseUp: @handleMouseUp
          onTouchEnd: @handleMouseUp
          onTouchCancel: @handleMouseUp

          onMouseDown: @handleMouseDown
          onTouchStart: @handleMouseDown

          onTouchMove: @handleMouseMove
          style: css.crossbrowserify handle_style

          if @root.proposal_mode == 'crafting'
           [DIV 
              style: css.crossbrowserify(mouth_style)
            DIV 
              style: css.crossbrowserify(_.defaults({left: 6}, eye_style))
            DIV 
              style: css.crossbrowserify(_.defaults({right: 6}, eye_style ))
           ]

          if @root.proposal_mode == 'crafting' && !slider.has_moved
            for support in [true, false]
              DIV 
                style: 
                  right: if support then -15
                  left: if !support then -15
                  position: 'absolute'
                  top: 3
                  color: focus_blue
                  fontSize: 12              
                if support then '>' else '<'



  # Kick off sliding 
  handleMouseDown: (e) -> 
    el = @getDOMNode()
    # Dragging has to start by dragging the slider handle
    return if !$(e.target).is('.the_handle')

    e.preventDefault()

    # Initiate dragging
    slider = fetch('slider')
    slider.is_moving = true
    slider.offsetX = e.clientX or e.touches[0].clientX

    slider.startX = parseInt($(e.target)[0].style.left, 10) || 0
    save slider

    $(window).on "mousemove.slider", @handleMouseMove
    $(window).on "mouseup.slider", @handleMouseUp

  # Stop sliding
  handleMouseUp: (e) ->
    # Don't do anything if we're not actually dragging. We only hit this logic
    # if there is some delay in removing the event handlers.
    slider = fetch 'slider'

    return if !slider.is_moving

    e.preventDefault()

    your_opinion = fetch(@proposal.your_opinion)
    
    # Clicking on the slider handle should transition us between 
    # crafting <=> results. We should also transition to crafting 
    # when we've been dragging on the results page. 
    if slider.stance == your_opinion.stance || @root.proposal_mode == 'results'
      new_page = if @root.proposal_mode == 'results' then 'crafting' else 'results'
      togglePage new_page, 'click_slider'
      e.stopPropagation()

    # We save the slider's position to the server only on mouse-up.
    # This way you can drag it with good performance.
    if your_opinion.stance != slider.stance
      your_opinion.stance = slider.stance
      save your_opinion
      window.writeToLog 
        what: 'move slider'
        details: {stance: slider.stance}

    # Turn off dragging
    slider.is_moving = false
    save slider

    $(window).off ".slider" # Remove event handlers

  # While sliding
  handleMouseMove: (e) ->
    e.preventDefault() # prevents text selection of surrounding elements

    slider = fetch('slider')

    clientX = e.clientX or e.touches[0].clientX

    # Update position
    slider.clientX = slider.startX + clientX - slider.offsetX
    slider.clientX = 0 if slider.clientX < 0
    slider.clientX = @props.width if slider.clientX > @props.width
    slider.has_moved = true

    # convert position of handle to a slider value on [1, -1]
    slider.stance = translatePixelXToStance(slider.clientX, @props.width)

    save slider


styles += """
#{css.grab_cursor('.the_handle')}
"""



##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'
  mixins: [PageTransition] # animation logic when moving results <==> crafting

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')
    hist = fetch('histogram')
    
    your_opinion = fetch(@proposal.your_opinion)

    register_dependency = fetch('slider').clientX 
                             # to keep bubble mouth in sync with slider

    selected_point = @root.selected_point && @root.proposal_mode == 'crafting'
    selected_wing_point = selected_point && 
                           !_.contains(your_opinion.point_inclusions, \
                                       @root.selected_point)
    
    decision_board_style =
      borderRadius: 16
      borderStyle: 'dashed'
      borderWidth: 3
      borderColor: focus_blue


    if @local.user_hovering_on_drop_target
      decision_board_style.borderStyle = 'solid'

    if @root.proposal_mode == 'results'
      _.extend decision_board_style,
        borderStyle: 'solid'
        backgroundColor: focus_blue
        boxShadow: '0px 2px 0px black'
        cursor: 'pointer'

    if selected_wing_point
      css.grayscale decision_board_style
      decision_board_style.opacity = '.4'
    else if selected_point
      decision_board_style.borderColor = "#ccc"

    if your_opinion.published
      can_opine = permit 'update opinion', @proposal, your_opinion
    else
      can_opine = permit 'publish opinion', @proposal

    enable_opining = can_opine != Permission.INSUFFICIENT_PRIVILEGES && 
                      (can_opine != Permission.DISABLED || your_opinion.published ) && 
                      !(hist.selected_opinions || hist.selected_opinion)


    DIV 
      className:'opinion_region'
      style:
        width: DECISION_BOARD_WIDTH

      if enable_opining        
        Bubblemouth()


      if enable_opining
        # only shown during results, but needs to be present for animation
        if @root.proposal_mode == 'results'
          give_opinion_style = 
            display: 'block'
            color: 'white'
            padding: '.25em 18px'
            margin: 0
            fontSize: 16
            boxShadow: 'none'
        else
          give_opinion_style = {}

        [DIV 
          className:'decision_board_body'
          style: decision_board_style
          onClick: => 
            if @root.proposal_mode == 'results' 
              togglePage('crafting', 'give_opinion_button')

          DIV null, 
            # only shown during crafting, but needs to be present always for animation
            DIV 
              className: 'your_points'
              style: 
                padding: '0 18px'
                marginTop: -3 # To undo the 3 pixel border
              YourPoints { key: 'your_con_points', valence: 'cons' }
              YourPoints { key: 'your_pro_points', valence: 'pros' }


            A 
              className: 'give_opinion_button primary_button'
              style: give_opinion_style

              if your_opinion.published 
                'Update your Opinion' 
              else 
                'Give your Opinion'

        DIV 
          style:
            width: DECISION_BOARD_WIDTH

          # Big bold button at the bottom of the crafting page
          DIV 
            className:'save_opinion_button primary_button'
            onClick: => 
              your_opinion = fetch(@proposal.your_opinion)
              if can_opine > 0
                your_opinion.published = true
                save your_opinion
                togglePage('results', 'save_button')
              else
                if can_opine == Permission.UNVERIFIED_EMAIL
                  auth_form = 'verify email'
                  current_user.trying_to = 'send_verification_token'
                  save current_user
                else if can_opine == Permission.INSUFFICIENT_INFORMATION
                  auth_form = 'user questions'
                else
                  auth_form = 'create account'

                @root.auth = {
                  form: auth_form, goal: 'Save your Opinion', ask_questions: true}

                # We'll need to publish this opinion after auth is completed
                @root.opinions_to_publish.push(@proposal.your_opinion)

                save @root

            if your_opinion.published 
              'See the results' 
            else 
              'Save your opinion and see results'

          if @root.proposal_mode == 'crafting'
            A 
              style: 
                marginTop: '.5em'
                padding: 3
                display: 'inline-block'

              INPUT
                type:      'checkbox'
                id:        "follow_proposal"
                name:      "follow_proposal"
                checked:   @proposal.is_following
                style: 
                  fontSize: 21
                  cursor: 'pointer'
                onChange: =>
                  @proposal.is_following = !@proposal.is_following
                  save @proposal
              LABEL 
                htmlFor: "follow_proposal"
                title:'''
                      We\'ll send periodic email notifications summarizing 
                      activity on the proposal, as well as alerts about new 
                      pro and con points. You can easily unsubscribe later.'''
                style: 
                  marginLeft: 6
                  fontSize: 16
                  color: '#888'
                  cursor: 'pointer'   
                'Notify me about new activity'

          if !your_opinion.published
            A 
              className:'cancel_opinion_button primary_cancel_button'
              onClick: => togglePage('results', 'cancel_button')
              'or just skip to the results' ]
          


  componentDidMount : ->
    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = fetch(@proposal.your_opinion)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)

            window.writeToLog
              what: 'included point'
              details: 
                point: ui.draggable.parent().data('id')

          @local.user_hovering_on_drop_target = false
          save @local

      out : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = false
          save @local

      over : (ev, ui) => 
        if ui.draggable.parent().is('.community_point')
          @local.user_hovering_on_drop_target = true
          save @local

Bubblemouth = ReactiveComponent
  displayName: 'Bubblemouth'
  mixins: [PageTransition] # animation logic when moving results <==> crafting

  render : -> 
    slider = fetch('slider')
    # Can't be dynamically set b/c of integration with asset fingerprinting. 
    # This is also why this file is ERB.
    bubblemouth_srcs = 
      neutral : 
        crafting: "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
        results: "<%= asset_path 'bubblemouth_neutral-results.png' %>"
      other : 
        crafting: "<%= asset_path 'bubblemouth-crafting.png' %>"
        results: "<%= asset_path 'bubblemouth-results.png' %>"

    bubblemouth_src = if isNeutralOpinion(slider.stance) 
                        bubblemouth_srcs['neutral'][@root.proposal_mode] 
                      else
                        bubblemouth_srcs['other'][@root.proposal_mode]

    bubblemouth_style = 
      left: translateStanceToPixelX slider.stance, DECISION_BOARD_WIDTH
      position: 'absolute'
      width: 18
      pointerEvents: 'none'
      zIndex: 10
      marginLeft: -9
      top: -25
      visibility: if @root.selected_point then 'hidden'

    IMG 
      className:'bubblemouth'
      src: bubblemouth_src
      style: bubblemouth_style



##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  render : ->
    included_points = fetch(@proposal.your_opinion).point_inclusions    
    left_or_right = if @props.valence == 'pros' then 'right' else 'left'

    can_add_new_point = permit 'create point', @proposal

    your_points = @data @props.key,
      editing_points : []
      adding_new_point : false

    header_style =           
      fontWeight: 700
      color: if @root.selected_point then "#ccc" else focus_blue

    DIV 
      className: "points_on_decision_board #{@props.valence}_on_decision_board"
      style: 
        width: POINT_WIDTH
        marginTop: 28

      DIV 
        className:'points_heading_label'
        style: header_style
        "Give Your #{capitalize(@props.valence)}"

      UL null,
        for point in included_points

          if fetch(point).is_pro == (@props.valence == 'pros')
            if point in your_points.editing_points
              EditPoint 
                key: point
                fresh: false
                valence: @props.valence
                your_points_key: @props.key
            else
              Point
                key: point
                rendered_as: 'decision_board_point'
                your_points_key: @props.key

        #drop target
        DIV 
          style: 
            padding: '0 0 .25em 9px'
            position: 'relative'

          IMG 
            src: "<%= asset_path 'drop_target.png' %>"
            style: css.crossbrowserify
              transform: if @props.valence == 'cons' then '' else 'scaleX(-1)'
              width: 223

          SPAN 
            style:
              fontSize: 14
              position: 'absolute'
              top: '1.4em'
              left: if @props.valence == 'cons' then 36 else 29
              width: 180

            "Drag a "
            capitalize(if @props.valence=='pros' then 'pro' else 'con')
            " from the #{left_or_right}"

        if can_add_new_point != Permission.INSUFFICIENT_PRIVILEGES
          if !your_points.adding_new_point
            DIV 
              style: 
                padding: '.25em 0'
                marginTop: '1em'
                marginLeft: 20
                fontSize: 14

              SPAN 
                style: 
                  fontWeight: if browser.high_density_display then 300 else 400
                'or '
              SPAN 
                style: {padding: '0 6px'}
                dangerouslySetInnerHTML:{__html: '&bull;'}
              A 
                style:
                  textDecoration: 'underline'
                  color: focus_blue
                onClick: => 
                  if can_add_new_point == Permission.NOT_LOGGED_IN
                    @root.auth = {form: 'create account', goal: 'write a point'}
                    save @root
                  else if can_add_new_point == Permission.UNVERIFIED_EMAIL
                    @root.auth = {form: 'verify email', goal: 'write a point'}
                    save @root
                    current_user.trying_to = 'send_verification_token'
                    save current_user

                  else
                    your_points.adding_new_point = true
                    save your_points

                  writeToLog {what: 'click new point'}

                "Write a new "
                capitalize(if @props.valence == 'pros' then 'pro' else 'con')

          else
            EditPoint
              key: "new_point_#{@props.valence}"
              fresh: true
              valence: @props.valence
              your_points_key: @props.key

styles += """
.points_by_community, .points_on_decision_board {
  display: inline-block;
  vertical-align: top; }

.points_heading_label {
  text-align: center;
  margin-bottom: 18px;
  margin-top: 7px;
  font-size: 30px; }

"""


##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'
  mixins: [PageTransition] # animation logic when moving results <==> crafting
  render : ->

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key
    con_is_selected = @root.selected_point and not fetch(@root.selected_point).is_pro

    # TODO: The minheight below is not a principled or complete solution to two
    #       sizing issues: 
    #           1) resizing the reasons region when the height of the decision board 
    #              (which is absolutely positioned) grows taller the wing points
    #           2) when filtering the points on result page to a group of opinions 
    #              with few inclusions, the document height can jarringly fluctuate
    DIV
      className: "points_by_community #{@props.key}_by_community"
      style:
        width: POINT_CONTENT_WIDTH
        minHeight: (if @page.points.length > 4 then jQuery(window).height() else 400)
        zIndex: if con_is_selected and @props.key == 'cons' then 6 else 2
        margin: '38px 18px 0 18px'
        position: 'relative'

      DIV 
        className:'points_heading_label'
        style: 
          position: 'relative'
          left: if @props.key == 'cons' then -20 else 20
            # Mike: I wanted the headers to be centered over the ENTIRE
            # points including avatars, not just bubbles.  But the
            # avatars are sticking out on their own, so I simulated
            # a centered look with these -20px and +20px offsets

        if fetch('root').proposal_mode == 'results' 
          "Top #{label}" 
        else 
          "Others' #{label}"

      UL null,
        if points.length > 0
          for point in points
            Point
              key: point.key,
              is_new: Date.parse(point.created_at) > newpoint_threshold
              rendered_as : 'community_point'
        else
          LI 
            style: 
              marginTop: 50
              fontStyle: 'italic'
              listStyle: 'none'
              textAlign: 'center'
              fontWeight: if browser.high_density_display then '300' else '400'

            "No #{label} given"

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @page.points || []
    newpoint_threshold = 
      (_.sortBy points, \
                (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = fetch('root').proposal_mode == 'results'
    hist = fetch('histogram')

    selected_opinions = if hist.selected_opinion 
                          [hist.selected_opinion] 
                        else 
                          hist.selected_opinions

    included_points = fetch(@proposal.your_opinion).point_inclusions
    points = @page.points
    opinions = @page.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_opinions
      # Filter down to the points included in the selection opinions, and 
      # order them by resonance to those users.

      point_inclusions_per_point = {} # map of points to including users
      _.each selected_opinions, (opinion_key) =>
        opinion = fetch(opinion_key)
        if opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point)
              point_inclusions_per_point[point] = 1
            else
              point_inclusions_per_point[point] += 1

      points = (pnt for pnt in points when pnt.key of point_inclusions_per_point)
      points = _.sortBy points, (pnt) -> -point_inclusions_per_point[pnt.key]
    else
      # Default sort order
      points = _.sortBy points, (pnt) => 
                          if is_results then -pnt.score else -pnt.last_inclusion

    points

styles += """

"""


##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  render : ->
    point = @data()

    is_selected = @root.selected_point == @props.key

    current_user = fetch('/current_user')


    renderIncluders = (draw_all_includers) =>

      if @data().includers

        if !draw_all_includers
          includers = [point.user]
        else 
          includers = @buildIncluders()

        s = #includers_style
          rows: 8
          dx: 2
          dy: 5
          col_gap: 8
          side_offset: if @props.rendered_as == 'decision_board_point' then 10 else 47

        if includers.length == 0
          includers = [point.user]

        # Now we'll go through the list from back to front
        i = includers.length

        for includer in includers
          i -= 1
          curr_column = Math.floor(i / s.rows)
          side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
          top_offset = (i % s.rows) * s.dy 
          left_right = if @data().is_pro then 'right' else 'left'
          style = { top: top_offset }
          style[left_right] = -side_offset

          # Finally draw the guys
          Avatar
            key: includer
            className: "point_includer_avatar"
            style: style
            hide_tooltip: @props.rendered_as == 'under_review' 
            anonymous: point.user == includer && point.hide_name

    renderNewIndicator = =>
      if @data().includers
        side_offset = 48
        left_right = if @data().is_pro then 'right' else 'left'
        style = 
          position: 'absolute'
          color: 'rgb(255,22,3)'
          fontSize: '11px'
          top: -14
          #backgroundColor: 'white'
          zIndex: 5
          fontVariant: 'small-caps'
          fontWeight: 'bold'

        style[left_right] = "#{-side_offset}"
        SPAN {style: style}, '-new-'


    point_content_style = 
      width: POINT_CONTENT_WIDTH + 6
      borderWidth: 3
      borderStyle: 'solid'
      borderColor: 'transparent'
      left: -3
      top: -3

    if is_selected
      _.extend point_content_style,
        borderColor: focus_blue
        backgroundColor: 'white'

    if @props.rendered_as == 'decision_board_point'
      _.extend point_content_style,
        padding: 8
        borderRadius: 8
        top: point_content_style.top - 8
        left: point_content_style.left - 8
        width: point_content_style.width + 16

    if @props.rendered_as == 'under_review'
      _.extend point_content_style, {width: 500}


    expand_to_see_details = point.text && 
                             (point.nutshell.length + point.text.length) > 210

    select_enticement = []

    if expand_to_see_details
      select_enticement.push SPAN key: 1,
        if is_selected
          "read less"
        else
          [SPAN dangerouslySetInnerHTML: {__html: '&hellip;'}
          ' ('
          A className: 'select_point',
            "read more"
          ')']

    if point.comment_count > 0 || !expand_to_see_details
      select_enticement.push SPAN key: 2, style: {whiteSpace: 'nowrap'},
        " ("
        A 
          className: 'select_point'
          point.comment_count 
          " comment"
          if point.comment_count != 1 then 's' else ''
        ")"

    if point.assessment
      select_enticement.push SPAN key: 3,
        I
          className: 'fa fa-search'
          title: 'Click to read a fact-check of this point'
          style: 
            color: '#5E6B9E'
            fontSize: 14
            cursor: 'help'
            paddingLeft: 4


    point_style = 
      position: 'relative'
      listStyle: 'none outside none'

    if @props.rendered_as == 'decision_board_point'
      _.extend point_style, 
        marginLeft: 9
        padding: '0 18px 0 18px'

    draw_all_includers = @props.rendered_as == 'community_point'
    LI
      className: "point #{@props.rendered_as} #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
      onClick: @selectPoint
      onTouchEnd: @selectPoint
      style: point_style

      if @props.rendered_as == 'community_point' && @props.is_new
        renderNewIndicator()

      DIV 
        className:'includers'
        onMouseEnter: @highlightIncluders
        onMouseLeave: @unHighlightIncluders

        renderIncluders(draw_all_includers)

      DIV className:'point_content', style : point_content_style,
        if is_selected ||
            @props.rendered_as == 'community_point' || 
            @props.rendered_as == 'under_review'
          IMG
            className: 'community_point_mouth'
            src:  if is_selected
                    "<%= asset_path 'community_point_mouth_selected.png' %>" 
                  else 
                    "<%= asset_path 'community_point_mouth.png' %>"

        DIV className:'point_nutshell',
          splitParagraphs point.nutshell

          DIV 
            className: "point_details" + \
                       if is_selected || @props.rendered_as == 'under_review' 
                         ''
                       else 
                         '_tease'
            if point.text && point.text.length > 0
              if is_selected || 
                  !expand_to_see_details || 
                  @props.rendered_as == 'under_review'
                splitParagraphs(point.text)
              else 
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text()

            if select_enticement && @props.rendered_as != 'under_review'
              select_enticement

        DIV null,
          if permit('update point', point) > 0 && 
              @props.rendered_as == 'decision_board_point'
            A
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8

              onClick: ((e) =>
                e.stopPropagation()
                points = fetch(@props.your_points_key)
                points.editing_points.push(@props.key)
                save(points))
              SPAN null, 'edit'

          if permit('delete point', point) > 0 && 
              @props.rendered_as == 'decision_board_point'
            A 
              style:
                fontSize: 12
                color: '#999'
                paddingRight: 8
              onClick: (e) =>
                e.stopPropagation()
                if confirm('Delete this point forever?')
                  destroy @props.key
              SPAN null, 'delete'

      if is_selected
        your_opinion = fetch(@proposal.your_opinion)
        point_included = _.contains(your_opinion.point_inclusions, point.key)
        Discussion
          key:"/comments/#{point.id}"
          is_pro: point.is_pro
          in_wings: @root.proposal_mode == 'crafting' and not point_included

  componentDidMount : ->
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  componentDidUpdate : -> 
    @setDraggability()
    @ensureDiscussionIsInViewPort()

  # Hack that fixes a couple problems:
  #   - Scroll to the point when following a link from an email 
  #     notification to a point
  #   - Scroll to new point when scrolled down to bottom of long 
  #     discussion & click a new point below it
  ensureDiscussionIsInViewPort : ->
    if @root.selected_point == @props.key
      $(@getDOMNode()).ensureInView {scroll: false}

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page

    return if @props.rendered_as == 'under_review'

    disable = fetch('root').proposal_mode == 'results'

    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.rendered_as == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = fetch(@proposal.your_opinion)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, \
                                                    @props.key
          save(your_opinion)
          window.writeToLog
            what: 'removed point'
            details: 
              point: @props.key

        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable


  selectPoint: (e) ->
    # android browser needs to respond to this via a touch event;
    # all other browsers via click event. iOS fails to select 
    # a point if both touch and click are handled...sigh...
    return unless browser.is_android_browser || e.type == 'click'

    return if @props.rendered_as == 'under_review'

    e.stopPropagation()

    if @root.selected_point == @props.key # deselect
      @root.selected_point = null
      what = 'deselected a point'
    else
      what = 'selected a point'
      @root.selected_point = @props.key

    save @root

    window.writeToLog
      what: what
      details: 
        point: @props.key


  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  highlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      point = @data()
      includers = point.includers

      # For point authors who chose not to sign their points, remove them from 
      # the users to highlight. This is particularly important if the author 
      # is the only one who "included" the point. Then it is very eash for 
      # anyone to discover who wrote this point. 
      if point.hide_name
        includers = _.without includers, point.user
      hist = fetch 'histogram'
      if hist.highlighted_users != includers
        hist.highlighted_users = includers
        save(hist)

  unHighlightIncluders : -> 
    if fetch('root').proposal_mode == 'results'
      hist = fetch 'histogram'
      hist.highlighted_users = null
      save(hist)


  buildIncluders : -> 
    point = @data()
    author_has_included = _.contains point.includers, point.user
    to_remove = [point.user]

    includers = point.includers

    hist = fetch('histogram')
    selected_opinions = if hist.selected_opinion
                          [hist.selected_opinion] 
                        else 
                          hist.selected_opinions
    if selected_opinions?.length > 0      
      # only show includers from the current opinion selection
      selected_users = (fetch(o).user for o in selected_opinions)
      includers = _.intersection includers, selected_users
      author_has_included = _.contains selected_users, point.user

    includers = _.difference includers, to_remove
    if author_has_included 
      includers.push point.user
    includers
        

styles += """
.community_point_mouth {
  position: absolute;
  width: #{COMMUNITY_POINT_MOUTH_WIDTH}px;
  top: 8px;
  z-index: 1; }

.community_point.con .community_point_mouth, .under_review .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

.community_point.pro .community_point_mouth {
  right: -#{COMMUNITY_POINT_MOUTH_WIDTH}px;
  #{css.crossbrowserify({transform: 'scaleX(-1)'}, true)}; }

.decision_board_point .community_point_mouth {
  left: -#{COMMUNITY_POINT_MOUTH_WIDTH}px; }

/* war! disabled jquery UI draggable class defined with !important */
.point_content.ui-draggable-disabled {
  cursor: pointer !important; }

#{css.grab_cursor('.point_content.ui-draggable')}

.community_point .point_content, .under_review .point_content {
  border-radius: 16px;
  padding: 0.5em 9px;
  margin-bottom: 0.5em;
  background-color: #f6f7f9;
  box-shadow: #b5b5b5 0 1px 1px 0px;
  min-height: 34px; }

.point_nutshell {
  word-wrap: break-word;
  font-size: 14px; }

.point_details_tease, .point_details {
  margin-top: 0.5em;
  font-size: 14px;
  word-wrap: break-word; 
  font-weight: #{if browser.high_density_display then 300 else 400}; }
  .point_details_tease a, .point_details a {
    text-decoration: underline;
    word-break: break-all; }
  .point_details a.select_point{text-decoration: none;}

.point_details {
  display: block; }

.point_details_tease {
  cursor: pointer; }
  .point_details_tease a.select_point {
    text-decoration: none; }
    .point_details_tease a.select_point:hover {
      text-decoration: underline; }

.point_details p {
  margin-bottom: 1em; }

.point_details p:last-child {
  margin-bottom: 0; }

.point_includer_avatar {
  position: absolute;}

.under_review .point_includer_avatar {
  top: 0px;
  width: 50px;
  height: 50px;
  left: -73px;
  box-shadow: -1px 2px 0 0 #eeeeee; }

.point_includer_avatar {
  width: 22px;
  height: 22px; }

.community_point.con .point_includer_avatar {
  box-shadow: -1px 2px 0 0 #eeeeee; }

.community_point.pro .point_includer_avatar {
  box-shadow: 1px 2px 0 0 #eeeeee; }

.decision_board_point.pro .point_includer_avatar {
  left: -10px; }

"""

Comment = ReactiveComponent
  displayName: 'Comment'

  render: -> 
    comment = @data()

    if comment.editing
      # Sharing keys, with some non-persisted client data getting saved...
      EditComment fresh: false, point: comment.point, key: comment.key

    else

      DIV className: 'comment_entry',

        # Comment author name
        DIV className: 'comment_entry_name',
          fetch(comment.user).name + ':'

        # Comment author icon
        Avatar
          className: 'comment_entry_avatar'
          key: comment.user
          hide_tooltip: true

        # Comment body
        DIV className: 'comment_entry_body',
          splitParagraphs(comment.body)

        # Delete/edit button
        if permit('update comment', comment) > 0
          comment_action_style = 
            color: '#444'
            textDecoration: 'underline'
            cursor: 'pointer',
            paddingRight: 10
          DIV style: { marginLeft: 60}, 
            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                if confirm('Delete this comment forever?')
                  destroy(key)
              'delete'

            SPAN
              style: comment_action_style
              onClick: do (key = comment.key) => (e) =>
                e.stopPropagation()
                comment.editing = true
                save comment
              'edit'          

# fact-checks, edit comments, comments...
styles += """
.comment_entry {
  margin-bottom: 45px;
  min-height: 60px;
  position: relative; }

.comment_entry_name {
  font-weight: bold;
  color: #666666; }

.comment_entry_avatar {
  position: absolute;
  width: 50px;
  height: 50px; }

.comment_entry_body {
  margin-left: 60px;
  word-wrap: break-word;
  position: relative; }
  .comment_entry_body a {
    text-decoration: underline; }
  .comment_entry_body strong {
    font-weight: 600; }
  .comment_entry_body p {
    margin-bottom: 1em; }
"""

FactCheck = ReactiveComponent
  displayName: 'FactCheck'

  render : -> 
    assessment = @data()
    DIV className: 'comment_entry',

      # Comment author name
      DIV className: 'comment_entry_name',
        'Seattle Public Library Fact check:'

      # Comment author icon
      DIV className: 'magnifying_glass',
        I className: 'fa fa-search'

      # Comment body
      DIV className: 'comment_entry_body',
        DIV style: {margin: '10px 0 20px 0'},
          "A citizen requested research into the claims made by this point. "
          SPAN style: {fontSize: 12},
            A 
              style: {fontWeight: 700}
              href: '/about#fact_check'
              'Learn more'
            ' about the service.'

        for claim in assessment.claims
          claim = fetch(claim.key)
          verdict = fetch(claim.verdict)

          [DIV style: {margin: '10px 0'}, 
            IMG 
              style: {position: 'absolute', width: 25, left: -40}, 
              src: verdict.icon
            'Claim: '
            SPAN style: {fontWeight: 600}, claim.claim_restatement
          DIV null, 
            SPAN null,
              'Rating: '
              SPAN style: {fontStyle: 'italic'}, verdict.name
              SPAN 
                style: 
                  marginLeft: 20
                  fontSize: 12
                  textDecoration: 'underline'
                  cursor: 'help'
                title: verdict.desc
                'help'
          DIV 
            style: {margin: '10px 0'}
            dangerouslySetInnerHTML:{__html: claim.result}]

styles += """
.magnifying_glass {
  position: absolute;
  width: 50px;
  height: 50px;
  font-size: 50px;
  margin-top: -2px;
  color: #5e6b9e; }
"""

EditComment = ReactiveComponent
  displayName: 'EditComment'

  render : -> 
    permitted = permit 'create comment', @proposal

    DIV className: 'comment_entry',

      # Comment author name
      DIV
        style:
          fontWeight: 'bold'
          color: '#666'
        (fetch('/current_user').name or 'You') + ':'

      # Icon
      Avatar
        style:
          position: 'absolute'
          width: 50
          height: 50
          backgroundColor: if permitted < 0 then 'transparent'
          border:          if permitted < 0 then '1px dashed grey'

        key: fetch('/current_user').user
        hide_tooltip: true

      if permitted == Permission.DISABLED
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Comments closed'

      else if permitted == Permission.INSUFFICIENT_PRIVILEGES
        SPAN 
          style: {position: 'absolute', margin: '14px 0 0 70px'}
          'Sorry, you do not have permission to comment'

      else if permitted < 0
        SPAN
          style:
            position: 'absolute'
            margin: '14px 0 0 70px'
            cursor: 'pointer'

          onClick: =>
            if permitted == Permission.NOT_LOGGED_IN
              @root.auth = {form: 'login', goal: 'Write a Comment'}
            else if permitted == Permission.UNVERIFIED_EMAIL
              @root.auth = {form: 'verify email', goal: 'Write a Comment'}
              current_user.trying_to = 'send_verification_token'
              save current_user

            save(@root)

          if permitted == Permission.NOT_LOGGED_IN
            DIV null,
              SPAN 
                style: { textDecoration: 'underline', color: focus_blue }
                'Log in to write a comment'
              if '*' not in @proposal.roles.commenter
                DIV style: {fontSize: 11},
                  'Only some email addresses are authorized to comment.'

          else if permitted == Permission.UNVERIFIED_EMAIL
            DIV null,
              SPAN
                style: { textDecoration: 'underline', color: focus_blue }
               'Verify your account'
              SPAN null, 'to write a comment'

      AutoGrowTextArea
        className: 'new_comment'
        placeholder: if permitted > 0 then 'Write a new comment' else ''
        disabled: permitted < 0
        onChange: (e) => @local.new_comment = e.target.value; save(@local)
        defaultValue: if @props.fresh then null else @data().body
        min_height: 60
        style:
          marginLeft: 60
          width: 390
          lineHeight: 1.4
          fontSize: 16
          border: if permitted < 0 then 'dashed 1px'

      if permitted > 0
        DIV style: {textAlign: 'right'},
          Button({style: {marginLeft: 314}}, 'Save comment', (e) =>
            e.stopPropagation()
            if @props.fresh
              comment =
                key: '/new/comment'
                body: @local.new_comment
                user: fetch('/current_user').user
                point: "/point/#{@props.point}"
            else
              comment = @data()
              comment.body = @local.new_comment
              comment.editing = false

            save(comment)
            $(@getDOMNode()).find('.new_comment').val(''))


Discussion = ReactiveComponent
  displayName: 'Discussion'

  render : -> 
    
    discussion_style =
      width: DECISION_BOARD_WIDTH
      border: "3px solid #{focus_blue}"
      position: 'absolute'
      zIndex: 100
      padding: '20px 40px'
      borderRadius: 16
      backgroundColor: 'white'

    bubble_mouth_style =
      position: 'absolute'
      top: 14
      width: 27
      height: 63

    # Reconfigure discussion board position
    side = if @props.is_pro then 'right' else 'left'
    if @props.in_wings
      discussion_style[side] = 215
      discussion_style['top'] = 44
    else
      discussion_style[side] = if @props.is_pro then -23 else -30
      discussion_style['marginTop'] = 13

    # Reconfigure bubble mouth position
    if @props.in_wings
      bubble_mouth_style.right = if @props.is_pro then -27       else undefined
      bubble_mouth_style.left  = if @props.is_pro then undefined else -27
    else
      trans_func = 'rotate(270deg)'
      if @props.is_pro
        trans_func += ' scaleY(-1)'

      _.extend bubble_mouth_style,
        left: if @props.is_pro then 335 else 100
        top: -45
        transform:            trans_func
        '-ms-transform':      trans_func
        '-moz-transform':     trans_func
        '-webkit-transform':  trans_func
        '-o-transform':       trans_func
      

    comments = @discussion.comments
    if @discussion.assessment
      comments = comments.slice()
      comments.push @discussion.assessment
      comments.sort (a,b) -> a.created_at < b.created_at

    DIV style: discussion_style, onClick: ((e) -> e.stopPropagation()),
      IMG
        src: "<%= asset_path 'bubblemouth-discussions.png' %>"
        className: if @props.is_pro then '' else 'flipped'
        style: bubble_mouth_style

      H1
        style:
          textAlign: 'left'
          fontSize: 38
          color: focus_blue
          marginLeft: 60
          marginBottom: 25
          marginTop: 24
          fontWeight: 600
        'Discuss this Point'
      
      SubmitFactCheck()

      DIV className: 'comments',
        for comment in comments
          if comment.key.match /(comment)/
            Comment key: comment.key
          else 
            FactCheck key: comment.key

      # Write a new comment
      EditComment fresh: true, point: arest.key_id(@props.key)

  # HACK! Insert a placeholder to add enough height to accommodate the 
  # overlaid point. And if it is a point on the decision board,
  # also add the space to the decision board (so that scrolling
  # to bottom of discussion can occur)
  componentDidUpdate : -> @fixBodyHeight()
  componentDidMount : -> @fixBodyHeight()
  componentWillUnmount : -> @clear_placeholder()
  clear_placeholder : -> 
    $body = $('.reasons_region')
    $body.find('.discussion_placeholder').remove()

  fixBodyHeight : -> 
    @clear_placeholder()

    $body = $('.reasons_region')
    height_of_discussion = $(@getDOMNode()).height()
    placeholder = "<div class='discussion_placeholder' style='height: " + \
                    height_of_discussion + "px'></div>"
    $body.append(placeholder)
    if $(@getDOMNode()).parents('.opinion_region').length > 0
      $('.decision_board_body').append placeholder

Button = (props, text, callback) ->
  style =
    backgroundColor: focus_blue
    borderRadius: 8
    color: 'white'
    padding: '3px 10px'
    display: 'inline-block'
    fontWeight: 600
    textAlign: 'center'
    cursor: 'pointer'
  props.style = _.extend(style, (props.style or {}))
  props.onClick = callback

  DIV props, text


SubmitFactCheck = ReactiveComponent
  displayName: 'SubmitFactCheck'

  # States
  # - Blank
  # - Clicked request
  # - Contains request from you already
  # - Contains a verdict

  render: ->
    return SPAN(null) if !@proposal.assessment_enabled

    logged_in = fetch('/current_user').logged_in

    request_a_fact_check = =>
      [
        DIV null,
          'You can'
        DIV
          style:
            fontSize: 22
            fontWeight: 600
            textDecoration: 'underline'
            color: '#474747'
            marginTop: -4
            marginBottom: -1
            cursor: 'pointer'
          onClick: (=>
            if @local.state == 'blank slate'
              @local.state = 'clicked'
            else if @local.state == 'clicked'
              @local.state = 'blank slate'
            save(@local))
          'Request a Fact Check'
        DIV null,
          'from The Seattle Public Library'
      ]

    a_librarian_will_respond = (width) =>
      DIV style: {maxWidth: width},
        'A '
        A
          style: {textDecoration: 'underline'}
          href: '/about/#fact_check'
          'librarian will respond'
        ' to your request within 48 hours'

    request_a_factcheck = =>
      if permit('request factcheck', @proposal) > 0
        [
          DIV style: {marginTop: 12},
            'What factual claim do you want researched?'
          AutoGrowTextArea
            className: 'new_request'
            style:
              width: 390
              height: 60
              lineHeight: 1.4
              fontSize: 16
            placeholder: (logged_in and 'Your research question') or ''
            disabled: not logged_in
            onChange: (e) =>
              @local.research_question = e.target.value
              save(@local)
          Button
            style: {float: 'right'}
            onClick => (e) =>
              e.stopPropagation()
              request =
                key: '/new/request'
                suggestion: @local.research_question
                point: "/point/#{arest.key_id(@discussion.key)}"
              save(request)
              $(@getDOMNode()).find('.new_request').val('')
            'submit'

          a_librarian_will_respond(255)
        ]
      else
        DIV
          onClick: =>
            @root.auth = {form: 'login', goal: 'Request a Fact Check'}
            save(@root)
          style:
            marginTop: 14
            textDecoration: 'underline'
            color: focus_blue
            cursor: 'pointer'
          'Log in to request a fact check'


    top_message_style = {maxWidth: 274, marginBottom: 10}
    request_in_progress = =>
      DIV null,
        DIV style: top_message_style,
          'You have requested a Fact Check from The Seattle Public Library'
        a_librarian_will_respond()
          
    request_completed = =>
      overall_verdict = fetch(@discussion.assessment.verdict)

      [
        DIV style: top_message_style,
          'This point has been Fact-Checked by The Seattle Public Library'
        DIV style: {marginBottom: 10},
          switch overall_verdict.id
            when 1
              "They found some claims inconsistent with reliable sources."
            when 2
              "They found some sources that agreed with claims and some that didn't."
            when 3
              "They found the claims to be consistent with reliable sources."
            when 4
              '''Unfortunately, the claims made are outside the research scope of 
              the fact-checking service.'''

        DIV style: {marginBottom: 10},
          A style: {textDecoration: 'underline'},
            ''
          "See the details"
          " of the librarians' research below."
      ]


    # Determine our current state
    @local.state = @local.state or 'blank slate'
    your_requests = (r for r in @discussion.requests or [] \
                     when r.user == fetch('/current_user').user)
    fact_check_completed = @discussion.claims?.length > 0
    if fact_check_completed
      @local.state = 'verdict'
    else if your_requests.length > 0
      @local.state = 'requested'


    show_request = @local.state != 'blank slate'
    
    request_style = if show_request then { marginBottom: 45, minHeight: 60 } else {}

    # Now let's draw
    DIV style: request_style,

      # Magnifying glass
      if show_request

        DIV className: 'magnifying_glass',
          I
            className: 'fa fa-search'

      # Text to the right
      DIV
        style:
          marginLeft: 60
        switch @local.state
          when 'blank slate'
            request_a_fact_check()
          when 'clicked'
            [request_a_fact_check()
            request_a_factcheck()]
          when 'requested'
            request_in_progress()
          when 'verdict'
            request_completed()

##
# EditPoint
# Form for editing or creating a point. Used by NewPoint component & when someone
# edits their point. 
EditPoint = ReactiveComponent
  displayName: 'EditPoint'

  render : ->
    @local = @data @local_key,
      sign_name : if @props.fresh then true else !@data().hide_name
      add_details : false

    textarea_style = 
      width: '100%'
      minHeight: 100
      overflow: 'hidden'
      fontSize: 14

    DIV
      className: 'edit_point'
      style: 
        margin: '0 18px'
        position: 'relative'
        fontSize: 14

      INPUT 
        id:'is_pro'
        name: 'is_pro'
        type: 'hidden'
        value: "#{@props.valence == 'pros'}"
      LABEL 
        htmlFor:'nutshell'
        'Your point'
      CharacterCountTextInput 
        id:'nutshell'
        maxLength:140
        name:'nutshell'
        pattern:'^.{3,}'
        placeholder:'Make this summary succinct.'
        required:'required'
        defaultValue: if @props.fresh then null else @data().nutshell
        style: textarea_style

      
      DIV null,
        A 
          className: 'add_details'
          onClick: =>
            @local.add_details = !@local.add_details
            save(@local)            
          title: 'Provide background and/or back your point up with evidence.'
          style: { fontSize: 14 }

          I className: if @local.add_details 
                         'fa-caret-down fa' 
                       else 
                         'fa-caret-right fa'
          SPAN
            style: {paddingLeft: 6}
            'Expand on your point'

        if @local.add_details
          DIV null, 
            AutoGrowTextArea 
              id:'text'
              name:'text'
              placeholder:'Provide background and/or back your point up with evidence.'
              required:'required'
              min_height: 170
              defaultValue: if @props.fresh then null else @data().text
              style: textarea_style


      if @proposal.active
        DIV 
          style: 
            position: 'absolute'
            bottom: 0
            fontSize: 13
          INPUT
            className: 'newpoint-anonymous'
            type:      'checkbox'
            id:        "sign_name-#{@props.valence}"
            name:      "sign_name-#{@props.valence}"
            checked:   @local.sign_name
            onChange: =>
              @local.sign_name = !@local.sign_name
              save(@local)
          LABEL 
            htmlFor: "sign_name-#{@props.valence}"
            title:'Signing your name lends your point more weight with other participants.'
            'Sign your name'

      if @local.errors?.length > 0
        
        DIV
          style:
            fontSize: 18
            color: 'darkred'
            backgroundColor: '#ffD8D8'
            padding: 10
            marginTop: 10
          for error in @local.errors
            DIV null, 
              I
                className: 'fa fa-exclamation-circle'
                style: {paddingRight: 9}

              SPAN null, error

      DIV 
        style: 
          textAlign: 'right'
          marginTop: 3
          marginBottom: '.5em'

        if !@proposal.active
          DIV 
            style: {color: '#777', fontSize: 12}
            'New points disabled for this proposal'
        else
          INPUT 
            className:'button primary_button'
            action:'submit-point',
            type:'submit', 
            onClick: @savePoint
            value:'Done'
            style: 
              marginTop: '.5em'
              width: '100%'
              fontSize: 18

        A 
          className:'newpoint-cancel primary_cancel_button'
          onClick: @done
          'cancel'  

  componentDidMount : ->
    $el = $(@getDOMNode())
    $el.find('#nutshell').focus()
    $el.find('.newpoint-cancel').ensureInView {scroll: false, position: 'bottom'}

  done : ->

    your_points = fetch @props.your_points_key

    if @props.fresh
      your_points.adding_new_point = false
    else
      your_points.editing_points = _.without your_points.editing_points, @props.key

    save your_points

  savePoint : (ev) ->
    $form = $(@getDOMNode())
    root = fetch('root')

    nutshell = $form.find('#nutshell').val()
    text = $form.find('#text').val()
    hide_name = !$form.find("#sign_name-#{@props.valence}").is(':checked')

    if !@props.fresh
      # If we're updating an existing point, we just have to update
      # some of the fields from the form
      point = @data()
      point.nutshell = nutshell
      point.text = text
      point.hide_name = hide_name
    else
      current_user = fetch('/current_user').user
      point =
        key : '/new/point'
        is_pro : @props.valence == 'pros'
        user : current_user
        comment_count : 0
        includers : [current_user]
        proposal : @proposal.key
        nutshell : nutshell
        text : text
        hide_name : hide_name

    point.errors = []
    save point, => 
      if point.errors?.length == 0
        @done()
      else
        @local.errors = point.errors
        save @local

    # # This is a kludge cause activerest sucks for pre-rendering
    # # changes before the server returns them
    # fetch(@proposal.your_opinion).point_inclusions.push(point.key)
    # re_render([@proposal.your_opinion])

styles += """
.edit_point .count{
  position: absolute;
  right: 20px;
  top: -19px;
}
"""

####
# GroupSelectionRegion
#
# Draws a border around the selected opinion(s)
# Shows a bubble mouth for selected opinions or 
# a user name + avatar display if we've selected
# an individual opinion.
GroupSelectionRegion = ReactiveComponent
  displayName: 'GroupSelectionRegion'

  render : -> 
    hist = fetch 'histogram'

    has_histogram_focus = hist.selected_opinions || hist.selected_opinion
    if has_histogram_focus
      DIV 
        style: 
          width: BODY_WIDTH + 80
          border: "3px solid #{if @root.selected_point then '#ccc' else focus_blue }"
          height: '100%'
          position: 'absolute'
          borderRadius: 16
          marginLeft: if lefty then 200 else -BODY_WIDTH/2 - 40
          left: if lefty then 0 else '50%'
          top: 18

        # draw a bubble mouth
        if hist.selected_opinions
          w = 40; h = 30
          left = translateStanceToPixelX(hist.selected_opinion_value, BODY_WIDTH) + 10

          DIV 
            style: cssTriangle 'top', \
                               (if @root.selected_point then '#ccc' else focus_blue), \
                               w, h,               
                                  position: 'relative'
                                  top: -32
                                  left: left

            DIV
              style: cssTriangle 'top', 'white', w - 1, h - 1,
                position: 'relative'
                left: -(w - 2)/2
                top: 6

        # draw a name + avatar display for the selected opinion
        else 
          place_avatar_opinion_value = \
               if hist.selected_opinion_value > 0 then .8 else -.8
          left = translateStanceToPixelX(place_avatar_opinion_value, BODY_WIDTH) + 20

          avatar_size = 80
          user = fetch(fetch(hist.selected_opinion).user)
          name = user.name or 'Anonymous'
          title = "#{name}'#{if name[name.length - 1] != 's' then 's' else ''} Opinion"

          name_width = widthWhenRendered(title, {fontSize: '30px', fontWeight: '600'})

          if hist.selected_opinion_value > 0
            name_style = 
              left: -28 - avatar_size * .5 - name_width 
              borderTopLeftRadius: 16
              paddingRight: avatar_size * .75
              paddingLeft: 18

          else
            name_style = 
              left: avatar_size/4
              borderTopRightRadius: 16
              paddingLeft: avatar_size * .75
              paddingRight: 18
                
          DIV style: {left: left, position: 'absolute'},

            DIV null,
              Avatar 
                key: user
                user: user
                hide_tooltip: true
                style: 
                  position: 'absolute'
                  width: avatar_size
                  height: avatar_size
                  top: -avatar_size * .75
                  left: -avatar_size/4
                  zIndex: 99 
                  border: "3px solid #{focus_blue}"

              DIV 
                style: _.extend name_style,
                  position: 'absolute'
                  backgroundColor: focus_blue
                  paddingTop: 8
                  paddingBottom: 8
                  color: 'white'
                  top: -58
                  width: name_width + 10 + 18 + avatar_size * .75 + 10


                SPAN 
                  style: 
                    fontSize: 30
                  title

    else 
      SPAN null

##
# Avatar
# Displays a user's avatar
#
# We primarily download all avatar images as part of a CSS file specifying a 
# b64 encoded background-image small 50x50 thumbnails for each user 
# (under #avatar-{id}). 
#
# Higher resolution images are available ('large' and 'original'). These can 
# be specified by setting the img_size property of Avatar.
#
# Additionally, Avatar will automatically upgrade the image resolution if 
# the style specifies a width greater than the size of the thumbnails. 
#
# Avatar will output either a SPAN or IMG. The choice of which tag is used 
# is fraught based upon the browser and how React replaces elements. In the 
# future we can refactor this for a cleaner implementation.
#
# Properties set on Avatar will be transferred to the outputted SPAN or IMG.
#
# Props
#   img_size (default = 'thumb')
#      The size of the embedded image. 'thumb' or 'large' or 'original'
#   hide_tooltip (default = false)
#      Suppress the tooltip on hover. 
#   anonymous (default = false)
#      Don't show a real picture and show "anonymous" in the tooltip. 

Avatar = ReactiveComponent
  displayName: 'Avatar'
  
  render : ->
    user = @data()

    id = if @props.anonymous 
           "avatar-hidden" 
         else 
           "avatar-#{user.key.split('/')[2]}"

    style = _.extend {}, @props.style
    img_size = img_size or 'thumb'

    show_avatar = !@props.anonymous && user.avatar_file_name
    # Automatically upgrade the avatar size to 'large' if the width of the image is 
    # greater than the size of the b64 encoded image
    img_size = 'large' if img_size == 'thumb' && style?.width > 50 && !browser.is_ie9
    # ...but we only use a larger image if this user actually has one and isn't anonymous
    use_large_image = img_size != 'thumb' && show_avatar

    if use_large_image
      @props.src = fetch('/subdomain').asset_host + \
                   "/system/avatars/" + \
                   "#{user.key.split('/')[2]}/#{img_size}/#{user.avatar_file_name}"  
    else
      # prevents a weird webkit outlining issue
      # http://stackoverflow.com/questions/4743127
      style.content = "''" 

    # Override the gray default avatar color if we're showing an image. 
    # In most cases the white will allow for a transparent look. It 
    # isn't set to transparent because a transparent icon in many cases
    # will reveal content behind it that is undesirable to show.  
    style.backgroundColor = 'white' if show_avatar
      
    attrs =
      className: "avatar #{@props.className or ''}"
      id: id
      style: style
      onMouseEnter: => 
        if !@props.hide_tooltip
          name = if @props.anonymous || user.name?.length == 0 
                   'Anonymous' 
                 else 
                   user.name
          tooltip = fetch 'tooltip'
          tooltip.coords = $(@getDOMNode()).offset()
          tooltip.tip = name
          save tooltip
      onMouseLeave: => 
        if !@props.hide_tooltip      
          tooltip = fetch 'tooltip'
          tooltip.coords = null
          save tooltip

    # IE9 gets confused if there is an image without a src
    tag = if browser.is_ie9 && img_size == 'thumb' then SPAN else IMG

    @transferPropsTo tag attrs

Tooltip = ReactiveComponent
  displayName: 'Tooltip'

  render : -> 
    tooltip = fetch('tooltip')
    return SPAN(null) if !tooltip.coords

    coords = tooltip.coords
    tip = tooltip.tip

    # place the tooltip above the element
    DIV
      style: 
        position: 'absolute'
        top: coords.top - 20
        left: coords.left
        fontSize: 14
        color: 'black'
        backgroundColor: 'white'
        padding: '0 4px'
        borderRadius: 8
        zIndex: 9999
        whiteSpace: 'nowrap'
        pointerEvents: 'none'
      tip



styles += """
.avatar {
  vertical-align: top;
  background-color: transparent;
  border: none;
  display: inline-block;
  margin: 0;
  padding: 0;
  border-radius: 50%;
  background-size: cover;
  background-color: #{default_avatar_in_histogram_color}; 
  user-select: none; 
  -moz-user-select: none; 
  -webkit-user-select: none;
  -ms-user-select: none;}
  .avatar.avatar_anonymous {
    cursor: default; 
}


"""


Homepage = ReactiveComponent
  displayName: 'Homepage'
  render: ->
    customization('Homepage')()


window.proposal_editor = (proposal) ->
  editor = proposal.roles.editor.length > 0 and proposal.roles.editor[0]
  return editor != '-' and editor


ProfileMenu = ReactiveComponent
  displayName: 'ProfileMenu'

  componentDidMount : -> @setBgColor()
  componentDidUpdate : -> @setBgColor()
  setBgColor : -> 
    cb = (is_light) => 
      if @local.light_background != is_light
        @local.light_background = is_light
        save @local

    is_light = isLightBackground @getDOMNode(), cb

    cb is_light

  render : -> 
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')
    loc = fetch('location') # should rerender on a location change because background
                            # color might change

    is_evaluator = subdomain.assessment_enabled && current_user.is_evaluator
    is_admin = current_user.is_admin
    is_moderator = current_user.is_moderator
    menu_options = [
      {href: '/edit_profile', label: 'Edit Profile'},
      {href: '/dashboard/email_notifications', label: 'Notifications'},
      if is_admin then {href: '/dashboard/import_data', label: 'Import Data'} else null,
      if is_admin then {href: '/dashboard/application', label: 'App Settings'} else null,
      if is_admin then {href: '/dashboard/roles', label: 'User Roles'} else null,
      if is_moderator then {href: '/dashboard/moderate', label: 'Moderate'} else null,
      if is_evaluator then {href: '/dashboard/assessment', label: 'Fact-check'} else null 
    ]

    menu_options = _.compact menu_options

    DIV
      style:
        _.extend(
          position: 'absolute'
          right: 50
          top: 17,
          _.clone(@props.style))

      if current_user.logged_in
        SPAN
          className: 'profile_menu_wrap'
          style:
            position: 'relative'
          onMouseEnter: => @local.menu = true; save(@local)
          onMouseLeave: => @local.menu = false; save(@local)
          DIV 
            style: 
              display: if not @local.menu then 'none'
              position: 'absolute'
              marginTop: -8
              marginLeft: -8
              padding: 8
              paddingTop: 50
              paddingRight: 14
              backgroundColor: '#eee'
              left: -82
              textAlign: 'left'
              zIndex: 999999

            for option in menu_options
              A
                className: 'menu_link'
                href: option.href
                key: option.href
                option.label

            A 
              className: 'menu_link'
              onClick: @logout
              'Log out'

          SPAN 
            style: 
              color: if !@local.light_background then 'white'
              position: 'relative'
              zIndex: 9999999999
              backgroundColor: if !@local.menu then 'rgba(255,255,255, .1)'
              boxShadow: if !@local.menu then '0px 1px 1px rgba(0,0,0,.1)'
              borderRadius: 8
              padding: '3px 4px'

            Avatar 
              key: current_user.user
              hide_tooltip: true
              className: 'userbar_avatar'
              style: {height: 20, width: 20, marginRight: 7, marginTop: 1}
            I 
              className: 'fa fa-caret-down'
              style: 
                visibility: if @local.menu then 'hidden'
      else
        A
          'className': 'profile_anchor login'
          'data-action': 'login'
          onClick: (e) =>
            @root.auth = {form: 'login', goal: null}
            save @root
          style: 
            color: if !@local.light_background then 'white'
          'Log in'


  logout : -> 
    current_user = fetch('/current_user')
    current_user.logged_in = false
    current_user.trying_to = 'logout'

    if @root.auth && @root.auth.form == 'edit profile'
      @root.page_name = 'homepage'

    @root.auth = null

    save current_user, =>
      # We need to get a fresh your_opinion object
      # after logging out. 

      # TODO: the server should dirty keys on the client when the
      # current_user logs out
      arest.clear_matching_objects((key) -> key.match( /\/page\// ))

    save @root

styles += """
.profile_navigation {
  text-align: right;
  width: 100%;
  padding: 20px 120px 0 0;
  font-size: 21px; }

.menu_link {
  position: relative;
  bottom: 8px;
  padding-left: 27px;
  display: block;
  color: #{focus_blue};
  white-space: nowrap; }

.menu_link:hover{ color: black; }

.profile_menu_wrap:hover .profile_anchor{ color: inherit; }
"""

Header = ReactiveComponent
  displayName: 'Header'

  render : ->
    current_user = fetch('/current_user')
    subdomain = fetch('/subdomain')

    DIV 
      style: 
        position: 'relative'
        margin: '0 auto'
        backgroundColor: 'white'
        minWidth: PAGE_WIDTH

      if @root.page_name == 'homepage'
        customization('HomepageHeader')()
      else 
        customization('NonHomepageHeader')()

      DIV null, 
        if @root.page_name == 'about'
          A 
            href: '/'
            style: 
              position: 'absolute'
              display: 'inline-block'
              zIndex: 999
              marginTop: 8
              marginLeft: 16
              fontWeight: 600
            I className: 'fa fa-home', style: {fontSize: 28, color: '#bbb'}
            SPAN 
              style: 
                fontSize: 15
                paddingLeft: 6
                color: '#777'
                verticalAlign: 'text-bottom'
              'Home'

      DIV 
        style: 
          backgroundColor: '#eee'
          color: '#f00'
          padding: '5px 20px'
          display: if @root.server_error then 'block' else 'none'
        'Warning: there was a server error!'

    


EditProposal = ReactiveComponent
  displayName: 'EditProposal'

  render : ->
    user = fetch('/current_user')
    proposal = @data()
    subdomain = fetch '/subdomain'

    # defaultValue for React forms conflicts with statebus's method of 
    # just rerunning until things work. Namely, the default value
    # that is set before the proposal is loaded entirely sticks
    # even after the proposal is fully loaded from the server.
    # This code works around that problem by simply exiting the 
    # render if the proposal isn't loaded already. 
    if !@props.fresh && !proposal.id
      return SPAN null

    default_group = if subdomain.name == 'bitcoin'
                      'Proposals'
                    else
                      null
    
    # check permissions
    permitted = if @props.fresh  
                  permit('create proposal')
                else
                  permit('update proposal', proposal)

    if permitted < 0
      recourse permitted, 'create a proposal'
      return DIV null

    block_style = 
      width: CONTENT_WIDTH
      padding: '2px 0px'
      marginBottom: 12
      position: 'relative'

    description_field_style =
      fontSize: 18
      width: CONTENT_WIDTH - 200
      padding: 12
      marginBottom: 8
      border: '1px solid #ccc'

    input_style = _.extend {}, description_field_style, 
      display: 'block'

    label_style =
      fontSize: 24
      fontWeight: 600
      width: 240
      display: 'inline-block'
      color: focus_blue
      marginBottom: 3

    operation_style = 
      color: '#aaa'
      textDecoration: 'underline'
      fontSize: 14
      cursor: 'pointer'
      display: 'block'      


    if !@local.description_fields
      @local.description_fields = if @data().description_fields 
                                    $.parseJSON(@data().description_fields) || [] 
                                  else 
                                    []
      @local.open_fields = []

      if @local.description_fields.length > 0
        if @local.description_fields[0].group
          # Right now, we just downgrade group syntax to flat description list syntax
          # TODO: when editing a proposal, support the proposal description groups 
          # syntax (or get rid of it)
          @local.description_fields = _.flatten \
                                         @local.description_fields.map \
                                            (group) -> group.items

        # Add unique identifiers to each field so we can hide/edit them
        for field,idx in @local.description_fields
          field.id = idx

      save @local

    toggleDescriptionFieldOpen = (field, field_open) =>
      if field_open
        @local.open_fields = _.without @local.open_fields, field.id
      else
        @local.open_fields.push field.id
      save @local

    DIV null, 
      DashHeader 
        name: if @props.fresh then "New Proposal" else "Edit #{proposal.name}"
      DIV 
        style: 
          width: CONTENT_WIDTH
          margin: 'auto'
          padding: '3em 0'
          position: 'relative'


        if proposal.slug
          A 
            style: 
              color: '#777'
              position: 'absolute'
              left: -100
              top: 54
            href: "/#{proposal.slug}"

            I
              className: 'fa fa-arrow-left'
              style: 
                paddingRight: 10
            'back'

        DIV 
          style: 
            marginBottom: 20

          DIV 
            style: 
              fontSize: 28

            "A proposal must be "
            SPAN
              style: 
                color: focus_blue
                fontWeight: 600
              "Actionable"
            ", " 
            SPAN
              style: 
                color: focus_blue     
                fontWeight: 600         
              "Clear"
            ", "
            "and "
            SPAN
              style: 
                color: focus_blue
                fontWeight: 600

              "Unique"
            '. '

          DIV null
            A 
              style: 
                textDecoration: 'underline'
              onClick: => @local.show_criteria = !@local.show_criteria; save(@local)
              if @local.show_criteria
                "Hide"
              else
                "Read more"

          DIV 
            style: 
              fontSize: 22
            if @local.show_criteria

              UL 
                style: 
                  marginLeft: 40

                LI 
                  style:
                    listStyle: 'none'
                  'Actionable'
                  UL 
                    style: 
                      marginLeft: 40

                    LI null,
                      'your proposal should have concrete actions'
                    LI null,
                      'the proposed actions should be realistic and on-topic'

                LI
                  style: 
                    listStyle: 'none'
                  'Clear'
                  UL 
                    style: 
                      marginLeft: 40
                    LI null,
                      'format your proposal to maximize readability'
                    LI null,
                      'eliminate possibilities for misunderstanding'
                    LI null,
                      'state your assumptions'
                    LI null,                  
                      'describe the situation your proposal addresses'
                    LI null,                  
                      'motivate each proposed action'

                LI
                  style: 
                    listStyle: 'none'

                  'Unique'
                  UL 
                    style: 
                      marginLeft: 40
                    LI null,
                      'browse the site for similar proposals'
                    LI null,                  
                      'if you want to improve upon an existing proposal, '
                      A 
                        style:
                          'textDecoration': 'underline'
                        href: 'mailto:admin@consider.it'
                        'email us'
                      '.'



        DIV style: block_style,
          LABEL htmlFor:'slug', style: label_style, 'URL:'

          BR null
          SPAN
            style: 
              fontSize: 20
              color: '#aaa'
            "#{location.origin}/"
          INPUT 
            id:'slug'
            name:'slug'
            pattern:'^.{3,}'
            placeholder: "Just letters, numbers, underscores, dashes."
            required:'required'
            defaultValue: if @props.fresh then null else proposal.slug
            style: _.extend {}, input_style,
              width: 400
              display: 'inline-block'

        DIV style: block_style,
          LABEL htmlFor:'name', style: label_style, 'Summary:'
          INPUT 
            id:'name'
            name:'name'
            pattern:'^.{3,}'
            placeholder:'Aim for 3-8 words with a verb and noun.'
            required:'required'
            defaultValue: if @props.fresh then null else proposal.name
            style: input_style

        DIV style: block_style,
          LABEL htmlFor:'description', style: label_style, 'Description:'
          
          WysiwygEditor
            key:"description-#{proposal.key}"
            placeholder:'Clearly describe the details.'
            style: input_style
            html: if @props.fresh then null else proposal.description

          # Expandable description fields

          DIV 
            style: 
              marginBottom: 20
              marginLeft: 45
              display: if not fetch('/current_user').is_super_admin then 'none'

            for field in @local.description_fields
              field_open = field.id in @local.open_fields
              DIV 
                key: "field-#{field.id}"
                style: _.extend({}, block_style, {width: ''}),

                I 
                  className: "fa fa-#{if field_open then 'minus' else 'plus'}-circle"
                  style: 
                    position: 'absolute'
                    left: -20
                    top: 18
                    color: '#414141'
                    cursor: 'pointer'
                  onClick: do (field, field_open) => => 
                    toggleDescriptionFieldOpen(field, field_open)

                if field_open
                  [INPUT
                    style: _.extend {}, description_field_style, \
                                    {width: description_field_style.width - 45}
                    type: 'text'
                    id:"field-#{field.id}-label"
                    name:"field-#{field.id}-label"
                    pattern:'^.{3,}'
                    placeholder:'Label'
                    required:'required'
                    onChange: do(field) => (e) => 
                      field.label = e.target.value; save(@local)
                    value: field.label

                  WysiwygEditor
                    key:"field-#{field.id}-html-#{proposal.key}"
                    name:"field-#{field.id}-html"
                    placeholder:'Text that is shown when expanded'
                    style: _.extend {}, description_field_style, \
                                    {width: description_field_style.width - 45}
                    html: field.html]

                else
                  DIV 
                    style: 
                      fontSize: 18
                      fontWeight: 600
                      cursor: 'pointer'
                      marginTop: 12
                      marginLeft: 5
                      width: description_field_style.width - 45
                    onClick: do (field, field_open) => => 
                      toggleDescriptionFieldOpen(field, field_open)
                    field.label

                DIV 
                  style: 
                    position: 'absolute'
                    right: 150
                    top: 12

                  A
                    style: operation_style
                    onClick: do (field, field_open) => => 
                      toggleDescriptionFieldOpen(field, field_open)
                    if field_open then 'close' else 'edit'

                  A
                    style: operation_style
                    onClick: do (field) => =>
                      @local.description_fields = \
                        _.filter @local.description_fields, \
                                 (fld) -> fld.id != field.id
                      save @local
                    'delete'

            SPAN
              style: 
                color: '#aaa'
                cursor: 'pointer'
                fontSize: 18
                marginLeft: -18

              onClick: => 
                new_id = 0
                for field in @local.description_fields
                  new_id += field.id  
                new_id += 1
                @local.description_fields.push {label: null, html: null, id: new_id}
                @local.open_fields.push new_id
                save @local

              "+ "
              SPAN 
                style: 
                  textDecoration: 'underline'
                  marginLeft: 7
                "Add expandable description section"


        DIV
          style: _.extend {}, block_style,
            display: if !user.is_admin then 'none'

          LABEL htmlFor:'cluster', style: label_style, 'Group (optional):'
          INPUT 
            id:'cluster'
            name:'cluster'
            pattern:'^.{3,}'
            placeholder:'The group to which this proposal belongs, if any.'
            defaultValue: if @props.fresh then default_group else proposal.cluster
            style: input_style

        DIV 
          style: _.extend {}, block_style,
            display: if !user.is_admin then 'none'

          LABEL htmlFor: 'listed_on_homepage', style: label_style, 'List on homepage?'

          INPUT 
            id: 'listed_on_homepage'
            name: 'listed_on_homepage'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else !proposal.hide_on_homepage
            style: 
              fontSize: 24

        DIV
          style: _.extend {}, block_style,
            display: if !user.is_admin then 'none'

          LABEL 
            htmlFor: 'open_for_discussion'
            style: label_style
            'Open for discussion?'

          INPUT 
            id: 'open_for_discussion'
            name: 'open_for_discussion'
            type: 'checkbox'
            defaultChecked: if @props.fresh then true else proposal.active
            style: {fontSize: 24}
          

        DIV 
          style: 
            display: if !user.is_admin then 'none'

          SPAN 
            style: _.extend {}, label_style,
              textDecoration: 'underline'
              cursor: 'pointer'
              width: 400
              position: 'relative'
            onClick: => 
              @local.edit_roles = !@local.edit_roles
              save @local
            I 
              className: 'fa-child fa'
              style: 
                position: 'absolute'
                left: -25
                top: 5


            'Permissions and invitations'

          DIV 
            style: 
              width: CONTENT_WIDTH
              backgroundColor: '#fafafa'
              padding: '10px 60px'
              display: if @local.edit_roles then 'block' else 'none' 
                  # roles has to be rendered so that default roles 
                  # are set on the proposal

            ProposalRoles 
              key: if @props.fresh then @local else proposal


        if @local.errors?.length > 0
          
          DIV
            style:
              fontSize: 18
              color: 'darkred'
              backgroundColor: '#ffD8D8'
              padding: 10
              marginTop: 10
            for error in @local.errors
              DIV null, 
                I
                  className: 'fa fa-exclamation-circle'
                  style: {paddingRight: 9}

                SPAN null, error


        DIV null,
          INPUT 
            className:'button primary_button'
            type:'submit'
            style: 
              width: 400
              marginTop: 35
            value:"#{if @props.fresh then 'Publish' else 'Update'}"
            onClick: @saveProposal

        DIV 
          style: 
            fontSize: 18
            width: 400
            marginTop: 5

          "You are accepting responsibility for improving your proposal given input from others." 

  saveProposal : -> 
    $el = $(@getDOMNode())

    name = $el.find('#name').val()
    description = fetch("description-#{@data().key}").html
    slug = $el.find('#slug').val()
    cluster = $el.find('#cluster').val()
    cluster = null if cluster == ""
    active = $el.find('#open_for_discussion:checked').length > 0
    hide_on_homepage = $el.find('#listed_on_homepage:checked').length == 0

    if @props.fresh
      proposal =
        key : '/new/proposal'
        name : name
        description : description
        cluster : cluster
        slug : slug
        active: active
        hide_on_homepage: hide_on_homepage

    else 
      proposal = @data()
      _.extend proposal, 
        cluster: cluster
        name: name
        slug: slug
        description: description
        active: active
        hide_on_homepage: hide_on_homepage

    if @local.roles
      proposal.roles = @local.roles
      proposal.invitations = @local.invitations

    if @local.description_fields
      for field in @local.description_fields
        edited_html = fetch("field-#{field.id}-html-#{proposal.key}")
        field.html = edited_html.html if edited_html.html
      proposal.description_fields = JSON.stringify(@local.description_fields)

    proposal.errors = []
    @local.errors = []
    save @local

    save proposal, => 
      if proposal.errors?.length == 0
        window.scrollTo(0,0)
        window.app_router.navigate "/#{slug}", {trigger : true}
      else
        @local.errors = proposal.errors
        save @local


About = ReactiveComponent
  displayName: 'About'

  componentWillMount : ->
    @local.embed_html_directly = true
    @local.html = null
    @local.save

  componentDidMount : -> @handleContent()
  componentDidUpdate : -> @handleContent()

  handleContent : -> 
    $el = $(@getDOMNode())

    if @local.embed_html_directly
      # have to use appendChild rather than dangerouslysetinnerhtml
      # because scripts in the about page html won't get executed
      # when using dangerouslysetinnerhtml
      if @local.html
        $el.find('.embedded_about_html').append @local.html

    else
      # REACT iframes don't support onLoad, so we need to figure out when 
      #               to check the height of the loaded content ourselves      
      $el.prop('tagName').toLowerCase() == 'iframe'
      iframe = $el[0]
      _.delay ->
        try 
          iframe.height = iframe.contentWindow.document.body.scrollHeight + "px"
        catch e
          iframe.height = "2000px"
          console.error 'http/https mismatch for about page. Should work in production.'
          console.error e
      , 1000


  render : -> 
    subdomain = fetch('/subdomain') 

    if @local.embed_html_directly && !@local.html && subdomain.about_page_url
      # fetch the about page HTML directly
      $.get subdomain.about_page_url, \
            (response) => @local.html = response; save @local

    DIV style: {marginTop: 20},
      if !subdomain.about_page_url
        DIV null, 'No about page defined'
      else if !@local.embed_html_directly
        IFRAME 
          src: subdomain.about_page_url
          width: PAGE_WIDTH
          style: {display: 'block', margin: 'auto'}
      else
        DIV className: 'embedded_about_html'


EmailNotificationSettings = ReactiveComponent
  displayName: 'EmailNotificationSettings'

  render : -> 
    data = @data()
    current_user = fetch('/current_user')

    DIV null,
      DashHeader name: 'Email Notification Settings'
      DIV style: {width: CONTENT_WIDTH, margin: '15px auto'}, 
        DIV style: {position: 'relative'},
          INPUT 
            id: 'no_email_notifications'
            name: 'no_email_notifications'
            type: 'checkbox'
            defaultChecked: !current_user.no_email_notifications
            style: css.crossbrowserify
              transform: "scale(1.5)"
              fontSize: 30
              position: 'absolute'
              left: -32
              top: 11
            onChange: (e) => 
              current_user.no_email_notifications = \
                !$('#no_email_notifications').is(':checked')
              save current_user

          LABEL 
            htmlFor: 'no_email_notifications'
            style: 
              fontSize: 30
 
            'Enable email notifications'

        if !current_user.no_email_notifications
          if _.flatten(_.values(data.follows)).length == 0
            DIV null, 'You\'re not currently receiving any email notifications'
          else
            DIV null,
              HR null
              for followable_type in ['Point', 'Proposal']
                if data.follows[followable_type].length > 0
                  DIV null,
                    H1 
                      style: 
                        fontSize: 18
                        marginTop: '18px'

                      if followable_type == 'Point'
                        "Pro/con points to which you are subscribed"
                      else
                        "#{followable_type}s to which you have subscribed"
                    for follow in data.follows[followable_type]
                      followable = fetch(follow)
                      DIV style: {margin: '20px 0'}, 
                        if followable_type == 'Point'
                          Point key: followable, rendered_as: 'under_review'
                        else 
                          BLOCKQUOTE null,
                            followable.name
                        BUTTON 
                          style: {fontSize: 18}
                          onClick: do(followable) => => 
                            followable.is_following = false
                            save followable
                            arest.serverFetch '/dashboard/email_notifications' 
                               # don't want to have to dirty this key whenever 
                               # a point or proposal is updated
                          'unsubscribe'


Computer = ReactiveComponent
  # This doesn't actually render anything.  It just processes state
  # changes to current_user for CSRF and logging in and out.
  displayName: 'Computer'
  render : ->
    current_user = fetch('/current_user')
    if current_user.csrf
      arest.csrf(current_user.csrf)

    # Publish pending opinions if we can
    if @root.opinions_to_publish.length > 0

      remaining_opinions = []

      for opinion_key in @root.opinions_to_publish
        opinion = fetch(opinion_key)
        can_opine = permit('publish opinion', opinion.proposal)

        if can_opine > 0 && !opinion.published
          opinion.published = true
          save opinion
        else 
          remaining_opinions.push opinion_key

          # TODO: show some kind of prompt to user indicating that despite 
          #       creating an account, they still aren't permitted to publish 
          #       their opinion.
          # if can_opine == Permission.INSUFFICIENT_PRIVILEGES
          #   ...

      if remaining_opinions.length != @root.opinions_to_publish.length
        @root.opinions_to_publish = remaining_opinions
        save @root

    # users following an email invitation need to complete 
    # registration (name + password)
    if current_user.needs_to_set_password
      @root.auth = 
        form: 'create account via invitation'
        goal: 'complete registration'
      save @root

    SPAN null


Page = ReactiveComponent
  displayName: 'Page'
  mixins: [AccessControlled]

  render: ->

    avatars = fetch('/avatars')
    subdomain = fetch('/subdomain')

    if @root.auth && @root.auth.form != 'edit profile'
      return Auth()

    if subdomain.name == 'homepage' && @root.page_name == 'homepage'
      SPAN null, ''
    else if !subdomain.name
      L
    else
      DIV 
        style:
          minWidth: PAGE_WIDTH
          backgroundColor: 'white'
          overflowX: 'hidden'
        if avatars.avatars
          STYLE 
            type: 'text/css'
            id: 'b64-avatars'
            dangerouslySetInnerHTML: {__html: avatars.avatars}
        
        BrowserHacks()
        Header()
        DIV 
          style: 
            minWidth: PAGE_WIDTH
            minHeight: 200
            zIndex: 2
            margin: 'auto'
            marginLeft: if lefty then 0

          if @root.page_name == 'edit_profile'
            Auth()

          else

            if !@accessGranted()
              SPAN null 
            else if @root.page_name.match(/(.+)\/edit/)
              EditProposal 
                key: "/#{@root.page_name.match(/(.+)\/edit/)[1]}"
                fresh: false
            else
              switch @root.page_name
                when 'homepage'
                  Homepage key: @page.key
                when 'about'
                  About()
                when 'proposal/new'
                  EditProposal key: "new_proposal", fresh: true              
                when 'dashboard/email_notifications'
                  EmailNotificationSettings 
                    key: '/page/dashboard/email_notifications'
                when 'dashboard/assessment'
                  FactcheckDash key: "/page/dashboard/assessment"
                when 'dashboard/create_subdomain'
                  CreateSubdomain key: "/page/dashboard/create_subdomain"
                when 'dashboard/import_data'
                  ImportDataDash key: "/page/dashboard/import_data"
                when 'dashboard/moderate'
                  ModerationDash key: "/page/dashboard/moderate"
                when 'dashboard/application'
                  AppSettingsDash key: "/page/dashboard/application"
                when 'dashboard/roles'
                  SubdomainRoles key: "/page/dashboard/roles"
                else
                  Proposal key: @page.proposal.key

        customization('Footer')()

Root = ReactiveComponent
  displayName: 'Root'
  resetSelection: (e) ->

    if !@root.auth
      hist = fetch 'histogram'

      if @root.selected_point
        window.writeToLog
          what: 'deselected a point'
          details:
            point: @root.selected_point

        @root.selected_point = null
        save @root

      else if hist.selected_opinions || hist.selected_opinion
        if hist.dragging
          hist.dragging = false
        else
          hist.selected_opinion = null
          hist.selected_opinions = null
          hist.selected_opinion_value = null
        save hist

    if @root.show_wyswyg_toolbar
      @root.show_wyswyg_toolbar = false
      save @root



  render : -> 
    root = @data()

    ######
    # Handle application routing, derived from client state.
    query_parameters = Backbone.history.getQueryParameters()
    query_parameters = {}

    if @root.proposal_mode == 'results'
      query_parameters['results'] = true 
        # the only query parameter we currently support is ?results=true 
        # for proposal pages
    if @root.selected_point
      query_parameters['selected'] = @root.selected_point

    # Second, construct the proper url
    if root.page_name == 'homepage' 
      url = ''
    else if root.page_name == 'about'
      url = 'about'
    else #if we're rendering a proposal...
      url = window.app_router.toFragment root.page_name, query_parameters

    # Third, update the location bar if it's different
    if "#{window.location.pathname}#{window.location.search}" != "/#{url}"
      window.app_router.navigate url, {trigger : true}
    ####

    # Now let's render
    DIV onClick: @resetSelection,          
      StateDash(),
      Page(key: "/page/#{root.page_name}"),
      Computer() # Doesn't actually render anything
      Tooltip()


# Displays warnings for some browsers
# Stores state about the current device. 
# Note that IE<9 users are redirected at
# an earlier point to an MS upgrade site. 
BrowserHacks = ReactiveComponent
  displayName: 'BrowserHacks'

  render : ->
    browser = fetch 'browser'
    if  browser.is_opera_mini #|| browser.is_android_browser
      DIV 
        style: 
          backgroundColor: 'red'
          padding: 10
          textAlign: 'center'
          color: 'white'
          fontSize: 24

        "This website does not work well with "
        if browser.is_android_browser then 'the Android Browser' else 'Opera Mini'
        ". Please use "
        A 
          href: "https://play.google.com/store/apps/details?id=com.android.chrome&hl=en"
          style: 
            color: 'white'
            textDecoration: 'underline'
          'Chrome for Android' 
        ' if you experience difficulty. Thanks, and sorry for the inconvenience!'

    else 
      # Use third party script for detecting and warning users
      # of other outdated browsers. Sticking with
      # third party for now because of some complexities
      # in detecting some of these browser versions. In 
      # the future, probably want to extract the logic. 
      # "https://browser-update.org/update.html"
      SCRIPT type: 'text/javascript', src: '//browser-update.org/update.js'




# Fetch current user every 2 minutes so that if the user gets
# logged out (e.g. by server deploy after letting a browser window stay open), 
# their browser will accurately reflect reality. 
# Only do this if user is already logged in, so that we don't 
# accidently interfere with a login process.
# TODO: Remove this after we have true realtime updates
setInterval -> 
  current_user = fetch '/current_user'
  if current_user.logged_in
    arest.serverFetch('/current_user')
, 2 * 60 * 1000


##
# Routing
window.root = null
Router = Backbone.Router.extend
  
  routes :
    "(/)" : "homepage"
    "about(/)" : "about"
    "edit_profile(/)" : "edit_profile"
    "proposal/new(/)" : "new_proposal"
    "proposal/:proposal/edit(/)": "edit_proposal"
    ":proposal(/)": "proposal"    
    "dashboard/:dash(/)": "dashboard"

  proposal : (slug, params) ->
    root = fetch('root')
    resetState(root)

    root.page_name = slug

    #TODO: Manage proposal_mode {crafting/results} with client state on 
    #      the proposal. Right now activeREST doesn't allow wide consumption 
    #      of a component's client state if its data is synced with the server. 
    root.proposal_mode = 'crafting'
    root.selected_point = null
    if params 
      root.proposal_mode = 'results' if params['results']
      root.selected_point = params['selected'] if params['selected']

    save root

    writeToLog
      what: 'loaded page',
      where: slug

  homepage : (params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = 'homepage'
    save root

    writeToLog
      what: 'loaded page',
      where: 'homepage'

  about : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'about'
    save root

    writeToLog
      what: 'loaded page',
      where: 'about'

  new_proposal : (params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = 'proposal/new'
    save root

  edit_proposal : (id, params) ->
    root = fetch('root')
    resetState(root)
    root.page_name = "proposal/#{id}/edit"
    save root

  dashboard : (dash, params) -> 
    root = fetch('root')
    resetState(root)
    root.page_name = "dashboard/#{dash}"    
    save root

  edit_profile : (params) -> 
    root = fetch('root')
    resetState(root)

    root.page_name = 'edit_profile'
    root.auth = {form: 'edit profile', ask_questions: true}

    save root


# Temporary method for handling resetting root state when switching between
# routes. Remove once we have a better activeREST answer. 
resetState = (root) ->
  root.auth = null

  #TODO: Manage proposal_mode {crafting/results} with client state on 
  #      the proposal. Right now activeREST doesn't allow wide consumption 
  #      of a component's client state if its data is synced with the server. 
  root.proposal_mode = null    
  root.selected_point = null

  hist = fetch('histogram')
  hist.selected_opinion = hist.selected_opinions = hist.selected_opinion_value = null
  save hist

window.app_router = new Router()
window.on_ajax_error = () ->
  (root = fetch('root')).server_error = true
  save(root)
window.on_client_error = (e) ->
  if navigator.userAgent.indexOf('PhantomJS') >= 0
    # don't care about errors on phtanomjs web crawlers
    return

  save(
    key: '/new/client_error'
    stack: e.stack
    message: e.message or e.description
    name: e.name
    line_number: e.lineNumber
    column_number: e.columnNumber
    )

window.writeToLog = (entry) ->
  _.extend entry, 
    key: '/new/log'
    where: fetch('root').page_name

  save entry

# exports...
window.Point = Point
window.Comment = Comment
window.Avatar = Avatar
window.Button = Button
window.ProfileMenu = ProfileMenu
window.Histogram = Histogram

#######
# Start the app!


$( ->
  #static consider.it homepage doesn't want this stuff by default
  if document.getElementById('content') 
    # add styles
    $('body').append("<style type='text/css'>#{styles}</style>")

    if 'ontouchend' in document #detect touch support
      React.initializeTouchEvents(true)

    Backbone.history.start {pushState: true}
    window.root = React.renderComponent(Root(), document.getElementById('content'))
)
