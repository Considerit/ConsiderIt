#////////////////////////////////////////////////////////////
# Exploratory reimplementation of considerit client in React
#////////////////////////////////////////////////////////////

# Ugliness in this prototype: 
#   - Provision of @data() as a function via reactiveREST, rather than a straight up object. I couldn't
#     figure out a way to do it more cleanly. 
#   - Children needing to know the parent Proposal's key, and using active_proposal_key() to get it
#   - Programmer needing to know multiple ActiveREST cache keys to save new points to
#   - UI state and persisted data stored in same place (when saving, what to send to server?)
#   - Figuring out if the route was changed. Or more generally, knowing what the diff in state was
#     in the lifecycle methods now that we're not using @props or @state. Right now using a hack
#     (see use of _route_changed ActiveREST cache key)
#   - All UI state _must_ be declared in the @getDefaultData method for the component at which
#     that state will be stored. Otherwise, getters and setters won't be operative!
#   - Computed state not yet stored in ActiveREST
#   - Easy for programmer to accidently mess up ActiveREST cache
#   - Managing top_level_component in Router
#   - NewPoint CSS/HTML is still bulky, waiting on redesign

# ##
# React aliases
R = React.DOM

# ##
# Constants, especially used for layout styling
TRANSITION_SPEED = 700   # Speed of transition from results to crafting (and vice versa) 
BIGGEST_POSSIBLE_AVATAR_SIZE = 50
GRID_MAJOR = 48  #GRID_MAJOR = GRID_MINOR + GRID_GUTTER
GRID_MINOR = 30
GRID_GUTTER = 18
PAGE_WIDTH = 24 * GRID_MAJOR
CONTENT_WIDTH = PAGE_WIDTH - 4 * GRID_MAJOR
BODY_WIDTH = CONTENT_WIDTH - 8 * GRID_MAJOR - 2 * GRID_GUTTER
POINT_WIDTH = BODY_WIDTH / 2 - 20
POINT_CONTENT_WIDTH = POINT_WIDTH - 35 - GRID_GUTTER
HISTOGRAM_WIDTH = BODY_WIDTH    # Width of the slider / histogram base 
DECISION_BOARD_WIDTH = BODY_WIDTH + 4 # the four is for the border
REASONS_REGION_WIDTH = DECISION_BOARD_WIDTH + 2 * POINT_CONTENT_WIDTH + 4 * GRID_GUTTER + 4
MAX_HISTOGRAM_HEIGHT = 200

##
# Helpers that should probably go elsewhere

capitalize = (string) -> string.charAt(0).toUpperCase() + string.substring(1)
L = loading_indicator = R.div null, 'Loading...'

# Returns the top level Proposal component key. Components use this to grab data
# from its Proposal. This is a hack. Shadowing parent state would solve the problem.
# window.current_proposal = () ->
#         long_id = fetch('root')?.url.split('/')[1]
#         fetch('/page/' + long_id).proposal
getStanceSegment = (value) ->
  for i in [0..5]
    if value < stanceSegmentBoundaries[i + 1]
      return i
  return 6

userOpinion = (user_key) ->
  window.user_opinions[user_key]


_route_changed = false

togglePage = (page_name) -> 
  $('.histogram_segment_pole').ensureInView
    offset_buffer: 150
    callback : -> 
      root = fetch('root')
      root.page_name = page_name
      save(root)

      # Kludge for tracking when the page changes
      _route_changed = true
      _.delay -> 
        _route_changed = false
      , 1



stanceSegmentBoundaries = { 0 : -1, 1 : -.9999, 2 : -0.5, 3 : -0.05, 4 : 0.05, 5 : 0.5, 6 : .9999 } 

stance_names = 
  6 : 'Fully Support'
  0 : 'Fully Oppose'
  5 : 'Firmly Support'
  1 : 'Firmly Oppose'
  4 : 'Slightly Support'
  2 : 'Slightly Oppose'
  3 : 'Are Neutral'

##
# PageTransition mixin
# Helper for components that implement a page transition animation.
# Applies styles defined in the component that change
# depending on the route. 
#
# The styles will be added on every update and on component mount. 
# However, it will *animate* the styles only if the page has changed (_route_changed). 
# Otherwise it just directly applies the styles
PageTransition = 

  componentDidMount : -> @applyStyles false

  componentDidUpdate : (prev_props, prev_page) -> 
    @applyStyles _route_changed

  applyStyles : (animate) -> 
    duration = if animate then TRANSITION_SPEED else 0
    root = @data('root')        
    $el = $(@getDOMNode())


    # Each Component that implements this mixin can get triggered multiple times after a route change. 
    # So we're going to ensure that we apply styles only once for a given route change. 
    return if @transitioning == root.page_name
    @transitioning = root.page_name

    switch @name

      # The histogram will get transparent when moving to crafting page
      when 'histogram'
        opacity = if root.page_name == 'crafting' then '0.2' else '1.0'
        $el.find('.histogram_bar').velocity {opacity: opacity}, {duration}

      # The position of the CommunityPoints will move to the wings on crafting, and 
      # be close together in results
      when 'communitypoints'

        if root.page_name == 'crafting'
          offset_x = if @props.key == 'pros' then 0 else DECISION_BOARD_WIDTH
        else if root.page_name == 'results'
          offset_x = DECISION_BOARD_WIDTH / 2

        $el.velocity { translateX: offset_x }, {duration}

      # The slider handle and mouth will change size and location when moving between crafting and results
      when 'slider'
        slider = @data('slider')

        mouth_scaler = if slider.stance_segment >  3 then -1 else 1
        mouth_x      = if slider.stance_segment == 3 then  0 else -7.5

        if root.page_name == 'crafting'
          bubblemouth_style = { scaleX: mouth_scaler * 1.5, scaleY: 1.5, translateY: 7, translateX: mouth_x * 1.5  }
          handle_style = { scale: 2.5, translateY: -8 }
        else 
          bubblemouth_style = { scaleX: mouth_scaler, scaleY: 1, translateY: -4.5, translateX: mouth_x  }
          handle_style = { scale: 1, translateY: -9 }

        $el.find('.bubblemouth').velocity bubblemouth_style, {duration}
        $el.find('.the_handle').velocity handle_style, {duration}

      # The decision board will have to expand for crafting and collapse into to the Give Opinion button in results
      when 'decisionboard'
        if root.page_name == 'crafting'
          decision_board_style =  { translateX: 0, translateY: 0, width: "#{DECISION_BOARD_WIDTH}px", minHeight: "275px"}

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.give_opinion_button').css 'visibility', 'hidden'
          _.delay => 
            #delay & check in case of quick switch between pages
            if root.page_name == 'crafting'
              $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', ''
          , duration

        else 
          slider = @data('slider')
          stance = slider.stance

          give_opinion_button_width = 200
          gutter = .1 * give_opinion_button_width

          opinion_region_x = -gutter + (DECISION_BOARD_WIDTH - give_opinion_button_width + 2 * gutter) * -(stance-1) / 2.0

          decision_board_style =  { translateX: opinion_region_x, translateY: -18, width: "#{give_opinion_button_width}px", minHeight: "32px"}

          $el.find('.decision_board_body').velocity decision_board_style, {duration}

          $el.find('.your_points, .save_opinion_button, .cancel_opinion_button').css 'display', 'none'
          _.delay => 
            #check in case of quick switch between pages
            if root.page_name == 'results'
              $el.find('.give_opinion_button').css 'visibility', ''
          , duration  
      else
        throw "The #{@name} component does not define any styles to animate"

    _.delay => 
      @transitioning = null
    , duration


## ##################
# React Components
#
# These are the components and their relationships:
#
#                     Application 
#                          |
#                       Proposal
#                   /      |           \            \
#    CommunityPoints   DecisionBoard   Histogram    Slider
#               |          |
#               |      YourPoints
#               |    /            \
#              Point             NewPoint
#
#   (also, Proposal, Histogram, and Point employ Avatar)


##
# Proposal
# Has proposal description, feelings area (slider + histogram), and reasons area
Proposal = ReactiveComponent
  displayName: 'Proposal'

  ##
  # Lifecycle methods
  componentDidMount : -> 
    $el = $(@getDOMNode())
    $el.find('.proposal_heading.stickable').stickyTopBottom
      placeholder: $el.find('.proposal_heading.placeholder')[0]
      container: $el

  componentDidUpdate : ->
    $el = $(@getDOMNode())
    $el.find('.proposal_heading.stickable').stickyTopBottom('update')

    # $el.find('.description_region').css
    #   top: $el.find('.proposal_heading').height() + 24

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.find('.proposal_heading.stickable').stickyTopBottom('destroy')

  ##
  # Make this thing!
  render : ->
    proposal = @data()
    root = @data('root')
    your_opinion = @data(proposal.your_opinion)
    included_points = your_opinion.point_inclusions

    description_region_style = {width: 1.25 * BODY_WIDTH}

    # Update global references:
    #  - The current_proposal for this page
    #  - The user_opinions hash (maps users to their opinions in this proposal)
    #  - The current user's opinion: your_opinion
    window.user_opinions = {}
    for opinion in proposal.opinions
      window.user_opinions[opinion.user] = opinion

    # I need to improve save() so that it knows when things actually
    # change because these if statements are stupid
    if root.current_proposal != proposal.key
      root.current_proposal = proposal.key
      save(root)
    if root.your_opinion_key != proposal.your_opinion
      root.your_opinion_key = proposal.your_opinion
      save(root)

    proposer = @data(proposal.user)

    # Temporary approach to Proposal description fields. 
    # Description fields are the expandable details that help people drill
    # into the proposal. They are very specific to the type of proposal (e.g. for
    # an LVG ballot measure, one of the fields might be "fiscal impact statement").  
    # For Tigard, I'm storing all these fields in proposal.additional_description1
    # as a serialized JSON object of the following structure:
    #       [ {"label": "field one", "html": "<p>some details</p>"}, ... ] 
    # If we choose to use this more flexible approach, we can migrate all the old 
    # data to this format, rename the column, and get rid of a bunch of columns on 
    # Proposal that will be made obsolete. 
    if !@local.description_fields
      # Deserialize the description fields. 
      # It would be nice if ActiveREST recognized that a field is a serialized data object!
      # This will fail for proposals that are not using the serialized JSON format; 
      # For now, we'll just catch the error and carry on 
      try 
        @local.description_fields = $.parseJSON(@data().additional_description1)
        @local.expanded_field = null
      catch
        @local.description_fields = null


    R.div className:'proposal', key:@props.long_id, 'data-page':root.page_name,
      R.div className: 'proposal_heading stickable',  style : { minWidth: PAGE_WIDTH }, # minwidth is for width consistency when dropping into fixed sticky header
        R.span null,"#{if proposal.category && proposal.designator then proposal.category + ' ' + proposal.designator + ':' else ''}#{proposal.name}"

      R.div className: 'proposal_heading placeholder', 
        R.span null,"#{if proposal.category && proposal.designator then proposal.category + ' ' + proposal.designator + ':' else ''}#{proposal.name}"

      #description

      R.div className:'description_region', style: description_region_style, 

        # R.div className: 'context',
          
        #   R.div className: 'proposer_name', "posted by #{if proposer then proposer.name else ''}" 

        R.div className: 'proposal_details', dangerouslySetInnerHTML:{__html: proposal.description}

        if @local.description_fields
          R.div className: 'description_fields',
            for field in @local.description_fields
              do (field) => 
                R.div className: 'description_field', key: field.label,
                  R.div className: 'field_heading', onClick: (=> field.expanded = !field.expanded; save(@local);),
                    R.span className: 'expand_arrow', dangerouslySetInnerHTML: {__html: if field.expanded then '&#9660;' else '&#9658;'}
                    R.span className: 'field_name', field.label
                  if field.expanded
                    R.div className: 'field_body', dangerouslySetInnerHTML:{__html: field.html}

    
      #feelings
      R.div className:'feelings_region', style : { width: BODY_WIDTH },
        OpinionFilter()
        Histogram()

      if root.auth_mode
        Auth()
      else
        #reasons
        R.div 
          className:'reasons_region'
          style : { width: REASONS_REGION_WIDTH }, #, left: -(REASONS_REGION_WIDTH - CONTENT_WIDTH) / 2 },
            #community pros
            CommunityPoints { key: 'pros' }

            DecisionBoard()

            #community cons
            CommunityPoints { key: 'cons' }


##
# Histogram
Histogram = ReactiveComponent
  displayName : 'Histogram'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  getDefaultProps : ->
    opinions: []

  ##
  # buildHistogram
  # Split up opinions into segments. For now we'll keep three hashes: 
  #   - all opinions
  #   - high level segments (the seven segments, strong supporter, neutral, etc)
  #   - small segments that represent individual columns in the histogram,
  #     now that we do not have wide bars per se
  buildHistogram : ->
    ##
    # Size the avatars. Size of avatar shrinks proportional to 1/sqrt(num_opinions)
    opinions = @data(@data('root').current_proposal).opinions || []

    avatar_size = Math.min BIGGEST_POSSIBLE_AVATAR_SIZE, 
      Math.floor(BIGGEST_POSSIBLE_AVATAR_SIZE / Math.sqrt( (opinions.length + 1) / 10 )  )

    # Calculate about how many columns of opinions to put on the histogram. 
    columns_in_histogram = Math.floor(HISTOGRAM_WIDTH / avatar_size)

    max_slider_variance = 2.0 # Slider stances vary from -1.0 to 1.0. 

    # Assign each column in the histogram to a segment. Each column is an 
    # empty array which will eventually hold opinions.
    segments = ( [] for segment in [0..6] )
    for col in [0..columns_in_histogram]
      segment = getStanceSegment(max_slider_variance * col / columns_in_histogram - 1)
      segments[segment].push []

    # ensure neutral segment has 3 columns
    segments[3].push([]) while segments[3].length < 3   

    # Assign each Opinion to a column
    # This gets complicated because we treat the extremes and Neutral differently. 
    #  - The number of columns in the extremes is variable, with the max number
    #    of opinions per columns capped. Here we'll dynamically grow the number of 
    #    cols in each extreme, subdividing the cols whenever they hit their max number. 
    #  - There are three columns for Neutral. We distributed the opinions evenly 
    #    across these three. 
    #  - Opinions belonging to other places along the spectrum are mapped directly 
    #    to the column associated with that stance.     
    opinions_in_segment = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0}
    max_opinions_in_column = Math.floor MAX_HISTOGRAM_HEIGHT / avatar_size
    for opinion in opinions
      segment = getStanceSegment opinion.stance

      # If this is a Neutral opinion, fill up all three neutral cols equally
      if segment == 3
        segments[3][opinions_in_segment[3] % 3].push opinion

      # If this is an extreme opinion...
      else if segment in [0,6]
        last_col_in_segment = segments[segment].length - 1
        if segments[segment][last_col_in_segment].length == max_opinions_in_column - 1
          segments[segment].push []

        segments[segment][last_col_in_segment].push opinion

      # If this opinion is somewhere else on the spectrum...
      else
        adjusted_stance = Math.abs(opinion.stance - stanceSegmentBoundaries[segment])
        col_width = Math.abs( stanceSegmentBoundaries[segment + 1] - 
          stanceSegmentBoundaries[segment])/segments[segment].length
        segments[segment][Math.floor(adjusted_stance / col_width)].push opinion

      opinions_in_segment[segment] += 1

    # make sure that the extreme segment with fewest opinions has as 
    # many columns as the other extreme
    if segments[0].length != segments[6].length
      if segments[0].length > 
         segments[6].length then [bigger, smaller] = [segments[0], segments[6]] else 
                                 [bigger, smaller] = [segments[6], segments[0]]
      
      all_opinions_in_smaller = _.flatten(smaller)

      smaller.push([]) while smaller.length < bigger.length

      for column in smaller
        column.pop() while column.length > 0

      for opinion, idx in all_opinions_in_smaller
        smaller[idx%smaller.length].push opinion

    num_columns = _.flatten(_.values(segments), true).length

    [num_columns, segments, avatar_size]

  onClickHistogram : (ev) ->
    if @data('root').page_name == 'crafting'
      togglePage('results')

  onSelectSegment : (ev) ->
    if @data('root').page_name == 'results'
      segment = $(ev.currentTarget).data('segment')

      selected_segment = @data('histogram').selected_segment

      # If clicking on already hard-selected segment, then we'll deselect. 
      segment = if selected_segment[0] == segment && 
                   selected_segment[1] then null else segment
      click_select = ev.type == 'click' 

      #ignore mouseEnter and mouseLeave events if selection was via click
      return if selected_segment && selected_segment[1] && !click_select 

      @data('histogram').selected_segment = [segment, click_select && segment]
      ev.stopPropagation()

  render : ->
    selected_segment = @data('histogram').selected_segment
    users_to_highlight = @data('histogram').highlighted_users
    [num_columns, segments, avatar_size] = @buildHistogram() #todo: memoize

    effective_histogram_width = num_columns * avatar_size
    margin_adjustment = -(effective_histogram_width - HISTOGRAM_WIDTH)/2
    #make sure that the neutral segment is centered
    margin_adjustment += (segments[0].length - segments[6].length) / 2 * avatar_size

    R.table 
      className: 'histogram'
      onClick: @onClickHistogram
      # onMouseLeave: @onSelectSegment
      style: { width: effective_histogram_width, marginLeft: margin_adjustment }, 
        R.tr null, 
          for bars, idx in segments.reverse()
            segment = 6 - idx
            is_selected = selected_segment[0] == segment
            R.td 
              className:"histogram_segment #{if is_selected then 'is_selected' else 'not_selected'}"
              key:segment
              # onMouseEnter: @onSelectSegment
              'data-segment':segment
              style : { opacity: (if is_selected && !selected_segment[0]? then '1' else '1') }
            ,
              R.table null,
                R.tr null,
                  for bar, idx in bars
                    R.td key: idx , className:"histogram_bar", style: {width: avatar_size},
                      for opinion in bar
                        user = opinion.user
                        Avatar 
                          tag: R.span, 
                          key: user
                          user: user
                          hide_face: @data('root').page_name == 'crafting'                             
                          'data-segment':segment
                          style:
                            height: avatar_size
                            width: avatar_size
                            opacity: if users_to_highlight && 
                              !_.contains(users_to_highlight, opinion.user) 
                              then '.15' 
                              else if selected_segment[0] == null || is_selected 
                              then '1.0'
                              else '.15'

              if segment == 6
                R.div className:"histogram_segment_pole", 'Supporters'
              else if segment == 0
                R.div className:"histogram_segment_pole", 'Opposers'

##
# Slider
# Manages the slider and the UI elements attached to it. 
Slider = ReactiveComponent
  displayName: 'Slider'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  componentDidMount : -> 
    @setSlidability()

  componentWillUpdate : (prev_props, prev_state) ->
    @setSlidability()

  ##
  # setSlidability
  # Inits jQuery UI slider and enables/disables it between pages
  setSlidability : ->

    root = @data('root')
    slider = @data('slider')
    
    # Wait to set slidability until we have an opinion from the server.
    # Otherwise slider will get initialized with a NaN stance that 
    # breaks the slider. 
    return if !@data(root.your_opinion_key).stance?


    $slider_base = $(@getDOMNode()).find('.slider_base')
    if $slider_base.hasClass "ui-slider"
      if !slider.is_moving
        $('.slider_base').slider({value: -slider.stance})
      $slider_base.slider(if root.auth_mode then 'disable' else 'enable')
    else
      $slider_base.slider
        disabled: root.auth_mode
        min: -1
        max: 1
        step: .01
        value: -@data(root.your_opinion_key).stance
        slide: (ev, ui) => 
          # Update the stance segment if it has changed. This facilitates 
          # the feedback atop the slider changing from e.g. 'strong 
          # supporter' to 'neutral'
          return false if ev.originalEvent.type != 'mousemove'

          slider.has_moved = true
          slider.is_moving = true
          slider.stance_segment = getStanceSegment -ui.value
          slider.stance = -ui.value

          save(slider)
        stop : (ev, ui) =>
          if root.page_name == 'results'
            togglePage('crafting')

          # We save the slider's position to the server only on mouse-up.
          # This way you can drag it with good performance.
          your_opinion = @data(@data('root').your_opinion_key)
          slider = @data('slider')
          if your_opinion.stance != slider.stance
            your_opinion.stance         = slider.stance
            your_opinion.stance_segment = slider.stance_segment
            save(your_opinion)

          slider.is_moving = false
          save(slider)

  togglePage : (ev) ->
    root = @data('root')
    if !root.auth_mode
      new_page = if root.page_name == 'results' then 'crafting' else 'results'
      togglePage(new_page)
    ev.stopPropagation()

  render : ->
    slider = @data('slider')
    stance = slider.stance
    segment = slider.stance_segment

    # Update the slider position when the server gets back to us
    your_opinion = @data(@data('root').your_opinion_key)
    if slider.stance != your_opinion.stance and !slider.is_moving
      slider.stance = your_opinion.stance
      slider.stance_segment = your_opinion.stance_segment
      slider.has_moved = true
      save(slider)


    page = @data('root').page_name
    is_auth_mode = @data('root').auth_mode
    sticky = @data('decisionboard').sticky

    #jquery UI slider will pick an el with this class name up
    props_for_slider_handle = { className:'ui-slider-handle' } 
    if page == 'results'    
      _.extend props_for_slider_handle, 
        onClick: => @togglePage
        style: { cursor : 'pointer' } 

    # Can't be dynamically set b/c of integration with asset fingerprinting. This is 
    # also why this file is ERB
    if segment == 3
      if page == 'crafting'
        bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
      else
        bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-results.png' %>"
    else
      if page == 'crafting'
        bubblemouth_src = "<%= asset_path 'bubblemouth-crafting.png' %>"
      else
        bubblemouth_src = "<%= asset_path 'bubblemouth-results.png' %>"

    slider_feedback_percent = 
      if segment == 3 
      then "Neutral" 
      else "#{Math.floor(Math.abs(stance) * 100)}% #{if segment > 3 then 'Support' else 'Oppose'}"

    slider_feedback_bucket = stance_names[segment]
    
    face_left_eye_style = 
      transform: 
        if segment in [0, 6] 
        then 'scale(.9, .8)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_right_eye_style = 
      transform: 
        if segment in [0, 6] 
        then 'scale(1.1, 1.2)' 
        else "scale(#{.8 + .2 * Math.abs(stance)}, #{.8 + .2 * Math.abs(stance)})"

    face_mouth_style = 
      transform: 
        "scale(#{.4 + .3 * Math.abs(stance) }, #{.08 + .4 * stance}) 
         translate(0, #{-2 - 5 * Math.abs(stance)}px) 
         rotate(45deg) 
         skew(#{if segment in [0,6] then '10deg' else '0deg'})"

    # safari only respects -webkit-transform
    crossbrowserTransformProperty = (props) -> _.extend props,
      '-webkit-transform' : props.transform
      '-ms-transform' : props.transform
      '-moz-transform' : props.transform

    crossbrowserTransformProperty sty for sty in [
      face_left_eye_style, face_right_eye_style, face_mouth_style]

    # ugly access here...this is a hack that hides a dependency between slider and histogram 
    triangle_width = 
      if sticky
      then 0 
      else $('.histogram_segment[data-segment="0"]').width() + 5

    slider_base_triangle_style = 
      borderLeft: "#{triangle_width}px solid transparent"
      borderRight: "#{triangle_width}px solid transparent"



    # Keep feedback centered over handle, but keep within the bounds of the slider region 
    # when the slider is in an extreme position. 
    feedback_left = (DECISION_BOARD_WIDTH ) * -(stance-1) / 2.0 
    if sticky 
      feedback_width = if slider.has_moved then 190 else 400
      if feedback_left > DECISION_BOARD_WIDTH / 2
        feedback_left = Math.min(DECISION_BOARD_WIDTH - feedback_width/2 + 35, feedback_left)
      else if feedback_left < DECISION_BOARD_WIDTH / 2
        feedback_left = Math.max(feedback_width/2 - 35, feedback_left)
    else
      feedback_width = 450

    slider_feedback_style = 
      visibility: if sticky && !is_auth_mode then 'visible' else 'visible'
      left: feedback_left
      marginLeft: -feedback_width / 2
      width: feedback_width
      fontSize: if sticky then '18px' else '29px'
      top: if sticky then '-65px' else '-80px'

    if !slider.has_moved 
      slider_feedback = 'Give Your Overall Opinion' 
    else 
      slider_feedback = "You #{slider_feedback_bucket}"


    R.div className: 'slider', 
      R.div className:'slider_base', style : {width: HISTOGRAM_WIDTH}, 
        R.div 
          className: 'slider_base_triangle_left'
          style: _.extend({}, slider_base_triangle_style, {left: -triangle_width})
        R.div 
          className: 'slider_base_triangle_right'
          style: _.extend({}, slider_base_triangle_style, {right: -triangle_width})
        R.div 
          className:'slider_feedback'
          'data-stance-segment': segment
          style: slider_feedback_style
        , slider_feedback

        R.div props_for_slider_handle, 

          R.div className: 'the_handle', onClick: @togglePage,
            if page == 'crafting'
              R.div className: 'face',            
                R.div className: 'face_mouth face_part', style: face_mouth_style
                R.div className: 'face_left_eye face_eye face_part', style: face_left_eye_style
                R.div className: 'face_right_eye face_eye face_part', style: face_right_eye_style
            R.div className: 'drag_arrow right', '>' if page == 'crafting' && !slider.has_moved && !is_auth_mode
            R.div className: 'drag_arrow left', '<' if page == 'crafting' && !slider.has_moved && !is_auth_mode

          R.img className:'bubblemouth', src: bubblemouth_src

##
# OpinionFilter
# Filters whose opinions are displayed
OpinionFilter = ReactiveComponent
  displayName: 'OpinionFilter'

  onSelectSegment : (segment) ->
    hist = @data('histogram')
    hist.selected_segment = if hist.selected_segment == segment then [null, null] else [segment, segment != null]
    save(hist)

  render : ->
    hist = @data('histogram')

    # Remove filter when on crafting page
    if @data('root').page_name == 'crafting'
      hist.selected_segment = [null, null] if hist.selected_segment[0] 

    filter_options = ['show all opinions',
        'only full opposers',
        'only firm opposers',
        'only slight opposers',
        'only neutrals',
        'only slight supporters',
        'only firm supporters',
        'only full supporters']

    R.div className: 'opinion_filter_region',
      for phrase, i in filter_options

        # Shift i by 1, and start with null
        i = i-1
        if i == -1
          i = null

        c = "filter_option"
        if hist.selected_segment[0] == i
          c = c + ' selected'

        # I had to make this wrapper to make a new context for i
        wrapper = (i) => (=> @onSelectSegment(i))
        R.a key: "segment-#{i}", className: c, onClick: wrapper(i), phrase


##
# DecisionBoard
# Handles the user's list of important points in crafting page. 
DecisionBoard = ReactiveComponent
  displayName: 'DecisionBoard'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  componentDidMount : ->
    @setStickyHeader()

    # make this a drop target
    $el = $(@getDOMNode())
    $el.droppable
      accept: ".point_content"
      drop : (ev, ui) =>
        if ui.draggable.parent().is('.community_point')
          your_opinion = @data(@data('root').your_opinion_key)
          ui.draggable.parent().velocity 'fadeOut', 200, -> 
            your_opinion.point_inclusions.push(
              ui.draggable.parent().data('id'))
            save(your_opinion)
          $el.removeClass "user_is_hovering_on_a_drop_target"
      out : (ev, ui) => 
        $el.removeClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')
      over : (ev, ui) => 
        $el.addClass("user_is_hovering_on_a_drop_target") if ui.draggable.parent().is('.community_point')

  componentWillUnmount : -> 
    $el = $(@getDOMNode())
    $el.stickyTopBottom('destroy')

  componentDidUpdate : -> 
    $el = $(@getDOMNode())    

    # hack to get around a problem where the browser's remembered scroll position messes
    # up the sticky location after initialization
    if !@initial_position_fixed
      $el.stickyTopBottom('fix_initial_position')
      @initial_position_fixed = true

  setStickyHeader : ->
    $el = $(@getDOMNode())

    slider_region_height =  115 #$el.find('.slider .the_handle').outerHeight() + $el.find('.slider .slider_feedback').outerHeight() + 15 + 20 #15 is bubblemouth

    $el.stickyTopBottom
      container: $('.reasons_region')
      top_offset: $('.proposal_heading').outerHeight() + slider_region_height
      bottom_offset: 20
      unsticks: =>
        d = @data()
        d.sticky = false
        save(d)
      sticks: =>
        d = @data()
        d.sticky = true
        save(d)
      conditional: => @data('root').page_name == 'crafting'

  # When user clicks the big bold button at the bottom of the crafting page
  saveYourOpinion : -> 
    root = @data('root')
    your_opinion = @data (root.your_opinion_key)
    if @data('/current_user').logged_in
      your_opinion.published = true
      save your_opinion
      togglePage('results')
    else
      root.auth_mode = 'register'
      #we'll need to publish this opinion after auth is completed
      root.publish_this_opinion = true
      save(root)


  render : ->
    root = @data('root')
    current_user = @data('/current_user')
    your_opinion = @data(root.your_opinion_key)

    # Need to register this dependency because ActiveREST doesn't pick it up. 
    # In results state, decision board position depends on the slider position.
    @data('slider')

    # Centering the Decisionboard
    # When the screen is too small & the board is sticky, the board can be 
    # misplaced because fixed elements are not sized wrt their parents, but
    # the viewport. So we're going to be sensitive to the width of the screen
    # in how we center the decision board. 
    media = @data('media')
    if media.width >= PAGE_WIDTH || !@data().sticky
      opinion_region_style = 
        left: '50%'
        marginLeft: -DECISION_BOARD_WIDTH / 2
    else
      opinion_region_style = 
        left: POINT_CONTENT_WIDTH + 2 * GRID_GUTTER + 69 #69 is the margin of the reasons_region

    opinion_region_style.width = DECISION_BOARD_WIDTH

    R.div className:'opinion_region focal_wrapper', style: opinion_region_style,
      Slider()

      R.div 
        className:'decision_board_body focal_area'
        onClick: => if root.page_name == 'results' then togglePage('crafting')
      ,

        R.div null, 
          # only shown during crafting, but needs to be present always for animation
          R.div className: 'your_points',
            # your pros
            YourPoints { valence: 'pros' }

            # your cons
            YourPoints { valence: 'cons' }

          # only shown during results, but needs to be present always for animation
          R.a 
            className:'give_opinion_button primary_button'
          , if your_opinion.published then 'Update your Opinion' else 'Give your Opinion'

      R.div 
        className:'save_opinion_button primary_button'
        onClick: @saveYourOpinion
      , 'Save your opinion and see results'

      R.a 
        className:'cancel_opinion_button primary_cancel_button'
        onClick: (=> togglePage('results'))
      , 'or just skip to the results'  


##
# YourPoints
# List of important points for the active user. 
# Two instances used for Pro and Con columns. Shown as part of DecisionBoard. 
# Creates NewPoint instances.
YourPoints = ReactiveComponent
  displayName: 'YourPoints'

  render : ->
    root = @data('root')
    included_points = @data(root.your_opinion_key).point_inclusions
    left_or_right = if @props.valence == 'pros' then 'left' else 'right'

    R.div 
      className:"points_on_decision_board #{@props.valence}_on_decision_board"
      style: { width: POINT_WIDTH }
    ,
      R.div className:'points_heading_label',
        "Give Your #{capitalize(@props.valence)}"

      R.ul null,
        for point in included_points
          if @data(point).is_pro == (@props.valence == 'pros')
            Point { key: point, location_class: 'decision_board_point' }

        R.div className:'add_point_drop_target',
          R.div className: "drop_target_circle_#{left_or_right}"
          R.img className:'drop_target', src: "<%= asset_path 'drop_target.png' %>"
          R.span className:'drop_prompt',
            #"Drag #{@props.valence} points from the #{if @props.valence == 'pro' then 'left' else 'right'} that resonate with you."
            "Drag a #{capitalize(if @props.valence=='pros' then 'pro' else 'con')} from the #{left_or_right}"

        NewPoint { valence: @props.valence }

##
# CommunityPoints
# List of points contributed by others. 
# Shown in wing during crafting, in middle on results. 
CommunityPoints = ReactiveComponent
  displayName: 'CommunityPoints'
  mixins: [PageTransition] #implements animation logic when moving results <==> crafting

  buildNewPointThreshold : ->
    # Grab the 10th percentile
    points = @data(@data('root').current_proposal).points || []
    newpoint_threshold = 
      (_.sortBy points, (pnt) => - Date.parse(pnt.created_at))[Math.ceil(points.length / 10)]

    (newpoint_threshold and Date.parse(newpoint_threshold.created_at)) or 
      new Date()

  buildPointsList : ->
    is_results = @data('root').page_name == 'results'
    selected_segment = @data('histogram').selected_segment
    proposal = @data(@data('root').current_proposal)
    included_points = @data(@data('root').your_opinion_key).point_inclusions
    points = proposal.points
    opinions = proposal.opinions

    points =
      _.filter points, (pnt) =>
        is_correct_valence = pnt.is_pro == (@props.key == 'pros')
        has_not_been_included = is_results || !_.contains(included_points, pnt.key)
        is_correct_valence && has_not_been_included
    
    if selected_segment[0]?
      # If there is a histogram segment selected, we'll have to filter down 
      # to the points that users in this segment think are important, and 
      # order them by resonance to those users. I'm doing this quite inefficiently.
      point_inclusions_per_point_for_segment = {} # map of points to including users
      _.each opinions, (opinion) =>
        if opinion.stance_segment == selected_segment[0] && opinion.point_inclusions
          for point in opinion.point_inclusions
            if !(point of point_inclusions_per_point_for_segment)
              point_inclusions_per_point_for_segment[point] = 1
            else
              point_inclusions_per_point_for_segment[point] += 1

      points = 
        _.filter points, (pnt) -> pnt.key of point_inclusions_per_point_for_segment
      points = 
        _.sortBy points, (pnt) -> -point_inclusions_per_point_for_segment[pnt.key]
    else
      # Default sort order
      points = 
        _.sortBy points, (pnt) => - if is_results then pnt.score else pnt.persuasiveness

    points

  render : ->
    selected_segment = @data('histogram').selected_segment

    #filter to pros or cons & down to points that haven't been included
    points = @buildPointsList() #todo: memoize
    newpoint_threshold = @buildNewPointThreshold() #todo: memoize
    label = capitalize @props.key

    R.div 
      className:"points_by_community #{@props.key}_by_community"
      style: { width: POINT_CONTENT_WIDTH, minHeight: (if points.length > 3 then jQuery(window).height() else 400) }
    , 
      R.div className:'points_heading_label', 
        if @data('root').page_name == 'results' then "Top #{label}" else "Others' #{label}"
        R.p className:'points_segment_label', style: {visibility: if selected_segment[0] == null then 'hidden' else 'visible'},
          if selected_segment[0] == null then '-' else "for #{stance_names[selected_segment[0]]}s"          

      R.ul null, 
        if points.length > 0
          for point in points
            Point 
              key: point.key, 
              is_new: Date.parse(point.created_at) > newpoint_threshold
              location_class : 'community_point'
        else
          R.li className: 'empty_point', "No #{label} listed"

##
# Point
# A single point in a list. 
Point = ReactiveComponent
  displayName: 'Point'

  componentDidMount : ->
    @setDraggability()

  componentDidUpdate : -> 
    @setDraggability()

  setDraggability : ->
    # Ability to drag include this point if a community point, 
    # or drag remove for point on decision board
    # also: disable for results page


    disable = @data('root').page_name == 'results'

    $point_content = $(@getDOMNode()).find('.point_content')
    revert = 
      if @props.location_class == 'community_point' 
      then 'invalid' 
      else (valid) =>
        if !valid
          your_opinion = @data(@data('root').your_opinion_key)
          your_opinion.point_inclusions = _.without your_opinion.point_inclusions, @props.key
          save(your_opinion)
          console.log('Saved it.', your_opinion)
        valid

    if $point_content.hasClass "ui-draggable"
      $point_content.draggable(if disable then 'disable' else 'enable') 
    else
      $point_content.draggable
        revert: revert
        disabled: disable


  showDetails : -> 
    @local.show_details = !@local.show_details
    save(@local)

  ## ##
  # On hovering over a point, highlight the people who included this 
  # point in the Histogram.
  highlightIncluders : -> 
    if @data('root').page_name == 'results'
      includers = @data().includers
      point = @data()

      # For point authors who chose not to sign their points, remove them from 
      # the users to highlight. This is particularly important if the author 
      # is the only one who "included" the point. Then it is very eash for 
      # anyone to discover who wrote this point. 
      if point.hide_name
        includers = _.without includers, point.user
      hist = @data('histogram')
      if hist.highlighted_users != includers
        hist.highlighted_users = includers
        save(hist)

  unHighlightIncluders : -> 
    if @data('root').page_name == 'results'
      hist = @data('histogram')
      hist.highlighted_users = null
      save(hist)


  buildIncluders : -> 
    point = @data()
    to_remove = [point.user]

    # only show includers from this stance segment if a segment is selected
    selected_segment = @data('histogram').selected_segment
    if selected_segment[0]?
      for includer in point.includers
        stance_segment = @data(userOpinion(includer)).stance_segment

        if stance_segment && stance_segment != selected_segment[0]
          to_remove.push(includer)

    _.difference point.includers, to_remove

        
  renderIncluders : ->

    if @data().includers

      includers = @buildIncluders()

      s = #includers_style
        rows: 8
        dx: 2
        dy: 5
        col_gap: 8
        side_offset: 32 + 14 + 1

      # Now we'll go through the list from back to front
      i = includers.length

      for includer in includers
        i -= 1
        curr_column = Math.floor(i / s.rows)
        side_offset = s.side_offset + curr_column*s.col_gap + i*s.dx
        top_offset = (i % s.rows) * s.dy + 4
        left_right = if @data().is_pro then 'left' else 'right'
        style = { top: top_offset }
        style[left_right] = -side_offset

        # Finally draw the guy
        Avatar
          key: includer
          tag: R.span
          className: "point_includer_avatar"
          style: style

  renderNewIndicator : ->
    if @data().includers
      side_offset = 51
      left_right = if @data().is_pro then 'left' else 'right'
      style = 
        position: 'absolute'
        color: 'rgb(255,22,3)'
        fontSize: '11px'
        top:'41px'
        backgroundColor: 'white', zIndex: 5
      style[left_right] = "#{-side_offset}"
      R.span {style: style}, '*New*'

  render : -> 
    point = @data()

    selected_segment = @data('histogram').selected_segment
    author_opinion = @data(userOpinion(point.user))

    R.li 
      className: "point closed_point #{@props.location_class} 
        #{if point.is_pro then 'pro' else 'con'}"
      'data-id':@props.key
      onClick: @showDetails
    ,
  
      if @props.location_class == 'community_point' && @props.is_new
        @renderNewIndicator()

      R.div className:'includers', onMouseEnter: @highlightIncluders, onMouseLeave: @unHighlightIncluders, 
        if @props.location_class == 'community_point'
          @renderIncluders()

        if !selected_segment[0] || ( author_opinion && author_opinion.stance_segment == selected_segment[0] )
          Avatar tag: R.span, key: point.user, className:"point_author_avatar", hide_face: point.hide_name

      R.div className:'point_content', style : { width: POINT_CONTENT_WIDTH },
        if @props.location_class == 'community_point'
          R.img 
            className: 'community_point_mouth'
            src: "<%= asset_path 'community_point_mouth.png' %>"

        R.div className:'point_nutshell',
          point.nutshell
          if point.text
            if @local.show_details or 
              (point.nutshell.length + point.text.length) < 210
                R.div className: 'point_details', dangerouslySetInnerHTML:{__html: point.text}
            else
              R.span className: 'point_details_tease', 
                $("<span>#{point.text[0..210-point.nutshell.length]}</span>").text() + "... [more]"

        # R.a className:'open_point_link',
        #   "#{@props.comment_count} comment#{if @props.comment_count != 1 then 's' else ''}"

##
# NewPoint
# Handles adding a new point into the system. Only rendered when proposal is
# in Crafting state. Manages whether the user has clicked "add a new point". 
# If they have, show new point form. 
NewPoint = ReactiveComponent
  displayName: 'NewPoint'
  componentDidUpdate : ->
    if @local.edit_mode
      $(@getDOMNode()).find('#nutshell').focus()

  handleAddPointBegin : (ev) -> 
    @local.edit_mode = true
    @local.add_details = false
    save(@local)

  handleAddPointCancel : (ev) -> 
    @local.edit_mode = false
    save(@local)

  handleToggleDetails : (ev) -> 
    @local.add_details = !@local.add_details
    save(@local)

  handleSubmitNewPoint : (ev) ->
    $form = $(@getDOMNode())
    root = @data('root')

    current_user = @data('/current_user').user
    point =
      key : '/new/point'
      nutshell : $form.find('#nutshell').val()
      text : $form.find('#text').val()
      is_pro : @props.valence == 'pros'
      user : current_user
      comment_count : 0 
      includers : [current_user]
      proposal : @data(root.current_proposal).key
      hide_name : $form.find("sign_name-#{@props.valence}").val()
    save(point)

    @local.edit_mode = false
    save(@local)

    # This is a kludge cause activerest sucks for pre-rendering
    # changes before the server returns them
    
    @data(root.your_opinion_key).point_inclusions.push(point.key)
    re_render([root.your_opinion_key])
  render : ->
    #TODO: refactor HTML/CSS for new point after we get better sense of new point redesign
    @local = @data @local_key,
      edit_mode : false
      sign_name : true
      add_details : false

    R.div className:'newpoint',
      if !@local.edit_mode
        R.div className:'newpoint_prompt',
          R.span className:'qualifier', 
            'or '
          R.span className:'newpoint_bullet', dangerouslySetInnerHTML:{__html: '&bull;'}
          R.a className:'newpoint_link', 'data-action':'write-point', onClick: @handleAddPointBegin,
          "Express a new #{capitalize(if @props.valence == 'pros' then 'pro' else 'con')}"
      else
        R.div className:'newpoint_form',
          R.input id:'is_pro', name: 'is_pro', type: 'hidden', value: "#{@props.valence == 'pros'}"
          R.label htmlFor:'nutshell', 'Your point'
          CharacterCountTextInput id:'nutshell', className:'newpoint_nutshell', maxLength:140, name:'nutshell', pattern:'^.{3,}', placeholder:'Make this summary succinct.', required:'required'
          
          R.div null,
            R.a className: 'add_details', onClick: @handleToggleDetails, title: 'Provide background and/or back your point up with evidence.',
              R.i className: if @local.add_details then 'fa-caret-down fa' else 'fa-caret-right fa'
              R.span null, 'Expand on your point'

            if @local.add_details
              R.div null, 
                AutoGrowTextArea 
                  id:'text'
                  className:'newpoint_description'
                  name:'text'
                  placeholder:'Provide background and/or back your point up with evidence.'
                  required:'required'
                  min_height: 170

          R.div className:'newpoint_hide_name',
            R.input
              className: 'newpoint-anonymous'
              type:      'checkbox'
              id:        "sign_name-#{@props.valence}"
              name:      "sign_name-#{@props.valence}"
              checked:   @local.sign_name
              onChange: =>
                @local.sign_name = !@local.sign_name
                save(@local)
            R.label htmlFor: "sign_name-#{@props.valence}", title:'Signing your point with your name lends it more weight with other participants.', 'Sign your name'
          
          R.div className:'newpoint-submit',
            R.input className:'button primary_button', action:'submit-point', type:'submit', value:'Done', onClick: @handleSubmitNewPoint

            R.a className:'newpoint-cancel primary_cancel_button', onClick: @handleAddPointCancel,
              'cancel'

##
# Avatar
# Displays a user's avatar
# Supports straight up img src, or using the CSS-embedded b64 for each user
Avatar = ReactiveComponent
  has_multiple_instances_with_same_key: true
  displayName: 'Avatar'
  
  render : ->
    user = @data()
    @data(@local_key) # just to register a dependence
    className = "#{@props.className} avatar"

    id = if @props.hide_face then "avatar-hidden" else "avatar-#{user.key.split('/')[2]}"

    if @props.img_style && user.key != -1
      avatar_file_name = user.avatar_file_name

      console.log("Mike hasn't made this avatar's image work yet!  Fix the file line below:")
      if avatar_file_name
        filename = "/system/avatars/#{@props.key}/#{@props.img_style}/#{avatar_file_name}"

    attrs =
      className: className
      id: id
      'data-id': @props.key
      onMouseEnter: @showDetails
      onMouseLeave: @hideDetails

    attrs.src = filename if filename
    
    R.span style: {position: 'absolute'},
      if @local.show_details
        R.span style: {position: 'absolute', bottom: -10},
          @local.name
    @transferPropsTo @props.tag attrs

  getDefaultProps : ->
    key: '/user/-1' # defaults to anonymous user
    tag: R.img
    img_style: null #null defaults to the css-based b64 embedded images
    hide_face: false

  componentWillUpdate : -> 
    if @local.show_details
      @insertUserName()

  insertUserName : ->
    $el = $(@getDOMNode())
    pos = $el.offset()
    display_name = if @props.hide_face then 'Anonymous' else @data().name
    $name = $("<span class='hover_avatar_name'>#{display_name}</span>")
    $('body').append $name   # ugly!

    $name.css 
      left: pos.left - $name.width() / 2 + $el.width()/2
      top: pos.top - $name.height()

  showDetails : (ev) -> 
    @local.show_details = true
    save(@local)

  hideDetails : (ev) -> 
    $('.hover_avatar_name').remove()
    @local.show_details = false
    save(@local)




AutoGrowTextArea = ReactiveComponent
  displayName: 'AutoGrowTextArea'  

  autoGrow : -> 
    scroll_height = @getDOMNode().scrollHeight
    if scroll_height > @getDOMNode().clientHeight
      @local.height = scroll_height + 5
      save(@local)

  render : -> 
    if !@local.height
      @local.height = @props.min_height

    @transferPropsTo R.textarea onKeyUp: @autoGrow, style: {height: @local.height} 


CharacterCountTextInput = ReactiveComponent
  displayName: 'CharacterCountTextInput'
  componentWillMount : -> @data(@local_key).count = 0
  render : -> 
    class_name = "is_counted"
    R.div style: {position: 'relative'}, 
      @transferPropsTo R.textarea className: class_name, onChange: (=>
         @local.count = $(@getDOMNode()).find('textarea').val().length
         save(@local))
      R.span className: 'count', @props.maxLength - @local.count




##
# AuthHeader
# Should be refactored into Auth. Shares styles with Slider.
AuthHeader = ReactiveComponent
  displayName: 'AuthHeader'

  componentDidMount : -> 
    root = @data('root')
    # Mike note: Wondering why we are setting up the slider here, and
    # why we need to compute the default for your_opinion.stance here.
    #
    # I'd imagine that ideally, this component would assume that there
    # is a your_opinion_key, and that there is a stance, and that the
    # default was already set.
    stance = (root.your_opinion_key and @data(root.your_opinion_key).stance) or 0
    $slider_base = $(@getDOMNode()).find('.slider_base')
    if !$slider_base.hasClass "ui-slider"
      $slider_base.slider
        disabled: true
        min: -1
        max: 1
        step: .01
        value: -stance

  toggleAuthMode : -> 
    root = @data('root')
    current_user = @data('/current_user')
    root.auth_mode = if root.auth_mode == 'register' then 'login' else 'register'
    current_user.errors = {}
    save(root)

  render : ->
    root = @data('root')
    stance =  @data(root.your_opinion_key).stance
    segment = @data(root.your_opinion_key).stance_segment

    # Can't be dynamically set b/c of integration with asset fingerprinting. This is 
    # also why this file is ERB
    if segment == 3
      bubblemouth_src = "<%= asset_path 'bubblemouth_neutral-crafting.png' %>"
    else
      bubblemouth_src = "<%= asset_path 'bubblemouth-crafting.png' %>"

    slider_feedback = 'Please Introduce Yourself' 

    mouth_scaler = if segment > 3 then -1 else 1
    mouth_x =      if segment == 3 then 0 else -7.5


    bubble_mouth_props = 
      transform: "scale(#{mouth_scaler * 1.5}, 1.5) translate(#{mouth_x * 1.5}px, 7px)"
    handle_props = 
      transform: "scale(2.5) translateY(-8px)"

    crossbrowserTransformProperty = (props) -> _.extend props,
      '-webkit-transform' : props.transform
      '-ms-transform' : props.transform
      '-moz-transform' : props.transform

    crossbrowserTransformProperty bubble_mouth_props
    crossbrowserTransformProperty handle_props

    R.div className: 'slider', 
      R.div className:'slider_base', style : {width: HISTOGRAM_WIDTH}, 
        R.div className: 'ui-slider-handle', 
          R.div className: 'the_handle', onClick: @togglePage, style: handle_props
          R.img className:'bubblemouth', src: bubblemouth_src, style: bubble_mouth_props
          R.div className:'slider_feedback', 
            slider_feedback

            if root.auth_mode in ['login', 'register']
              R.div className: 'switch_auth_mode', 
                R.span null, if root.auth_mode == 'register' then 'If you already have an account, ' else 'If you don\'t have an account, '
                R.a className: 'toggle_auth', onClick: @toggleAuthMode, if root.auth_mode == 'register' then 'Log In' else 'Create an Account'


Auth = ReactiveComponent
  displayName: 'Auth'

  componentDidMount : -> 
    $(document).scrollTop $(@getDOMNode()).find('.slider_feedback').offset().top - 10

  startThirdPartyAuth : (provider) ->

    root = @data('root')
    new ThirdPartyAuthHandler
      provider : provider
      callback : (new_current_user) => 
        # Yay we got a new current_user object!  But this hasn't gone
        # through the normal arest channel, so we gotta save it in
        # sneakily with updateCache()
        arest.updateCache(new_current_user)

        # We know that the user has authenticated, but we don't know
        # whether they've completed OUR registration process including
        # the pledge.  The server tells us this via the existence of a
        # `user' object in current_user.
        if new_current_user.user
          # We are logged in!  The user has completed registration.
          # Let's transition to results.
          root.page_name = 'results'
          root.auth_mode = null
          if new_current_user.csrf
            arest.csrf(new_current_user.csrf)

          # @publishOpinionsAfterAuth()
          save(root)
        else 
          # We still need to show the pledge!
          root.auth_mode = 'register'
          save(root)

  submitAuth : (ev) -> 
    ev.preventDefault()
    save(@get('/current_user'))

        # # hack for submitting file data in ActiveREST for now
        # # we'll just submit the file form after user is signed in
        # if submit_avatar_form
        #   $('#user_avatar_form').ajaxSubmit
        #     type: 'PUT'
        #     data: 
        #       authenticity_token: current_user.csrf
        #     success: (data, status, xhr) -> 
        #       current_user.user = data.key
        #       current_user.errors = if data.errors then data.errors else []
        #       current_user.csrf = data.csrf
        #       current_user.name = data.name
        #       save(current_user)

  sendPasswordReminder : -> 
    email = @data('/current_user').email
    $.post Routes.send_password_reset_token_path(), {user : {email: email}}, (data) =>
      if data.errors && data.errors.length > 0
        current_user = @data('/current_user')
        current_user.errors = data.errors
        save(current_user)
      else 
        root = @data('root')
        root.auth_mode = 'password_reminder'
        save(root)

  # publishOpinionsAfterAuth: -> 
  #   # publish any opinions that were awaiting authorization
  #   your_opinion = @data your_opinion_key
  #   if your_opinion.publish_pending_authorization
  #     delete your_opinion['publish_pending_authorization']
  #     your_opinion.published = true
  #     save your_opinion

  render: -> 
    current_user = @data('/current_user')
    root = @data('root')

    # Once the user logs in, we will stop showing the log-in screen
    if current_user.logged_in
      root.auth_mode = null
      # @publishOpinionsAfterAuth()

      save(root)
      setTimeout((() -> togglePage('results')), 700)
      return loading_indicator

    focal_wrapper_style = 
      left: '50%'
      width: DECISION_BOARD_WIDTH
      marginLeft: -DECISION_BOARD_WIDTH / 2

    # Let's set up some useful helpers
    input_box = (name, placeholder, type, onChange, pattern) ->
      type = type || 'text'
      onChange = onChange || (event) => current_user[name] = event.target.value
      R.input
        id: 'user_' + name
        defaultValue: current_user[name]
        name: "user[#{name}]"
        placeholder: placeholder
        required: "required"
        type: type
        onChange: onChange
        pattern: pattern

    name_input_field     = input_box('name', 'first and last name')
    email_input_field    = input_box('email', 'email@address', 'email')
    password_input_field =
      input_box('password',
                 if root.auth_mode == 'login' then "password" else "new password",
                 'password',
                 null,
                 if root.auth_mode == 'register' then ".{5,}" else '')

    password_reset_token_field =
      R.input
        id: "user_verification_code"
        name: "user[password_code]"
        placeholder: "verification code"
        required: "required"
        type: "text"
        onChange: (event) => current_user.password_reset = {
            token: event.target.value,
            generate_new_token: false
          }

    providers = ['facebook', 'google']
    if root.auth_mode in ['login', 'password_reminder']
      providers.push('twitter')

    R.div className:'auth_region focal_wrapper', style: focal_wrapper_style,
      AuthHeader()

      R.div className:'auth focal_area',
        if root.auth_mode in ['login', 'register'] && !current_user.provider
          R.div className: 'third_party_auth',
            R.label className: 'third_party_call', 'Instantly:'
            for provider in providers
              do (provider) =>
                R.button className: "third_party_option #{provider}", onClick: (=> @startThirdPartyAuth(provider)),
                  R.i className: "fa fa-#{provider}"
                  R.span null, provider

            R.div className: 'separator', dangerouslySetInnerHTML:{__html: "&mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;  <label>or</label>  &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash;"}

        if root.auth_mode in ['login', 'password_reminder']
          # logging in

          R.div null, 
            R.label className: 'auth_section_label', if root.auth_mode == 'login' then 'By email address:' else 'Change your password to login'

            R.table className: 'auth_fields login', 
              R.tr null, 
                R.td className: 'label_cell',
                  if root.auth_mode == 'login'  
                    R.label htmlFor: 'user_email', 'email:'
                R.td className: 'field_cell',
                  email_input_field

              R.tr null, 
                R.td className: 'label_cell', 
                  switch root.auth_mode
                    when 'login'
                      R.label htmlFor: 'user_password', 'password:'
                    when 'password_reminder'
                      R.label htmlFor: 'user_password', 'new password:'

                R.td className: 'field_cell', 
                  password_input_field,
                  if root.auth_mode == 'login'
                    R.a className: 'forgot_password', onClick: @sendPasswordReminder, 'I forgot! Email me password instructions.'

              if root.auth_mode == 'password_reminder'
                R.tr null, 
                  R.td className: 'label_cell', 
                    R.label htmlFor: 'user_verification_code', 'verification code:'

                  R.td className: 'field_cell', 
                    password_reset_token_field,
                    R.div className: 'password_verification_explanation', "Find code in an email just sent to you."

        else 
          # creating new account
          R.table className: 'auth_fields register', 
            R.tr null, 
              R.td className: 'label_cell',
                R.label htmlFor: 'user_name', 'Hi, my name is:'
              R.td className: 'field_cell', 
                name_input_field
            if current_user.provider
              p = current_user.provider # will be 'facebook', 'google', or 'twitter'
              R.tr null, 

                R.td className: 'label_cell',
                  R.label htmlFor: 'user_provider', 'I login via:'
                R.td className: 'field_cell', 
                  R.button className: "third_party_option #{p}", style: {cursor: 'default'},
                    R.i className: "fa fa-#{p}"
                    R.span null, p

            else

              R.tr null, 

                R.td className: 'label_cell',
                  R.label htmlFor: 'user_email', 'I login as:'
                R.td className: 'field_cell', 
                  email_input_field,
                  password_input_field

            R.tr null, 
              R.td className: 'label_cell', 
                R.label htmlFor: 'user_avatar', 'I look like this:'
              R.td className: 'field_cell',
                # hack for submitting file data in ActiveREST for now
                # we'll just submit the file form after user is signed in
                R.form id: 'user_avatar_form',action: Routes.current_user_path(), 

                  R.div className: 'avatar_preview_enclosure',
                    R.img id: 'avatar_preview', src: if current_user.image_url then current_user.image_url else null #todo: make sure that if user overrides image_url, that the new image is used
                
                  R.input id: 'user_avatar', name: "user[avatar]", type: "file", onChange: (ev) -> 
                    input = $('#user_avatar')[0]
                    if input.files && input.files[0]
                      reader = new FileReader()
                      reader.onload = (e) ->
                        $("#avatar_preview").attr 'src', e.target.result
                      reader.readAsDataURL input.files[0]
                      current_user.avatar_file_name = input.files[0]
                    else
                      $("#avatar_preview").attr('src', "<%= asset_path 'no_image_preview.png' %>")
                      

            R.tr null,
              R.td className: 'label_cell', 
                R.label null, 'Community pledge:'
              R.td className: 'field_cell',
                R.ul className: 'pledges',
                  R.li className: 'pledge', 
                    R.input className:'pledge-1', type:'checkbox', id:"pledge-1", name:"pledge-1"
                    R.label htmlFor: "pledge-1", 'I will not attack or mock others.'
                  R.li className: 'pledge', 
                    R.input className:'pledge-2', type:'checkbox', id:"pledge-2", name:"pledge-2"
                    R.label htmlFor: "pledge-2", 'I will speak only on behalf of myself.'
                  R.li className: 'pledge', 
                    R.input className:'pledge-3', type:'checkbox', id:"pledge-3", name:"pledge-3"
                    R.label htmlFor: "pledge-3", 'I will use only one account to participate.'



        if current_user.errors && current_user.errors.length > 0
          R.div className: "auth_errors", 
            R.i className: 'fa fa-exclamation-circle'
            R.span null, "#{current_user.errors.join(', ')}"


      R.div null, 
        R.div 
          className:'auth_button primary_button'
          onClick: @submitAuth
        , if root.auth_mode == 'register' then 'Create account and save your opinion' else 'Login and save your opinion'

        R.a 
          className:'cancel_auth_button primary_cancel_button'
          onClick: (=>
            root.auth_mode = null
            root.publish_this_opinion = null
            save(root))
        , 'cancel log in'


Root = ReactiveComponent
  displayName: 'Root'

  render : -> 
    root = @data('root')

    # Update the location bar if it's different
    url = "/#{@props.long_id}#{if root.page_name == 'results' then '/results' else ''}"
    if (window.location.pathname != url)
      window.app_router.navigate url, {trigger : true}

    # Now let's render
    Page key: "/page/#{@props.long_id}"

Page = ReactiveComponent
  displayName: 'Page'
  render: ->
    root = @data('root')
    R.div 'data-authmode': root.auth_mode, #authmode controls styling during authentication process
      Header()
      R.div id: 'body', style : { minWidth: PAGE_WIDTH }, 
        R.div id: 'inner_body', #style : { width: CONTENT_WIDTH },
          Proposal key: @page.proposal.key
      Footer()
      Computer() # Doesn't actually render anything

Computer = ReactiveComponent
  # This doesn't actually render anything.  It just processes state
  # changes to current_user for CSRF and logging in and out.
  displayName: 'Computer'
  render : ->
    current_user = @data('/current_user')
    if current_user.csrf
      arest.csrf(current_user.csrf)

    # If the user changed, reload the current opinion
    # This will need to be updated with better arest
    if current_user.user != @local.last_curr_user
      console.log("COMPUTER: New currnet_user: #{current_user.user}, last: #{@local.last_curr_user}")
      if @local.last_curr_user
        current_proposal = @data('root').current_proposal
        console.log('Forcing refetch of current_proposal',current_proposal)
        arest.serverFetch(@data('root').current_proposal)
      @local.last_curr_user = current_user.user
      save(@local)

    # Publish this opinion if we can
    root = @data('root')
    if root.publish_this_opinion and current_user.logged_in
      opinion = @data(root.your_opinion_key)
      opinion.published = true
      root.publish_this_opinion = false
      save(root)
      save(opinion)

    return R.span null, ''



Header = ReactiveComponent
  displayName: 'Header'
  logout : -> 
    current_user = @data('/current_user')
    current_user.logged_in = false

    root = @data('root')
    root.auth_mode = null

    save(current_user)
    save(root)

  render : ->
    current_user = @data('/current_user')
    root = @data('root')
    customer = @data('customer')

    R.div className: 'l_header',       
      if customer.identifier == 'cityoftigard'
        R.img className: 'logo', src: "<%= asset_path 'cityoftigard/logo.png' %>", style: {height: '86px', position: 'absolute', bottom: '-38px', zIndex: 999999}

      R.div style: {
          'background-color': '#eee',
          'color': '#f00',
          'padding': '5px 20px',
          'display' : if root.server_error then 'block'  else 'none'
        },
        'Warning: there was a server error!'

      if customer.identifier == 'cityoftigard'
        R.a href: 'http://www.tigard-or.gov/', target: '_blank',
          R.img className: 'logo', src: "<%= asset_path 'cityoftigard/logo.png' %>", style: {height: '86px', position: 'absolute', bottom: '-38px', zIndex: 999999}

      if current_user.logged_in
        R.div className: 'userbar', 
          Avatar key: current_user.user, tag: R.span, className: 'userbar_avatar', style: {height: 20, width: 20}
          R.a 'data-action': 'logout', onClick: @logout, 'logout'


Footer = ReactiveComponent
  displayName: 'Footer'
  render : -> 
    R.div className: 'l_footer',
      "Technology by "
      R.a href: 'http://consider.it', target: '_blank', 'Considerit'
      R.span className: 'separator', '•'
      'Bug to report? '
      R.a href: "mailto:admin@consider.it", 'Email us'


# Tracks data useful for responsive layouts.
$(document).ready ->
  updateMedia()
  $(window).on "resize", -> updateMedia()

updateMedia = ->
  console.log 'HI'
  media = fetch('media')
  media.height = $(window).height()
  media.width = $(window).width()
  save media



## ########################
## Initialize defaults for client data

fetch 'histogram',
  highlighted_users : null
  selected_segment : [null, null]

fetch 'slider',
  has_moved : false
  is_moving : false
  stance : 0
  stance_segment : getStanceSegment 0

fetch 'decisionboard',
  sticky : false

fetch 'root',
  page_name : 'crafting'
  auth_mode : null
  your_opinion_key : null
  current_proposal : null
  publish_this_opinion : false

fetch('/current_user')


##
# load users' pictures
$.get Routes.get_avatars_path(), (data) -> $('head').append data


##
# Backbone routing
# Note: not committed to backbone. Want to experiment with other routing techniques too.
top_level_component = null
Router = Backbone.Router.extend

  routes :
    ":proposal(/)": "proposal"
    ":proposal/results(/)": "results"

  proposal : (long_id, page = 'crafting') ->
    root = fetch('root')
    root.page_name = page
    save(root)

    if !top_level_component
      top_level_component = React.renderComponent Root(
                                         long_id : long_id
                                         ), document.getElementById('content')

      


  results : (long_id) -> @proposal long_id, 'results'

window.app_router = new Router()
window.on_ajax_error = () ->
  (root = fetch('root')).server_error = true
  save(root)
window.on_client_error = (e) ->
  save({ key: '/new/error', stack: JSON.stringify(e.stack) })
$(document).ready -> Backbone.history.start {pushState: true}
